{"version":3,"file":"js/530.f6edd90c.js","mappings":"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","sources":["webpack://osi/./node_modules/music-metadata/lib/ogg/opus/Opus.js","webpack://osi/./node_modules/music-metadata/lib/ogg/opus/OpusStream.js","webpack://osi/./node_modules/music-metadata/lib/ogg/speex/Speex.js","webpack://osi/./node_modules/music-metadata/lib/ogg/speex/SpeexStream.js","webpack://osi/./node_modules/music-metadata/lib/ogg/theora/Theora.js","webpack://osi/./node_modules/music-metadata/lib/ogg/theora/TheoraStream.js","webpack://osi/./node_modules/music-metadata/lib/ogg/OggToken.js","webpack://osi/./node_modules/music-metadata/lib/ogg/flac/FlacStream.js","webpack://osi/./node_modules/music-metadata/lib/ogg/OggParser.js","webpack://osi/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js","webpack://osi/./node_modules/music-metadata/lib/ogg/vorbis/VorbisStream.js","webpack://osi/./node_modules/music-metadata/lib/flac/FlacParser.js","webpack://osi/./node_modules/music-metadata/lib/flac/FlacToken.js","webpack://osi/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","webpack://osi/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\r\nexport class OpusContentError extends makeUnexpectedFileContentError('Opus') {\r\n}\r\n/**\r\n * Opus ID Header parser\r\n * Ref: https://wiki.xiph.org/OggOpus#ID_Header\r\n */\r\nexport class IdHeader {\r\n    constructor(len) {\r\n        if (len < 19) {\r\n            throw new OpusContentError('ID-header-page 0 should be at least 19 bytes long');\r\n        }\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            magicSignature: new Token.StringType(8, 'ascii').get(buf, off + 0),\r\n            version: Token.UINT8.get(buf, off + 8),\r\n            channelCount: Token.UINT8.get(buf, off + 9),\r\n            preSkip: Token.UINT16_LE.get(buf, off + 10),\r\n            inputSampleRate: Token.UINT32_LE.get(buf, off + 12),\r\n            outputGain: Token.UINT16_LE.get(buf, off + 16),\r\n            channelMapping: Token.UINT8.get(buf, off + 18)\r\n        };\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport { VorbisStream } from '../vorbis/VorbisStream.js';\r\nimport * as Opus from './Opus.js';\r\nimport { OpusContentError } from './Opus.js';\r\n/**\r\n * Opus parser\r\n * Internet Engineering Task Force (IETF) - RFC 6716\r\n * Used by OggStream\r\n */\r\nexport class OpusStream extends VorbisStream {\r\n    constructor(metadata, options, tokenizer) {\r\n        super(metadata, options);\r\n        this.idHeader = null;\r\n        this.lastPos = -1;\r\n        this.tokenizer = tokenizer;\r\n        this.durationOnLastPage = true;\r\n    }\r\n    /**\r\n     * Parse first Opus Ogg page\r\n     * @param {IPageHeader} header\r\n     * @param {Uint8Array} pageData\r\n     */\r\n    parseFirstPage(_header, pageData) {\r\n        this.metadata.setFormat('codec', 'Opus');\r\n        // Parse Opus ID Header\r\n        this.idHeader = new Opus.IdHeader(pageData.length).get(pageData, 0);\r\n        if (this.idHeader.magicSignature !== \"OpusHead\")\r\n            throw new OpusContentError(\"Illegal ogg/Opus magic-signature\");\r\n        this.metadata.setFormat('sampleRate', this.idHeader.inputSampleRate);\r\n        this.metadata.setFormat('numberOfChannels', this.idHeader.channelCount);\r\n        this.metadata.setAudioOnly();\r\n    }\r\n    async parseFullPage(pageData) {\r\n        const magicSignature = new Token.StringType(8, 'ascii').get(pageData, 0);\r\n        switch (magicSignature) {\r\n            case 'OpusTags':\r\n                await this.parseUserCommentList(pageData, 8);\r\n                this.lastPos = this.tokenizer.position - pageData.length;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n    calculateDuration(enfOfStream) {\r\n        if (this.lastPageHeader && (enfOfStream || this.lastPageHeader.headerType.lastPage) && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\r\n            // Calculate duration\r\n            const pos_48bit = this.lastPageHeader.absoluteGranulePosition - this.idHeader.preSkip;\r\n            this.metadata.setFormat('numberOfSamples', pos_48bit);\r\n            this.metadata.setFormat('duration', pos_48bit / 48000);\r\n            if (this.lastPos !== -1 && this.tokenizer.fileInfo.size && this.metadata.format.duration) {\r\n                const dataSize = this.tokenizer.fileInfo.size - this.lastPos;\r\n                this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\r\n            }\r\n        }\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport * as util from '../../common/Util.js';\r\n/**\r\n * Speex Header Packet\r\n * Ref: https://www.speex.org/docs/manual/speex-manual/node8.html#SECTION00830000000000000000\r\n */\r\nexport const Header = {\r\n    len: 80,\r\n    get: (buf, off) => {\r\n        return {\r\n            speex: new Token.StringType(8, 'ascii').get(buf, off + 0),\r\n            version: util.trimRightNull(new Token.StringType(20, 'ascii').get(buf, off + 8)),\r\n            version_id: Token.INT32_LE.get(buf, off + 28),\r\n            header_size: Token.INT32_LE.get(buf, off + 32),\r\n            rate: Token.INT32_LE.get(buf, off + 36),\r\n            mode: Token.INT32_LE.get(buf, off + 40),\r\n            mode_bitstream_version: Token.INT32_LE.get(buf, off + 44),\r\n            nb_channels: Token.INT32_LE.get(buf, off + 48),\r\n            bitrate: Token.INT32_LE.get(buf, off + 52),\r\n            frame_size: Token.INT32_LE.get(buf, off + 56),\r\n            vbr: Token.INT32_LE.get(buf, off + 60),\r\n            frames_per_packet: Token.INT32_LE.get(buf, off + 64),\r\n            extra_headers: Token.INT32_LE.get(buf, off + 68),\r\n            reserved1: Token.INT32_LE.get(buf, off + 72),\r\n            reserved2: Token.INT32_LE.get(buf, off + 76)\r\n        };\r\n    }\r\n};\r\n","import initDebug from 'debug';\r\nimport { VorbisStream } from '../vorbis/VorbisStream.js';\r\nimport * as Speex from './Speex.js';\r\nconst debug = initDebug('music-metadata:parser:ogg:speex');\r\n/**\r\n * Speex, RFC 5574\r\n * Ref:\r\n * - https://www.speex.org/docs/manual/speex-manual/\r\n * - https://tools.ietf.org/html/rfc5574\r\n */\r\nexport class SpeexStream extends VorbisStream {\r\n    constructor(metadata, options, _tokenizer) {\r\n        super(metadata, options);\r\n    }\r\n    /**\r\n     * Parse first Speex Ogg page\r\n     * @param {IPageHeader} header\r\n     * @param {Uint8Array} pageData\r\n     */\r\n    parseFirstPage(_header, pageData) {\r\n        debug('First Ogg/Speex page');\r\n        const speexHeader = Speex.Header.get(pageData, 0);\r\n        this.metadata.setFormat('codec', `Speex ${speexHeader.version}`);\r\n        this.metadata.setFormat('numberOfChannels', speexHeader.nb_channels);\r\n        this.metadata.setFormat('sampleRate', speexHeader.rate);\r\n        if (speexHeader.bitrate !== -1) {\r\n            this.metadata.setFormat('bitrate', speexHeader.bitrate);\r\n        }\r\n        this.metadata.setAudioOnly();\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\n/**\r\n * 6.2 Identification Header\r\n * Ref: https://theora.org/doc/Theora.pdf: 6.2 Identification Header Decode\r\n */\r\nexport const IdentificationHeader = {\r\n    len: 42,\r\n    get: (buf, off) => {\r\n        return {\r\n            id: new Token.StringType(7, 'ascii').get(buf, off),\r\n            vmaj: Token.UINT8.get(buf, off + 7),\r\n            vmin: Token.UINT8.get(buf, off + 8),\r\n            vrev: Token.UINT8.get(buf, off + 9),\r\n            vmbw: Token.UINT16_BE.get(buf, off + 10),\r\n            vmbh: Token.UINT16_BE.get(buf, off + 17),\r\n            nombr: Token.UINT24_BE.get(buf, off + 37),\r\n            nqual: Token.UINT8.get(buf, off + 40)\r\n        };\r\n    }\r\n};\r\n","import initDebug from 'debug';\r\nimport { IdentificationHeader } from './Theora.js';\r\nconst debug = initDebug('music-metadata:parser:ogg:theora');\r\n/**\r\n * Ref:\r\n * - https://theora.org/doc/Theora.pdf\r\n */\r\nexport class TheoraStream {\r\n    constructor(metadata, _options, _tokenizer) {\r\n        this.durationOnLastPage = false;\r\n        this.metadata = metadata;\r\n    }\r\n    /**\r\n     * Vorbis 1 parser\r\n     * @param header Ogg Page Header\r\n     * @param pageData Page data\r\n     */\r\n    async parsePage(header, pageData) {\r\n        if (header.headerType.firstPage) {\r\n            await this.parseFirstPage(header, pageData);\r\n        }\r\n    }\r\n    calculateDuration() {\r\n        debug('duration calculation not implemented');\r\n    }\r\n    /**\r\n     * Parse first Theora Ogg page. the initial identification header packet\r\n     */\r\n    async parseFirstPage(_header, pageData) {\r\n        debug('First Ogg/Theora page');\r\n        this.metadata.setFormat('codec', 'Theora');\r\n        const idHeader = IdentificationHeader.get(pageData, 0);\r\n        this.metadata.setFormat('bitrate', idHeader.nombr);\r\n        this.metadata.setFormat('hasVideo', true);\r\n    }\r\n    flush() {\r\n        return Promise.resolve();\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport * as util from '../common/Util.js';\r\nimport { StringType } from 'token-types';\r\nexport const PageHeader = {\r\n    len: 27,\r\n    get: (buf, off) => {\r\n        return {\r\n            capturePattern: new StringType(4, 'latin1').get(buf, off),\r\n            version: Token.UINT8.get(buf, off + 4),\r\n            headerType: {\r\n                continued: util.getBit(buf, off + 5, 0),\r\n                firstPage: util.getBit(buf, off + 5, 1),\r\n                lastPage: util.getBit(buf, off + 5, 2)\r\n            },\r\n            // packet_flag: Token.UINT8.get(buf, off + 5),\r\n            absoluteGranulePosition: Number(Token.UINT64_LE.get(buf, off + 6)),\r\n            streamSerialNumber: Token.UINT32_LE.get(buf, off + 14),\r\n            pageSequenceNo: Token.UINT32_LE.get(buf, off + 18),\r\n            pageChecksum: Token.UINT32_LE.get(buf, off + 22),\r\n            page_segments: Token.UINT8.get(buf, off + 26)\r\n        };\r\n    }\r\n};\r\nexport class SegmentTable {\r\n    static sum(buf, off, len) {\r\n        const dv = new DataView(buf.buffer, 0);\r\n        let s = 0;\r\n        for (let i = off; i < off + len; ++i) {\r\n            s += dv.getUint8(i);\r\n        }\r\n        return s;\r\n    }\r\n    constructor(header) {\r\n        this.len = header.page_segments;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            totalPageSize: SegmentTable.sum(buf, off, this.len)\r\n        };\r\n    }\r\n}\r\n","import initDebug from 'debug';\r\nimport * as Flac from '../../flac/FlacToken.js';\r\nimport { FlacParser } from '../../flac/FlacParser.js';\r\nimport { FourCcToken } from '../../common/FourCC.js';\r\nimport { VorbisPictureToken } from '../vorbis/Vorbis.js';\r\nconst debug = initDebug('music-metadata:parser:ogg:theora');\r\n/**\r\n * Ref:\r\n * - https://xiph.org/flac/ogg_mapping.html\r\n */\r\nexport class FlacStream {\r\n    constructor(metadata, options, tokenizer) {\r\n        this.durationOnLastPage = false;\r\n        this.metadata = metadata;\r\n        this.options = options;\r\n        this.tokenizer = tokenizer;\r\n        this.flacParser = new FlacParser(this.metadata, this.tokenizer, options);\r\n    }\r\n    /**\r\n     * Vorbis 1 parser\r\n     * @param header Ogg Page Header\r\n     * @param pageData Page data\r\n     */\r\n    async parsePage(header, pageData) {\r\n        if (header.headerType.firstPage) {\r\n            await this.parseFirstPage(header, pageData);\r\n        }\r\n    }\r\n    calculateDuration() {\r\n        debug('duration calculation not implemented');\r\n    }\r\n    /**\r\n     * Parse first Theora Ogg page. the initial identification header packet\r\n     */\r\n    async parseFirstPage(_header, pageData) {\r\n        debug('First Ogg/FLAC page');\r\n        const fourCC = await FourCcToken.get(pageData, 9);\r\n        if (fourCC.toString() !== 'fLaC') {\r\n            throw new Error('Invalid FLAC preamble');\r\n        }\r\n        const blockHeader = await Flac.BlockHeader.get(pageData, 13);\r\n        await this.parseDataBlock(blockHeader, pageData.subarray(13 + Flac.BlockHeader.len));\r\n    }\r\n    async parseDataBlock(blockHeader, pageData) {\r\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\r\n        switch (blockHeader.type) {\r\n            case Flac.BlockType.STREAMINFO: {\r\n                const streamInfo = Flac.BlockStreamInfo.get(pageData, 0);\r\n                return this.flacParser.processsStreamInfo(streamInfo);\r\n            }\r\n            case Flac.BlockType.PADDING:\r\n                break;\r\n            case Flac.BlockType.APPLICATION:\r\n                break;\r\n            case Flac.BlockType.SEEKTABLE:\r\n                break;\r\n            case Flac.BlockType.VORBIS_COMMENT:\r\n                return this.flacParser.parseComment(pageData);\r\n            case Flac.BlockType.PICTURE:\r\n                if (!this.options.skipCovers) {\r\n                    const picture = new VorbisPictureToken(pageData.length).get(pageData, 0);\r\n                    return this.flacParser.addPictureTag(picture);\r\n                }\r\n                break;\r\n            default:\r\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\r\n        }\r\n        // Ignore data block\r\n        return this.tokenizer.ignore(blockHeader.length).then();\r\n    }\r\n    flush() {\r\n        return Promise.resolve();\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport { EndOfStreamError } from 'strtok3';\r\nimport initDebug from 'debug';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { VorbisStream } from './vorbis/VorbisStream.js';\r\nimport { OpusStream } from './opus/OpusStream.js';\r\nimport { SpeexStream } from './speex/SpeexStream.js';\r\nimport { TheoraStream } from './theora/TheoraStream.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nimport { PageHeader, SegmentTable } from './OggToken.js';\r\nimport { FlacStream } from './flac/FlacStream.js';\r\nexport class OggContentError extends makeUnexpectedFileContentError('Ogg') {\r\n}\r\nconst debug = initDebug('music-metadata:parser:ogg');\r\nclass OggStream {\r\n    constructor(metadata, streamSerial, options) {\r\n        this.pageNumber = 0;\r\n        this.closed = false;\r\n        this.metadata = metadata;\r\n        this.streamSerial = streamSerial;\r\n        this.options = options;\r\n    }\r\n    async parsePage(tokenizer, header) {\r\n        this.pageNumber = header.pageSequenceNo;\r\n        debug('serial=%s page#=%s, Ogg.id=%s', header.streamSerialNumber, header.pageSequenceNo, header.capturePattern);\r\n        const segmentTable = await tokenizer.readToken(new SegmentTable(header));\r\n        debug('totalPageSize=%s', segmentTable.totalPageSize);\r\n        const pageData = await tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\r\n        debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\r\n        if (header.headerType.firstPage) {\r\n            this.metadata.setFormat('container', 'Ogg');\r\n            const idData = pageData.subarray(0, 7); // Copy this portion\r\n            const asciiId = Array.from(idData)\r\n                .filter(b => b >= 32 && b <= 126) // Keep only printable ASCII\r\n                .map(b => String.fromCharCode(b))\r\n                .join('');\r\n            switch (asciiId) {\r\n                case 'vorbis': // Ogg/Vorbis\r\n                    debug(`Set Ogg stream serial ${header.streamSerialNumber}, codec=Vorbis`);\r\n                    this.pageConsumer = new VorbisStream(this.metadata, this.options);\r\n                    break;\r\n                case 'OpusHea': // Ogg/Opus\r\n                    debug('Set page consumer to Ogg/Opus');\r\n                    this.pageConsumer = new OpusStream(this.metadata, this.options, tokenizer);\r\n                    break;\r\n                case 'Speex  ': // Ogg/Speex\r\n                    debug('Set page consumer to Ogg/Speex');\r\n                    this.pageConsumer = new SpeexStream(this.metadata, this.options, tokenizer);\r\n                    break;\r\n                case 'fishead':\r\n                case 'theora': // Ogg/Theora\r\n                    debug('Set page consumer to Ogg/Theora');\r\n                    this.pageConsumer = new TheoraStream(this.metadata, this.options, tokenizer);\r\n                    break;\r\n                case 'FLAC': // Ogg/Theora\r\n                    debug('Set page consumer to Vorbis');\r\n                    this.pageConsumer = new FlacStream(this.metadata, this.options, tokenizer);\r\n                    break;\r\n                default:\r\n                    throw new OggContentError(`Ogg codec not recognized (id=${asciiId}`);\r\n            }\r\n        }\r\n        if (header.headerType.lastPage) {\r\n            this.closed = true;\r\n        }\r\n        if (this.pageConsumer) {\r\n            await this.pageConsumer.parsePage(header, pageData);\r\n        }\r\n        else\r\n            throw new Error('pageConsumer should be initialized');\r\n    }\r\n}\r\n/**\r\n * Parser for Ogg logical bitstream framing\r\n */\r\nexport class OggParser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.streams = new Map();\r\n    }\r\n    /**\r\n     * Parse page\r\n     * @returns {Promise<void>}\r\n     */\r\n    async parse() {\r\n        this.streams = new Map();\r\n        let enfOfStream = false;\r\n        let header;\r\n        try {\r\n            do {\r\n                header = await this.tokenizer.readToken(PageHeader);\r\n                if (header.capturePattern !== 'OggS')\r\n                    throw new OggContentError('Invalid Ogg capture pattern');\r\n                let stream = this.streams.get(header.streamSerialNumber);\r\n                if (!stream) {\r\n                    stream = new OggStream(this.metadata, header.streamSerialNumber, this.options);\r\n                    this.streams.set(header.streamSerialNumber, stream);\r\n                }\r\n                await stream.parsePage(this.tokenizer, header);\r\n                if (stream.pageNumber > 12 && !(this.options.duration && [...this.streams.values()].find(stream => stream.pageConsumer?.durationOnLastPage))) {\r\n                    debug(\"Stop processing Ogg stream\");\r\n                    break;\r\n                }\r\n            } while (![...this.streams.values()].every(item => item.closed));\r\n        }\r\n        catch (err) {\r\n            if (err instanceof EndOfStreamError) {\r\n                debug(\"Reached end-of-stream\");\r\n                enfOfStream = true;\r\n            }\r\n            else if (err instanceof OggContentError) {\r\n                this.metadata.addWarning(`Corrupt Ogg content at ${this.tokenizer.position}`);\r\n            }\r\n            else\r\n                throw err;\r\n        }\r\n        for (const stream of this.streams.values()) {\r\n            if (!stream.closed) {\r\n                this.metadata.addWarning(`End-of-stream reached before reaching last page in Ogg stream serial=${stream.streamSerial}`);\r\n                await stream.pageConsumer?.flush();\r\n            }\r\n            stream.pageConsumer?.calculateDuration(enfOfStream);\r\n        }\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\r\n/**\r\n * Parse the METADATA_BLOCK_PICTURE\r\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\r\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\r\n * // ToDo: move to ID3 / APIC?\r\n */\r\nexport class VorbisPictureToken {\r\n    static fromBase64(base64str) {\r\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\r\n    }\r\n    static fromBuffer(buffer) {\r\n        const pic = new VorbisPictureToken(buffer.length);\r\n        return pic.get(buffer, 0);\r\n    }\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buffer, offset) {\r\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\r\n        offset += 4;\r\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\r\n        offset += mimeLen;\r\n        const descLen = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\r\n        offset += descLen;\r\n        const width = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const height = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const data = buffer.slice(offset, offset + picDataLen);\r\n        return {\r\n            type,\r\n            format,\r\n            description,\r\n            width,\r\n            height,\r\n            colour_depth,\r\n            indexed_color,\r\n            data\r\n        };\r\n    }\r\n}\r\n/**\r\n * Comment header decoder\r\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\r\n */\r\nexport const CommonHeader = {\r\n    len: 7,\r\n    get: (buf, off) => {\r\n        return {\r\n            packetType: Token.UINT8.get(buf, off),\r\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Identification header decoder\r\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\r\n */\r\nexport const IdentificationHeader = {\r\n    len: 23,\r\n    get: (uint8Array, off) => {\r\n        return {\r\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\r\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\r\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\r\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\r\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\r\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\r\n        };\r\n    }\r\n};\r\n","import * as Token from 'token-types';\r\nimport debugInit from 'debug';\r\nimport { VorbisDecoder } from './VorbisDecoder.js';\r\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\r\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\r\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\r\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\r\n}\r\n/**\r\n * Vorbis 1 Parser.\r\n * Used by OggStream\r\n */\r\nexport class VorbisStream {\r\n    constructor(metadata, options) {\r\n        this.pageSegments = [];\r\n        this.durationOnLastPage = true;\r\n        this.metadata = metadata;\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Vorbis 1 parser\r\n     * @param header Ogg Page Header\r\n     * @param pageData Page data\r\n     */\r\n    async parsePage(header, pageData) {\r\n        this.lastPageHeader = header;\r\n        if (header.headerType.firstPage) {\r\n            this.parseFirstPage(header, pageData);\r\n        }\r\n        else {\r\n            if (header.headerType.continued) {\r\n                if (this.pageSegments.length === 0) {\r\n                    throw new VorbisContentError('Cannot continue on previous page');\r\n                }\r\n                this.pageSegments.push(pageData);\r\n            }\r\n            if (header.headerType.lastPage || !header.headerType.continued) {\r\n                // Flush page segments\r\n                if (this.pageSegments.length > 0) {\r\n                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\r\n                    await this.parseFullPage(fullPage);\r\n                }\r\n                // Reset page segments\r\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\r\n            }\r\n        }\r\n    }\r\n    static mergeUint8Arrays(arrays) {\r\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\r\n        const merged = new Uint8Array(totalSize);\r\n        arrays.forEach((array, i, _arrays) => {\r\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\r\n            merged.set(array, offset);\r\n        });\r\n        return merged;\r\n    }\r\n    async flush() {\r\n        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\r\n    }\r\n    async parseUserComment(pageData, offset) {\r\n        const decoder = new VorbisDecoder(pageData, offset);\r\n        const tag = decoder.parseUserComment();\r\n        await this.addTag(tag.key, tag.value);\r\n        return tag.len;\r\n    }\r\n    async addTag(id, value) {\r\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\r\n            if (this.options.skipCovers) {\r\n                debug(\"Ignore picture\");\r\n                return;\r\n            }\r\n            value = VorbisPictureToken.fromBase64(value);\r\n            debug(`Push picture: id=${id}, format=${value.format}`);\r\n        }\r\n        else {\r\n            debug(`Push tag: id=${id}, value=${value}`);\r\n        }\r\n        await this.metadata.addTag('vorbis', id, value);\r\n    }\r\n    calculateDuration(enfOfStream) {\r\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\r\n            // Calculate duration\r\n            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\r\n            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\r\n        }\r\n    }\r\n    /**\r\n     * Parse first Ogg/Vorbis page\r\n     * @param _header\r\n     * @param pageData\r\n     */\r\n    parseFirstPage(_header, pageData) {\r\n        this.metadata.setFormat('codec', 'Vorbis I');\r\n        this.metadata.setFormat('hasAudio', true);\r\n        debug('Parse first page');\r\n        // Parse  Vorbis common header\r\n        const commonHeader = CommonHeader.get(pageData, 0);\r\n        if (commonHeader.vorbis !== 'vorbis')\r\n            throw new VorbisContentError('Metadata does not look like Vorbis');\r\n        if (commonHeader.packetType === 1) {\r\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\r\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\r\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\r\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\r\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\r\n        }\r\n        else\r\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\r\n    }\r\n    async parseFullPage(pageData) {\r\n        // New page\r\n        const commonHeader = CommonHeader.get(pageData, 0);\r\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\r\n        switch (commonHeader.packetType) {\r\n            case 3: //  type 3: comment header\r\n                return this.parseUserCommentList(pageData, CommonHeader.len);\r\n            case 1: // type 1: the identification header\r\n            case 5: // type 5: setup header type\r\n                break; // ignore\r\n        }\r\n    }\r\n    /**\r\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\r\n     */\r\n    async parseUserCommentList(pageData, offset) {\r\n        const strLen = Token.UINT32_LE.get(pageData, offset);\r\n        offset += 4;\r\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\r\n        offset += strLen;\r\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\r\n        offset += 4;\r\n        while (userCommentListLength-- > 0) {\r\n            offset += (await this.parseUserComment(pageData, offset));\r\n        }\r\n    }\r\n}\r\n","import initDebug from 'debug';\r\nimport { Uint8ArrayType } from 'token-types';\r\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\r\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { VorbisStream } from '../ogg/vorbis/VorbisStream.js';\r\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nimport * as Flac from './FlacToken.js';\r\nconst debug = initDebug('music-metadata:parser:FLAC');\r\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\r\n}\r\nexport class FlacParser extends AbstractID3Parser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.vorbisParser = new VorbisStream(this.metadata, this.options);\r\n        this.padding = 0;\r\n    }\r\n    async postId3v2Parse() {\r\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\r\n        if (fourCC.toString() !== 'fLaC') {\r\n            throw new FlacContentError('Invalid FLAC preamble');\r\n        }\r\n        let blockHeader;\r\n        do {\r\n            // Read block header\r\n            blockHeader = await this.tokenizer.readToken(Flac.BlockHeader);\r\n            // Parse block data\r\n            await this.parseDataBlock(blockHeader);\r\n        } while (!blockHeader.lastBlock);\r\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\r\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\r\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\r\n        }\r\n    }\r\n    async parseDataBlock(blockHeader) {\r\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\r\n        switch (blockHeader.type) {\r\n            case Flac.BlockType.STREAMINFO:\r\n                return this.readBlockStreamInfo(blockHeader.length);\r\n            case Flac.BlockType.PADDING:\r\n                this.padding += blockHeader.length;\r\n                break;\r\n            case Flac.BlockType.APPLICATION:\r\n                break;\r\n            case Flac.BlockType.SEEKTABLE:\r\n                break;\r\n            case Flac.BlockType.VORBIS_COMMENT:\r\n                return this.readComment(blockHeader.length);\r\n            case Flac.BlockType.CUESHEET:\r\n                break;\r\n            case Flac.BlockType.PICTURE:\r\n                await this.parsePicture(blockHeader.length);\r\n                return;\r\n            default:\r\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\r\n        }\r\n        // Ignore data block\r\n        return this.tokenizer.ignore(blockHeader.length).then();\r\n    }\r\n    /**\r\n     * Parse STREAMINFO\r\n     */\r\n    async readBlockStreamInfo(dataLen) {\r\n        if (dataLen !== Flac.BlockStreamInfo.len)\r\n            throw new FlacContentError('Unexpected block-stream-info length');\r\n        const streamInfo = await this.tokenizer.readToken(Flac.BlockStreamInfo);\r\n        this.metadata.setFormat('container', 'FLAC');\r\n        this.processsStreamInfo(streamInfo);\r\n    }\r\n    /**\r\n     * Parse STREAMINFO\r\n     */\r\n    processsStreamInfo(streamInfo) {\r\n        this.metadata.setFormat('codec', 'FLAC');\r\n        this.metadata.setFormat('hasAudio', true);\r\n        this.metadata.setFormat('lossless', true);\r\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\r\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\r\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\r\n        if (streamInfo.totalSamples > 0) {\r\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\r\n        }\r\n    }\r\n    /**\r\n     * Read VORBIS_COMMENT from tokenizer\r\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\r\n     */\r\n    async readComment(dataLen) {\r\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\r\n        return this.parseComment(data);\r\n    }\r\n    /**\r\n     * Parse VORBIS_COMMENT\r\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\r\n     */\r\n    async parseComment(data) {\r\n        const decoder = new VorbisDecoder(data, 0);\r\n        const vendor = decoder.readStringUtf8();\r\n        if (vendor.length > 0) {\r\n            this.metadata.setFormat('tool', vendor);\r\n        }\r\n        const commentListLength = decoder.readInt32();\r\n        const tags = new Array(commentListLength);\r\n        for (let i = 0; i < commentListLength; i++) {\r\n            tags[i] = decoder.parseUserComment();\r\n        }\r\n        await Promise.all(tags.map(tag => {\r\n            if (tag.key === 'ENCODER') {\r\n                this.metadata.setFormat('tool', tag.value);\r\n            }\r\n            return this.addTag(tag.key, tag.value);\r\n        }));\r\n    }\r\n    async parsePicture(dataLen) {\r\n        if (this.options.skipCovers) {\r\n            return this.tokenizer.ignore(dataLen);\r\n        }\r\n        return this.addPictureTag(await this.tokenizer.readToken(new VorbisPictureToken(dataLen)));\r\n    }\r\n    addPictureTag(picture) {\r\n        return this.addTag('METADATA_BLOCK_PICTURE', picture);\r\n    }\r\n    addTag(id, value) {\r\n        return this.vorbisParser.addTag(id, value);\r\n    }\r\n}\r\n","import * as util from '../common/Util.js';\r\nimport { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\r\n/**\r\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\r\n * ref: https://xiph.org/flac/format.html#metadata_block\r\n */\r\nexport const BlockType = {\r\n    STREAMINFO: 0, // STREAMINFO\r\n    PADDING: 1, // PADDING\r\n    APPLICATION: 2, // APPLICATION\r\n    SEEKTABLE: 3, // SEEKTABLE\r\n    VORBIS_COMMENT: 4, // VORBIS_COMMENT\r\n    CUESHEET: 5, // CUESHEET\r\n    PICTURE: 6 // PICTURE\r\n};\r\nexport const BlockHeader = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return {\r\n            lastBlock: util.getBit(buf, off, 7),\r\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\r\n            length: UINT24_BE.get(buf, off + 1)\r\n        };\r\n    }\r\n};\r\n/**\r\n * METADATA_BLOCK_DATA\r\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\r\n */\r\nexport const BlockStreamInfo = {\r\n    len: 34,\r\n    get: (buf, off) => {\r\n        return {\r\n            // The minimum block size (in samples) used in the stream.\r\n            minimumBlockSize: UINT16_BE.get(buf, off),\r\n            // The maximum block size (in samples) used in the stream.\r\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\r\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\r\n            // The minimum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\r\n            // The maximum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\r\n            // Sample rate in Hz. Though 20 bits are available,\r\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\r\n            // Also, a value of 0 is invalid.\r\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\r\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\r\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\r\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\r\n            // bits per sample)-1.\r\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\r\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\r\n            // Total samples in stream.\r\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\r\n            // A value of zero here means the number of total samples is unknown.\r\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\r\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\r\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\r\n        };\r\n    }\r\n};\r\n","import { EndOfStreamError } from 'strtok3';\r\nimport initDebug from 'debug';\r\nimport { ID3v2Header } from './ID3v2Token.js';\r\nimport { ID3v2Parser } from './ID3v2Parser.js';\r\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nconst debug = initDebug('music-metadata:parser:ID3');\r\n/**\r\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\r\n */\r\nexport class AbstractID3Parser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.id3parser = new ID3v2Parser();\r\n    }\r\n    static async startsWithID3v2Header(tokenizer) {\r\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\r\n    }\r\n    async parse() {\r\n        try {\r\n            await this.parseID3v2();\r\n        }\r\n        catch (err) {\r\n            if (err instanceof EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    finalize() {\r\n        return;\r\n    }\r\n    async parseID3v2() {\r\n        await this.tryReadId3v2Headers();\r\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\r\n        await this.postId3v2Parse();\r\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\r\n            this.finalize();\r\n        }\r\n        else {\r\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\r\n            await id3v1parser.parse();\r\n            this.finalize();\r\n        }\r\n    }\r\n    async tryReadId3v2Headers() {\r\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\r\n        if (id3Header.fileIdentifier === 'ID3') {\r\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\r\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\r\n            return this.tryReadId3v2Headers();\r\n        }\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport { textDecode } from '@borewit/text-codec';\r\nexport class VorbisDecoder {\r\n    constructor(data, offset) {\r\n        this.data = data;\r\n        this.offset = offset;\r\n    }\r\n    readInt32() {\r\n        const value = Token.UINT32_LE.get(this.data, this.offset);\r\n        this.offset += 4;\r\n        return value;\r\n    }\r\n    readStringUtf8() {\r\n        const len = this.readInt32();\r\n        const value = textDecode(this.data.subarray(this.offset, this.offset + len), 'utf-8');\r\n        this.offset += len;\r\n        return value;\r\n    }\r\n    parseUserComment() {\r\n        const offset0 = this.offset;\r\n        const v = this.readStringUtf8();\r\n        const idx = v.indexOf('=');\r\n        return {\r\n            key: v.substring(0, idx).toUpperCase(),\r\n            value: v.substring(idx + 1),\r\n            len: this.offset - offset0\r\n        };\r\n    }\r\n}\r\n"],"names":["OpusContentError","makeUnexpectedFileContentError","IdHeader","constructor","len","this","get","buf","off","magicSignature","Token","version","channelCount","preSkip","inputSampleRate","outputGain","channelMapping","OpusStream","VorbisStream","metadata","options","tokenizer","super","idHeader","lastPos","durationOnLastPage","parseFirstPage","_header","pageData","setFormat","Opus","length","setAudioOnly","parseFullPage","parseUserCommentList","position","calculateDuration","enfOfStream","lastPageHeader","headerType","lastPage","format","sampleRate","absoluteGranulePosition","pos_48bit","fileInfo","size","duration","dataSize","Header","speex","util","version_id","header_size","rate","mode","mode_bitstream_version","nb_channels","bitrate","frame_size","vbr","frames_per_packet","extra_headers","reserved1","reserved2","debug","initDebug","SpeexStream","_tokenizer","speexHeader","Speex","IdentificationHeader","id","vmaj","vmin","vrev","vmbw","vmbh","nombr","nqual","TheoraStream","_options","parsePage","header","firstPage","flush","Promise","resolve","PageHeader","capturePattern","StringType","continued","Number","streamSerialNumber","pageSequenceNo","pageChecksum","page_segments","SegmentTable","sum","dv","DataView","buffer","s","i","getUint8","totalPageSize","FlacStream","flacParser","FlacParser","fourCC","FourCcToken","toString","Error","blockHeader","Flac","parseDataBlock","subarray","type","STREAMINFO","streamInfo","processsStreamInfo","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","parseComment","PICTURE","skipCovers","picture","VorbisPictureToken","addPictureTag","addWarning","ignore","then","OggContentError","OggStream","streamSerial","pageNumber","closed","segmentTable","readToken","idData","asciiId","Array","from","filter","b","map","String","fromCharCode","join","pageConsumer","OggParser","BasicParser","arguments","streams","Map","parse","stream","set","values","find","every","item","err","EndOfStreamError","fromBase64","base64str","fromBuffer","Uint8Array","atob","c","charCodeAt","pic","offset","AttachedPictureType","mimeLen","descLen","description","width","height","colour_depth","indexed_color","picDataLen","data","slice","CommonHeader","packetType","vorbis","uint8Array","channelMode","bitrateMax","bitrateNominal","bitrateMin","debugInit","VorbisContentError","pageSegments","push","fullPage","mergeUint8Arrays","arrays","totalSize","reduce","acc","e","merged","forEach","array","_arrays","parseUserComment","decoder","VorbisDecoder","tag","addTag","key","value","commonHeader","byteLength","strLen","userCommentListLength","FlacContentError","AbstractID3Parser","vorbisParser","padding","postId3v2Parse","lastBlock","readBlockStreamInfo","readComment","CUESHEET","parsePicture","dataLen","channels","bitsPerSample","totalSamples","Uint8ArrayType","vendor","readStringUtf8","commentListLength","readInt32","tags","all","BlockType","BlockHeader","UINT24_BE","BlockStreamInfo","minimumBlockSize","UINT16_BE","maximumBlockSize","minimumFrameSize","maximumFrameSize","fileMD5","id3parser","ID3v2Parser","startsWithID3v2Header","peekToken","ID3v2Header","fileIdentifier","parseID3v2","finalize","tryReadId3v2Headers","skipPostHeaders","hasAny","id3v1parser","ID3v1Parser","id3Header","textDecode","offset0","v","idx","indexOf","substring","toUpperCase"],"ignoreList":[],"sourceRoot":""}