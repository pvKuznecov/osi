{"version":3,"file":"js/989.9ef9b127.js","mappings":"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","sources":["webpack://osi/./node_modules/music-metadata/lib/dsf/DsfChunk.js","webpack://osi/./node_modules/music-metadata/lib/dsf/DsfParser.js","webpack://osi/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\n/**\r\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\r\n */\r\nexport const ChunkHeader = {\r\n    len: 12,\r\n    get: (buf, off) => {\r\n        return { id: FourCcToken.get(buf, off), size: Token.UINT64_LE.get(buf, off + 4) };\r\n    }\r\n};\r\n/**\r\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\r\n */\r\nexport const DsdChunk = {\r\n    len: 16,\r\n    get: (buf, off) => {\r\n        return {\r\n            fileSize: Token.INT64_LE.get(buf, off),\r\n            metadataPointer: Token.INT64_LE.get(buf, off + 8)\r\n        };\r\n    }\r\n};\r\nexport const ChannelType = {\r\n    mono: 1,\r\n    stereo: 2,\r\n    channels: 3,\r\n    quad: 4,\r\n    '4 channels': 5,\r\n    '5 channels': 6,\r\n    '5.1 channels': 7\r\n};\r\n/**\r\n * Common chunk DSD header: the 'chunk name (Four-CC)' & chunk size\r\n */\r\nexport const FormatChunk = {\r\n    len: 40,\r\n    get: (buf, off) => {\r\n        return {\r\n            formatVersion: Token.INT32_LE.get(buf, off),\r\n            formatID: Token.INT32_LE.get(buf, off + 4),\r\n            channelType: Token.INT32_LE.get(buf, off + 8),\r\n            channelNum: Token.INT32_LE.get(buf, off + 12),\r\n            samplingFrequency: Token.INT32_LE.get(buf, off + 16),\r\n            bitsPerSample: Token.INT32_LE.get(buf, off + 20),\r\n            sampleCount: Token.INT64_LE.get(buf, off + 24),\r\n            blockSizePerChannel: Token.INT32_LE.get(buf, off + 32)\r\n        };\r\n    }\r\n};\r\n","import initDebug from 'debug';\r\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\r\nimport { ChunkHeader, DsdChunk, FormatChunk } from './DsfChunk.js';\r\nimport { ID3v2Parser } from \"../id3v2/ID3v2Parser.js\";\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:DSF');\r\nexport class DsdContentParseError extends makeUnexpectedFileContentError('DSD') {\r\n}\r\n/**\r\n * DSF (dsd stream file) File Parser\r\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\r\n */\r\nexport class DsfParser extends AbstractID3Parser {\r\n    async postId3v2Parse() {\r\n        const p0 = this.tokenizer.position; // mark start position, normally 0\r\n        const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\r\n        if (chunkHeader.id !== 'DSD ')\r\n            throw new DsdContentParseError('Invalid chunk signature');\r\n        this.metadata.setFormat('container', 'DSF');\r\n        this.metadata.setFormat('lossless', true);\r\n        this.metadata.setAudioOnly();\r\n        const dsdChunk = await this.tokenizer.readToken(DsdChunk);\r\n        if (dsdChunk.metadataPointer === BigInt(0)) {\r\n            debug(\"No ID3v2 tag present\");\r\n        }\r\n        else {\r\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\r\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\r\n            // Jump to ID3 header\r\n            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\r\n            return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\r\n        }\r\n    }\r\n    async parseChunks(bytesRemaining) {\r\n        while (bytesRemaining >= ChunkHeader.len) {\r\n            const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\r\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\r\n            switch (chunkHeader.id) {\r\n                case 'fmt ': {\r\n                    const formatChunk = await this.tokenizer.readToken(FormatChunk);\r\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\r\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\r\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\r\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\r\n                    this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\r\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\r\n                    this.metadata.setFormat('bitrate', bitrate);\r\n                    return; // We got what we want, stop further processing of chunks\r\n                }\r\n                default:\r\n                    this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);\r\n                    break;\r\n            }\r\n            bytesRemaining -= chunkHeader.size;\r\n        }\r\n    }\r\n}\r\n","import { EndOfStreamError } from 'strtok3';\r\nimport initDebug from 'debug';\r\nimport { ID3v2Header } from './ID3v2Token.js';\r\nimport { ID3v2Parser } from './ID3v2Parser.js';\r\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nconst debug = initDebug('music-metadata:parser:ID3');\r\n/**\r\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\r\n */\r\nexport class AbstractID3Parser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.id3parser = new ID3v2Parser();\r\n    }\r\n    static async startsWithID3v2Header(tokenizer) {\r\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\r\n    }\r\n    async parse() {\r\n        try {\r\n            await this.parseID3v2();\r\n        }\r\n        catch (err) {\r\n            if (err instanceof EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    finalize() {\r\n        return;\r\n    }\r\n    async parseID3v2() {\r\n        await this.tryReadId3v2Headers();\r\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\r\n        await this.postId3v2Parse();\r\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\r\n            this.finalize();\r\n        }\r\n        else {\r\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\r\n            await id3v1parser.parse();\r\n            this.finalize();\r\n        }\r\n    }\r\n    async tryReadId3v2Headers() {\r\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\r\n        if (id3Header.fileIdentifier === 'ID3') {\r\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\r\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\r\n            return this.tryReadId3v2Headers();\r\n        }\r\n    }\r\n}\r\n"],"names":["ChunkHeader","len","get","buf","off","id","FourCcToken","size","Token","DsdChunk","fileSize","metadataPointer","FormatChunk","formatVersion","formatID","channelType","channelNum","samplingFrequency","bitsPerSample","sampleCount","blockSizePerChannel","debug","initDebug","DsdContentParseError","makeUnexpectedFileContentError","DsfParser","AbstractID3Parser","postId3v2Parse","p0","this","tokenizer","position","chunkHeader","readToken","metadata","setFormat","setAudioOnly","dsdChunk","BigInt","parseChunks","ignore","Number","ID3v2Parser","parse","options","bytesRemaining","formatChunk","bitrate","BasicParser","constructor","super","arguments","id3parser","startsWithID3v2Header","peekToken","ID3v2Header","fileIdentifier","parseID3v2","err","EndOfStreamError","finalize","tryReadId3v2Headers","skipPostHeaders","hasAny","id3v1parser","ID3v1Parser","id3Header"],"ignoreList":[],"sourceRoot":""}