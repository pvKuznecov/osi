{"version":3,"file":"js/444.189d56b5.js","mappings":"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","sources":["webpack://osi/./node_modules/music-metadata/lib/mpeg/ReplayGainDataFormat.js","webpack://osi/./node_modules/music-metadata/lib/mpeg/ExtendedLameHeader.js","webpack://osi/./node_modules/music-metadata/lib/mpeg/XingTag.js","webpack://osi/./node_modules/music-metadata/lib/mpeg/MpegParser.js","webpack://osi/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js"],"sourcesContent":["import * as common from '../common/Util.js';\r\n/**\r\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#name-code\r\n */\r\nconst NameCode = {\r\n    /**\r\n     * not set\r\n     */\r\n    not_set: 0,\r\n    /**\r\n     * Radio Gain Adjustment\r\n     */\r\n    radio: 1,\r\n    /**\r\n     * Audiophile Gain Adjustment\r\n     */\r\n    audiophile: 2\r\n};\r\n/**\r\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format#originator-code\r\n */\r\nconst ReplayGainOriginator = {\r\n    /**\r\n     * Replay Gain unspecified\r\n     */\r\n    unspecified: 0,\r\n    /**\r\n     * Replay Gain pre-set by artist/producer/mastering engineer\r\n     */\r\n    engineer: 1,\r\n    /**\r\n     * Replay Gain set by user\r\n     */\r\n    user: 2,\r\n    /**\r\n     * Replay Gain determined automatically, as described on this site\r\n     */\r\n    automatic: 3,\r\n    /**\r\n     * Set by simple RMS average\r\n     */\r\n    rms_average: 4\r\n};\r\n/**\r\n * Replay Gain Data Format\r\n *\r\n * https://github.com/Borewit/music-metadata/wiki/Replay-Gain-Data-Format\r\n */\r\nexport const ReplayGain = {\r\n    len: 2,\r\n    get: (buf, off) => {\r\n        const gain_type = common.getBitAllignedNumber(buf, off, 0, 3);\r\n        const sign = common.getBitAllignedNumber(buf, off, 6, 1);\r\n        const gain_adj = common.getBitAllignedNumber(buf, off, 7, 9) / 10.0;\r\n        if (gain_type > 0) {\r\n            return {\r\n                type: common.getBitAllignedNumber(buf, off, 0, 3),\r\n                origin: common.getBitAllignedNumber(buf, off, 3, 3),\r\n                adjustment: (sign ? -gain_adj : gain_adj)\r\n            };\r\n        }\r\n        return undefined;\r\n    }\r\n};\r\n","/**\r\n * Extended Lame Header\r\n */\r\nimport * as Token from 'token-types';\r\nimport * as common from '../common/Util.js';\r\nimport { ReplayGain } from './ReplayGainDataFormat.js';\r\n/**\r\n * Info Tag\r\n * @link http://gabriel.mp3-tech.org/mp3infotag.html\r\n * @link https://github.com/quodlibet/mutagen/blob/abd58ee58772224334a18817c3fb31103572f70e/mutagen/mp3/_util.py#L112\r\n */\r\nexport const ExtendedLameHeader = {\r\n    len: 27,\r\n    get: (buf, off) => {\r\n        const track_peak = Token.UINT32_BE.get(buf, off + 2);\r\n        return {\r\n            revision: common.getBitAllignedNumber(buf, off, 0, 4),\r\n            vbr_method: common.getBitAllignedNumber(buf, off, 4, 4),\r\n            lowpass_filter: 100 * Token.UINT8.get(buf, off + 1),\r\n            track_peak: track_peak === 0 ? null : track_peak / 2 ** 23,\r\n            track_gain: ReplayGain.get(buf, 6),\r\n            album_gain: ReplayGain.get(buf, 8),\r\n            music_length: Token.UINT32_BE.get(buf, off + 20),\r\n            music_crc: Token.UINT8.get(buf, off + 24),\r\n            header_crc: Token.UINT16_BE.get(buf, off + 24)\r\n        };\r\n    }\r\n};\r\n","import * as Token from 'token-types';\r\nimport * as util from '../common/Util.js';\r\nimport { ExtendedLameHeader } from './ExtendedLameHeader.js';\r\n/**\r\n * Info Tag: Xing, LAME\r\n */\r\nexport const InfoTagHeaderTag = new Token.StringType(4, 'ascii');\r\n/**\r\n * LAME TAG value\r\n * Did not find any official documentation for this\r\n * Value e.g.: \"3.98.4\"\r\n */\r\nexport const LameEncoderVersion = new Token.StringType(6, 'ascii');\r\n/**\r\n * Info Tag\r\n * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n */\r\nexport const XingHeaderFlags = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return {\r\n            frames: util.isBitSet(buf, off, 31),\r\n            bytes: util.isBitSet(buf, off, 30),\r\n            toc: util.isBitSet(buf, off, 29),\r\n            vbrScale: util.isBitSet(buf, off, 28)\r\n        };\r\n    }\r\n};\r\n// /**\r\n//  * XING Header Tag\r\n//  * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n//  */\r\nexport async function readXingHeader(tokenizer) {\r\n    const flags = await tokenizer.readToken(XingHeaderFlags);\r\n    const xingInfoTag = { numFrames: null, streamSize: null, vbrScale: null };\r\n    if (flags.frames) {\r\n        xingInfoTag.numFrames = await tokenizer.readToken(Token.UINT32_BE);\r\n    }\r\n    if (flags.bytes) {\r\n        xingInfoTag.streamSize = await tokenizer.readToken(Token.UINT32_BE);\r\n    }\r\n    if (flags.toc) {\r\n        xingInfoTag.toc = new Uint8Array(100);\r\n        await tokenizer.readBuffer(xingInfoTag.toc);\r\n    }\r\n    if (flags.vbrScale) {\r\n        xingInfoTag.vbrScale = await tokenizer.readToken(Token.UINT32_BE);\r\n    }\r\n    const lameTag = await tokenizer.peekToken(new Token.StringType(4, 'ascii'));\r\n    if (lameTag === 'LAME') {\r\n        await tokenizer.ignore(4);\r\n        xingInfoTag.lame = {\r\n            version: await tokenizer.readToken(new Token.StringType(5, 'ascii'))\r\n        };\r\n        const match = xingInfoTag.lame.version.match(/\\d+.\\d+/g);\r\n        if (match !== null) {\r\n            const majorMinorVersion = match[0]; // e.g. 3.97\r\n            const version = majorMinorVersion.split('.').map(n => Number.parseInt(n, 10));\r\n            if (version[0] >= 3 && version[1] >= 90) {\r\n                xingInfoTag.lame.extended = await tokenizer.readToken(ExtendedLameHeader);\r\n            }\r\n        }\r\n    }\r\n    return xingInfoTag;\r\n}\r\n","import * as Token from 'token-types';\r\nimport { EndOfStreamError } from 'strtok3';\r\nimport initDebug from 'debug';\r\nimport * as common from '../common/Util.js';\r\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\r\nimport { InfoTagHeaderTag, LameEncoderVersion, readXingHeader } from './XingTag.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:mpeg');\r\nexport class MpegContentError extends makeUnexpectedFileContentError('MPEG') {\r\n}\r\n/**\r\n * Cache buffer size used for searching synchronization preabmle\r\n */\r\nconst maxPeekLen = 1024;\r\n/**\r\n * MPEG-4 Audio definitions\r\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\r\n */\r\nconst MPEG4 = {\r\n    /**\r\n     * Audio Object Types\r\n     */\r\n    AudioObjectTypes: [\r\n        'AAC Main',\r\n        'AAC LC', // Low Complexity\r\n        'AAC SSR', // Scalable Sample Rate\r\n        'AAC LTP' // Long Term Prediction\r\n    ],\r\n    /**\r\n     * Sampling Frequencies\r\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\r\n     */\r\n    SamplingFrequencies: [\r\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, null, null, -1\r\n    ]\r\n    /**\r\n     * Channel Configurations\r\n     */\r\n};\r\nconst MPEG4_ChannelConfigurations = [\r\n    undefined,\r\n    ['front-center'],\r\n    ['front-left', 'front-right'],\r\n    ['front-center', 'front-left', 'front-right'],\r\n    ['front-center', 'front-left', 'front-right', 'back-center'],\r\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\r\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\r\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\r\n];\r\n/**\r\n * MPEG Audio Layer I/II/III frame header\r\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\r\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\r\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\r\n */\r\nclass MpegFrameHeader {\r\n    constructor(buf, off) {\r\n        // E(15,12): Bitrate index\r\n        this.bitrateIndex = null;\r\n        // F(11,10): Sampling rate frequency index\r\n        this.sampRateFreqIndex = null;\r\n        // G(9): Padding bit\r\n        this.padding = null;\r\n        // H(8): Private bit\r\n        this.privateBit = null;\r\n        // I(7,6): Channel Mode\r\n        this.channelModeIndex = null;\r\n        // J(5,4): Mode extension (Only used in Joint stereo)\r\n        this.modeExtension = null;\r\n        // L(2): Original\r\n        this.isOriginalMedia = null;\r\n        this.version = null;\r\n        this.bitrate = null;\r\n        this.samplingRate = null;\r\n        this.frameLength = 0;\r\n        // B(20,19): MPEG Audio versionIndex ID\r\n        this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\r\n        // C(18,17): Layer description\r\n        this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\r\n        if (this.versionIndex > 1 && this.layer === 0) {\r\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\r\n        }\r\n        else {\r\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\r\n        }\r\n        // D(16): Protection bit (if true 16-bit CRC follows header)\r\n        this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\r\n    }\r\n    calcDuration(numFrames) {\r\n        return this.samplingRate == null ? null : (numFrames * this.calcSamplesPerFrame() / this.samplingRate);\r\n    }\r\n    calcSamplesPerFrame() {\r\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\r\n    }\r\n    calculateSideInfoLength() {\r\n        if (this.layer !== 3)\r\n            return 2;\r\n        if (this.channelModeIndex === 3) {\r\n            // mono\r\n            if (this.version === 1) {\r\n                return 17;\r\n            }\r\n            if (this.version === 2 || this.version === 2.5) {\r\n                return 9;\r\n            }\r\n        }\r\n        else {\r\n            if (this.version === 1) {\r\n                return 32;\r\n            }\r\n            if (this.version === 2 || this.version === 2.5) {\r\n                return 17;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    calcSlotSize() {\r\n        return [null, 4, 1, 1][this.layer];\r\n    }\r\n    parseMpegHeader(buf, off) {\r\n        this.container = 'MPEG';\r\n        // E(15,12): Bitrate index\r\n        this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\r\n        // F(11,10): Sampling rate frequency index\r\n        this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\r\n        // G(9): Padding bit\r\n        this.padding = common.isBitSet(buf, off + 2, 6);\r\n        // H(8): Private bit\r\n        this.privateBit = common.isBitSet(buf, off + 2, 7);\r\n        // I(7,6): Channel Mode\r\n        this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\r\n        // J(5,4): Mode extension (Only used in Joint stereo)\r\n        this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\r\n        // K(3): Copyright\r\n        this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\r\n        // L(2): Original\r\n        this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\r\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\r\n        this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\r\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\r\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\r\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\r\n        // Calculate bitrate\r\n        const bitrateInKbps = this.calcBitrate();\r\n        if (!bitrateInKbps) {\r\n            throw new MpegContentError('Cannot determine bit-rate');\r\n        }\r\n        this.bitrate = bitrateInKbps * 1000;\r\n        // Calculate sampling rate\r\n        this.samplingRate = this.calcSamplingRate();\r\n        if (this.samplingRate == null) {\r\n            throw new MpegContentError('Cannot determine sampling-rate');\r\n        }\r\n    }\r\n    parseAdtsHeader(buf, off) {\r\n        debug(\"layer=0 => ADTS\");\r\n        this.version = this.versionIndex === 2 ? 4 : 2;\r\n        this.container = `ADTS/MPEG-${this.version}`;\r\n        const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\r\n        this.codec = 'AAC';\r\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\r\n        debug(`MPEG-4 audio-codec=${this.codec}`);\r\n        const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\r\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\r\n        debug(`sampling-rate=${this.samplingRate}`);\r\n        const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\r\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\r\n        debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join('+') : '?'}`);\r\n        this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\r\n    }\r\n    calcBitrate() {\r\n        if (this.bitrateIndex === 0x00 || // free\r\n            this.bitrateIndex === 0x0F) { // reserved\r\n            return null;\r\n        }\r\n        if (this.version && this.bitrateIndex) {\r\n            const codecIndex = 10 * Math.floor(this.version) + this.layer;\r\n            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\r\n        }\r\n        return null;\r\n    }\r\n    calcSamplingRate() {\r\n        if (this.sampRateFreqIndex === 0x03 || this.version === null || this.sampRateFreqIndex == null)\r\n            return null; // 'reserved'\r\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\r\n    }\r\n}\r\nMpegFrameHeader.SyncByte1 = 0xFF;\r\nMpegFrameHeader.SyncByte2 = 0xE0;\r\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\r\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\r\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\r\nMpegFrameHeader.bitrate_index = {\r\n    1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\r\n    2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\r\n    3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\r\n    4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\r\n    5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\r\n    6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\r\n    7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\r\n    8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\r\n    9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\r\n    10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\r\n    11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\r\n    12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\r\n    13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\r\n    14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\r\n};\r\nMpegFrameHeader.sampling_rate_freq_index = {\r\n    1: { 0: 44100, 1: 48000, 2: 32000 },\r\n    2: { 0: 22050, 1: 24000, 2: 16000 },\r\n    2.5: { 0: 11025, 1: 12000, 2: 8000 }\r\n};\r\nMpegFrameHeader.samplesInFrameTable = [\r\n    /* Layer   I    II   III */\r\n    [0, 384, 1152, 1152], // MPEG-1\r\n    [0, 384, 1152, 576] // MPEG-2(.5\r\n];\r\n/**\r\n * MPEG Audio Layer I/II/III\r\n */\r\nconst FrameHeader = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return new MpegFrameHeader(buf, off);\r\n    }\r\n};\r\nfunction getVbrCodecProfile(vbrScale) {\r\n    return `V${Math.floor((100 - vbrScale) / 10)}`;\r\n}\r\nexport class MpegParser extends AbstractID3Parser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.frameCount = 0;\r\n        this.syncFrameCount = -1;\r\n        this.countSkipFrameData = 0;\r\n        this.totalDataLength = 0;\r\n        this.bitrates = [];\r\n        this.offset = 0;\r\n        this.frame_size = 0;\r\n        this.crc = null;\r\n        this.calculateEofDuration = false;\r\n        this.samplesPerFrame = null;\r\n        this.buf_frame_header = new Uint8Array(4);\r\n        /**\r\n         * Number of bytes already parsed since beginning of stream / file\r\n         */\r\n        this.mpegOffset = null;\r\n        this.syncPeek = {\r\n            buf: new Uint8Array(maxPeekLen),\r\n            len: 0\r\n        };\r\n    }\r\n    /**\r\n     * Called after ID3 headers have been parsed\r\n     */\r\n    async postId3v2Parse() {\r\n        this.metadata.setFormat('lossless', false);\r\n        this.metadata.setAudioOnly();\r\n        try {\r\n            let quit = false;\r\n            while (!quit) {\r\n                await this.sync();\r\n                quit = await this.parseCommonMpegHeader();\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n                if (this.calculateEofDuration) {\r\n                    if (this.samplesPerFrame !== null) {\r\n                        const numberOfSamples = this.frameCount * this.samplesPerFrame;\r\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                        if (this.metadata.format.sampleRate) {\r\n                            const duration = numberOfSamples / this.metadata.format.sampleRate;\r\n                            debug(`Calculate duration at EOF: ${duration} sec.`, duration);\r\n                            this.metadata.setFormat('duration', duration);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\r\n     */\r\n    finalize() {\r\n        const format = this.metadata.format;\r\n        const hasID3v1 = !!this.metadata.native.ID3v1;\r\n        if (this.mpegOffset !== null) {\r\n            if (format.duration && this.tokenizer.fileInfo.size) {\r\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\r\n                if (format.codecProfile && format.codecProfile[0] === 'V') {\r\n                    this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\r\n                }\r\n            }\r\n            if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\r\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\r\n                if (this.frame_size !== null && this.samplesPerFrame !== null) {\r\n                    const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\r\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                    if (format.sampleRate && !format.duration) {\r\n                        const duration = numberOfSamples / format.sampleRate;\r\n                        debug(\"Calculate CBR duration based on file size: %s\", duration);\r\n                        this.metadata.setFormat('duration', duration);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    async sync() {\r\n        let gotFirstSync = false;\r\n        while (true) {\r\n            let bo = 0;\r\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\r\n            if (this.syncPeek.len <= 163) {\r\n                throw new EndOfStreamError();\r\n            }\r\n            while (true) {\r\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\r\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\r\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\r\n                    await this.tokenizer.ignore(bo);\r\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\r\n                    if (this.syncFrameCount === this.frameCount) {\r\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\r\n                        this.frameCount = 0;\r\n                        this.frame_size = 0;\r\n                    }\r\n                    this.syncFrameCount = this.frameCount;\r\n                    return; // sync\r\n                }\r\n                gotFirstSync = false;\r\n                bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\r\n                if (bo === -1) {\r\n                    if (this.syncPeek.len < this.syncPeek.buf.length) {\r\n                        throw new EndOfStreamError();\r\n                    }\r\n                    await this.tokenizer.ignore(this.syncPeek.len);\r\n                    break; // continue with next buffer\r\n                }\r\n                ++bo;\r\n                gotFirstSync = true;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\r\n    async parseCommonMpegHeader() {\r\n        if (this.frameCount === 0) {\r\n            this.mpegOffset = this.tokenizer.position - 1;\r\n        }\r\n        await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), { length: 3 });\r\n        let header;\r\n        try {\r\n            header = FrameHeader.get(this.buf_frame_header, 0);\r\n        }\r\n        catch (err) {\r\n            await this.tokenizer.ignore(1);\r\n            if (err instanceof Error) {\r\n                this.metadata.addWarning(`Parse error: ${err.message}`);\r\n                return false; // sync\r\n            }\r\n            throw err;\r\n        }\r\n        await this.tokenizer.ignore(3);\r\n        this.metadata.setFormat('container', header.container);\r\n        this.metadata.setFormat('codec', header.codec);\r\n        this.metadata.setFormat('lossless', false);\r\n        this.metadata.setFormat('sampleRate', header.samplingRate);\r\n        this.frameCount++;\r\n        return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\r\n    }\r\n    /**\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\r\n    async parseAudioFrameHeader(header) {\r\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\r\n        this.metadata.setFormat('bitrate', header.bitrate);\r\n        if (this.frameCount < 20 * 10000) {\r\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\r\n        }\r\n        const slot_size = header.calcSlotSize();\r\n        if (slot_size === null) {\r\n            throw new MpegContentError('invalid slot_size');\r\n        }\r\n        const samples_per_frame = header.calcSamplesPerFrame();\r\n        debug(`samples_per_frame=${samples_per_frame}`);\r\n        const bps = samples_per_frame / 8.0;\r\n        if (header.bitrate !== null && header.samplingRate != null) {\r\n            const fsize = (bps * header.bitrate / header.samplingRate) + ((header.padding) ? slot_size : 0);\r\n            this.frame_size = Math.floor(fsize);\r\n        }\r\n        this.audioFrameHeader = header;\r\n        if (header.bitrate !== null) {\r\n            this.bitrates.push(header.bitrate);\r\n        }\r\n        // xtra header only exists in first frame\r\n        if (this.frameCount === 1) {\r\n            this.offset = FrameHeader.len;\r\n            await this.skipSideInformation();\r\n            return false;\r\n        }\r\n        if (this.frameCount === 4) {\r\n            // the stream is CBR if the first 3 frame bitrates are the same\r\n            if (this.areAllSame(this.bitrates)) {\r\n                // Actual calculation will be done in finalize\r\n                this.samplesPerFrame = samples_per_frame;\r\n                this.metadata.setFormat('codecProfile', 'CBR');\r\n                if (this.tokenizer.fileInfo.size)\r\n                    return true; // Will calculate duration based on the file size\r\n            }\r\n            else if (this.metadata.format.duration) {\r\n                return true; // We already got the duration, stop processing MPEG stream any further\r\n            }\r\n            if (!this.options.duration) {\r\n                return true; // Enforce duration not enabled, stop processing entire stream\r\n            }\r\n        }\r\n        // once we know the file is VBR attach listener to end of\r\n        // stream so we can do the duration calculation when we\r\n        // have counted all the frames\r\n        if (this.options.duration && this.frameCount === 4) {\r\n            this.samplesPerFrame = samples_per_frame;\r\n            this.calculateEofDuration = true;\r\n        }\r\n        this.offset = 4;\r\n        if (header.isProtectedByCRC) {\r\n            await this.parseCrc();\r\n            return false;\r\n        }\r\n        await this.skipSideInformation();\r\n        return false;\r\n    }\r\n    async parseAdts(header) {\r\n        const buf = new Uint8Array(3);\r\n        await this.tokenizer.readBuffer(buf);\r\n        header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\r\n        this.totalDataLength += header.frameLength;\r\n        this.samplesPerFrame = 1024;\r\n        if (header.samplingRate !== null) {\r\n            const framesPerSec = header.samplingRate / this.samplesPerFrame;\r\n            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\r\n            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\r\n            this.metadata.setFormat('bitrate', bitrate);\r\n            debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\r\n        }\r\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\r\n        // Consume remaining header and frame data\r\n        if (this.frameCount === 3) {\r\n            this.metadata.setFormat('codecProfile', header.codecProfile);\r\n            if (header.mp4ChannelConfig) {\r\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\r\n            }\r\n            if (this.options.duration) {\r\n                this.calculateEofDuration = true;\r\n            }\r\n            else {\r\n                return true; // Stop parsing after the third frame\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    async parseCrc() {\r\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\r\n        this.offset += 2;\r\n        return this.skipSideInformation();\r\n    }\r\n    async skipSideInformation() {\r\n        if (this.audioFrameHeader) {\r\n            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\r\n            if (sideinfo_length !== null) {\r\n                await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\r\n                // side information\r\n                this.offset += sideinfo_length;\r\n                await this.readXtraInfoHeader();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    async readXtraInfoHeader() {\r\n        const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);\r\n        this.offset += InfoTagHeaderTag.len; // 12\r\n        switch (headerTag) {\r\n            case 'Info':\r\n                this.metadata.setFormat('codecProfile', 'CBR');\r\n                return this.readXingInfoHeader();\r\n            case 'Xing': {\r\n                const infoTag = await this.readXingInfoHeader();\r\n                if (infoTag.vbrScale !== null) {\r\n                    const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\r\n                    this.metadata.setFormat('codecProfile', codecProfile);\r\n                }\r\n                return null;\r\n            }\r\n            case 'Xtra':\r\n                // ToDo: ???\r\n                break;\r\n            case 'LAME': {\r\n                const version = await this.tokenizer.readToken(LameEncoderVersion);\r\n                if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {\r\n                    this.offset += LameEncoderVersion.len;\r\n                    this.metadata.setFormat('tool', `LAME ${version}`);\r\n                    await this.skipFrameData(this.frame_size - this.offset);\r\n                    return null;\r\n                }\r\n                this.metadata.addWarning('Corrupt LAME header');\r\n                break;\r\n            }\r\n            // ToDo: ???\r\n        }\r\n        // ToDo: promise duration???\r\n        const frameDataLeft = this.frame_size - this.offset;\r\n        if (frameDataLeft < 0) {\r\n            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);\r\n        }\r\n        else {\r\n            await this.skipFrameData(frameDataLeft);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n     * @returns {Promise<string>}\r\n     */\r\n    async readXingInfoHeader() {\r\n        const offset = this.tokenizer.position;\r\n        const infoTag = await readXingHeader(this.tokenizer);\r\n        this.offset += this.tokenizer.position - offset;\r\n        if (infoTag.lame) {\r\n            this.metadata.setFormat('tool', `LAME ${common.stripNulls(infoTag.lame.version)}`);\r\n            if (infoTag.lame.extended) {\r\n                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\r\n                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\r\n                if (infoTag.lame.extended.track_gain) {\r\n                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\r\n                }\r\n                if (infoTag.lame.extended.album_gain) {\r\n                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\r\n                }\r\n                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\r\n            }\r\n        }\r\n        if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {\r\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\r\n            this.metadata.setFormat('duration', duration);\r\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\r\n            return infoTag;\r\n        }\r\n        // frames field is not present\r\n        const frameDataLeft = this.frame_size - this.offset;\r\n        await this.skipFrameData(frameDataLeft);\r\n        return infoTag;\r\n    }\r\n    async skipFrameData(frameDataLeft) {\r\n        if (frameDataLeft < 0)\r\n            throw new MpegContentError('frame-data-left cannot be negative');\r\n        await this.tokenizer.ignore(frameDataLeft);\r\n        this.countSkipFrameData += frameDataLeft;\r\n    }\r\n    areAllSame(array) {\r\n        const first = array[0];\r\n        return array.every(element => {\r\n            return element === first;\r\n        });\r\n    }\r\n}\r\n","import { EndOfStreamError } from 'strtok3';\r\nimport initDebug from 'debug';\r\nimport { ID3v2Header } from './ID3v2Token.js';\r\nimport { ID3v2Parser } from './ID3v2Parser.js';\r\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nconst debug = initDebug('music-metadata:parser:ID3');\r\n/**\r\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\r\n */\r\nexport class AbstractID3Parser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.id3parser = new ID3v2Parser();\r\n    }\r\n    static async startsWithID3v2Header(tokenizer) {\r\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\r\n    }\r\n    async parse() {\r\n        try {\r\n            await this.parseID3v2();\r\n        }\r\n        catch (err) {\r\n            if (err instanceof EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    finalize() {\r\n        return;\r\n    }\r\n    async parseID3v2() {\r\n        await this.tryReadId3v2Headers();\r\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\r\n        await this.postId3v2Parse();\r\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\r\n            this.finalize();\r\n        }\r\n        else {\r\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\r\n            await id3v1parser.parse();\r\n            this.finalize();\r\n        }\r\n    }\r\n    async tryReadId3v2Headers() {\r\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\r\n        if (id3Header.fileIdentifier === 'ID3') {\r\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\r\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\r\n            return this.tryReadId3v2Headers();\r\n        }\r\n    }\r\n}\r\n"],"names":["ReplayGain","len","get","buf","off","gain_type","common","sign","gain_adj","type","origin","adjustment","ExtendedLameHeader","track_peak","Token","revision","vbr_method","lowpass_filter","track_gain","album_gain","music_length","music_crc","header_crc","InfoTagHeaderTag","LameEncoderVersion","XingHeaderFlags","frames","util","bytes","toc","vbrScale","async","readXingHeader","tokenizer","flags","readToken","xingInfoTag","numFrames","streamSize","Uint8Array","readBuffer","lameTag","peekToken","ignore","lame","version","match","majorMinorVersion","split","map","n","Number","parseInt","extended","debug","initDebug","MpegContentError","makeUnexpectedFileContentError","maxPeekLen","MPEG4","AudioObjectTypes","SamplingFrequencies","MPEG4_ChannelConfigurations","undefined","MpegFrameHeader","constructor","this","bitrateIndex","sampRateFreqIndex","padding","privateBit","channelModeIndex","modeExtension","isOriginalMedia","bitrate","samplingRate","frameLength","versionIndex","layer","LayerDescription","parseAdtsHeader","parseMpegHeader","isProtectedByCRC","calcDuration","calcSamplesPerFrame","samplesInFrameTable","calculateSideInfoLength","calcSlotSize","container","isCopyrighted","emphasis","VersionID","channelMode","ChannelMode","codec","bitrateInKbps","calcBitrate","calcSamplingRate","profileIndex","codecProfile","samplingFrequencyIndex","channelIndex","mp4ChannelConfig","join","codecIndex","Math","floor","bitrate_index","sampling_rate_freq_index","SyncByte1","SyncByte2","FrameHeader","getVbrCodecProfile","MpegParser","AbstractID3Parser","super","arguments","frameCount","syncFrameCount","countSkipFrameData","totalDataLength","bitrates","offset","frame_size","crc","calculateEofDuration","samplesPerFrame","buf_frame_header","mpegOffset","syncPeek","postId3v2Parse","metadata","setFormat","setAudioOnly","quit","sync","parseCommonMpegHeader","err","EndOfStreamError","numberOfSamples","format","sampleRate","duration","finalize","hasID3v1","native","ID3v1","fileInfo","size","mpegSize","round","gotFirstSync","bo","peekBuffer","length","mayBeLess","position","indexOf","header","subarray","Error","addWarning","message","parseAdts","parseAudioFrameHeader","slot_size","samples_per_frame","bps","fsize","audioFrameHeader","push","skipSideInformation","areAllSame","options","parseCrc","framesPerSec","bytesPerFrame","readNumber","sideinfo_length","readXtraInfoHeader","headerTag","readXingInfoHeader","infoTag","skipFrameData","frameDataLeft","array","first","every","element","BasicParser","id3parser","ID3v2Parser","startsWithID3v2Header","ID3v2Header","fileIdentifier","parse","parseID3v2","tryReadId3v2Headers","skipPostHeaders","hasAny","id3v1parser","ID3v1Parser","id3Header"],"ignoreList":[],"sourceRoot":""}