{"version":3,"file":"js/802.5931a2e1.js","mappings":"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","sources":["webpack://osi/./node_modules/music-metadata/lib/aiff/AiffToken.js","webpack://osi/./node_modules/music-metadata/lib/iff/index.js","webpack://osi/./node_modules/music-metadata/lib/aiff/AiffParser.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nexport const compressionTypes = {\r\n    NONE: 'not compressed\tPCM\tApple Computer',\r\n    sowt: 'PCM (byte swapped)',\r\n    fl32: '32-bit floating point IEEE 32-bit float',\r\n    fl64: '64-bit floating point IEEE 64-bit float\tApple Computer',\r\n    alaw: 'ALaw 2:1\t8-bit ITU-T G.711 A-law',\r\n    ulaw: 'µLaw 2:1\t8-bit ITU-T G.711 µ-law\tApple Computer',\r\n    ULAW: 'CCITT G.711 u-law 8-bit ITU-T G.711 µ-law',\r\n    ALAW: 'CCITT G.711 A-law 8-bit ITU-T G.711 A-law',\r\n    FL32: 'Float 32\tIEEE 32-bit float '\r\n};\r\nexport class AiffContentError extends makeUnexpectedFileContentError('AIFF') {\r\n}\r\nexport class Common {\r\n    constructor(header, isAifc) {\r\n        this.isAifc = isAifc;\r\n        const minimumChunkSize = isAifc ? 22 : 18;\r\n        if (header.chunkSize < minimumChunkSize)\r\n            throw new AiffContentError(`COMMON CHUNK size should always be at least ${minimumChunkSize}`);\r\n        this.len = header.chunkSize;\r\n    }\r\n    get(buf, off) {\r\n        // see: https://cycling74.com/forums/aiffs-80-bit-sample-rate-value\r\n        const shift = Token.UINT16_BE.get(buf, off + 8) - 16398;\r\n        const baseSampleRate = Token.UINT16_BE.get(buf, off + 8 + 2);\r\n        const res = {\r\n            numChannels: Token.UINT16_BE.get(buf, off),\r\n            numSampleFrames: Token.UINT32_BE.get(buf, off + 2),\r\n            sampleSize: Token.UINT16_BE.get(buf, off + 6),\r\n            sampleRate: shift < 0 ? baseSampleRate >> Math.abs(shift) : baseSampleRate << shift\r\n        };\r\n        if (this.isAifc) {\r\n            res.compressionType = FourCcToken.get(buf, off + 18);\r\n            if (this.len > 22) {\r\n                const strLen = Token.UINT8.get(buf, off + 22);\r\n                if (strLen > 0) {\r\n                    const padding = (strLen + 1) % 2;\r\n                    if (23 + strLen + padding === this.len) {\r\n                        res.compressionName = new Token.StringType(strLen, 'latin1').get(buf, off + 23);\r\n                    }\r\n                    else {\r\n                        throw new AiffContentError('Illegal pstring length');\r\n                    }\r\n                }\r\n                else {\r\n                    res.compressionName = undefined;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            res.compressionName = 'PCM';\r\n        }\r\n        return res;\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\n/**\r\n * Common AIFF chunk header\r\n */\r\nexport const Header = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        return {\r\n            // Chunk type ID\r\n            chunkID: FourCcToken.get(buf, off),\r\n            // Chunk size\r\n            chunkSize: Number(BigInt(Token.UINT32_BE.get(buf, off + 4)))\r\n        };\r\n    }\r\n};\r\n","import * as Token from 'token-types';\r\nimport initDebug from 'debug';\r\nimport * as strtok3 from 'strtok3';\r\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport * as AiffToken from './AiffToken.js';\r\nimport { AiffContentError, compressionTypes } from './AiffToken.js';\r\nimport * as iff from '../iff/index.js';\r\nconst debug = initDebug('music-metadata:parser:aiff');\r\n/**\r\n * AIFF - Audio Interchange File Format\r\n *\r\n * Ref:\r\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\r\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\r\n */\r\nexport class AIFFParser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.isCompressed = null;\r\n    }\r\n    async parse() {\r\n        const header = await this.tokenizer.readToken(iff.Header);\r\n        if (header.chunkID !== 'FORM')\r\n            throw new AiffContentError('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\r\n        const type = await this.tokenizer.readToken(FourCcToken);\r\n        switch (type) {\r\n            case 'AIFF':\r\n                this.metadata.setFormat('container', type);\r\n                this.isCompressed = false;\r\n                break;\r\n            case 'AIFC':\r\n                this.metadata.setFormat('container', 'AIFF-C');\r\n                this.isCompressed = true;\r\n                break;\r\n            default:\r\n                throw new AiffContentError(`Unsupported AIFF type: ${type}`);\r\n        }\r\n        this.metadata.setFormat('lossless', !this.isCompressed);\r\n        this.metadata.setAudioOnly();\r\n        try {\r\n            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\r\n                debug(`Reading AIFF chunk at offset=${this.tokenizer.position}`);\r\n                const chunkHeader = await this.tokenizer.readToken(iff.Header);\r\n                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\r\n                const bytesRead = await this.readData(chunkHeader);\r\n                await this.tokenizer.ignore(nextChunk - bytesRead);\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof strtok3.EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    async readData(header) {\r\n        switch (header.chunkID) {\r\n            case 'COMM': { // The Common Chunk\r\n                if (this.isCompressed === null) {\r\n                    throw new AiffContentError('Failed to parse AIFF.COMM chunk when compression type is unknown');\r\n                }\r\n                const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\r\n                this.metadata.setFormat('bitsPerSample', common.sampleSize);\r\n                this.metadata.setFormat('sampleRate', common.sampleRate);\r\n                this.metadata.setFormat('numberOfChannels', common.numChannels);\r\n                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\r\n                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\r\n                if (common.compressionName || common.compressionType) {\r\n                    this.metadata.setFormat('codec', common.compressionName ?? compressionTypes[common.compressionType]);\r\n                }\r\n                return header.chunkSize;\r\n            }\r\n            case 'ID3 ': { // ID3-meta-data\r\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\r\n                const rst = strtok3.fromBuffer(id3_data);\r\n                await new ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                return header.chunkSize;\r\n            }\r\n            case 'SSND': // Sound Data Chunk\r\n                if (this.metadata.format.duration) {\r\n                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\r\n                }\r\n                return 0;\r\n            case 'NAME': // Sample name chunk\r\n            case 'AUTH': // Author chunk\r\n            case '(c) ': // Copyright chunk\r\n            case 'ANNO': // Annotation chunk\r\n                return this.readTextChunk(header);\r\n            default:\r\n                debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);\r\n                return 0;\r\n        }\r\n    }\r\n    async readTextChunk(header) {\r\n        const value = await this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));\r\n        const values = value.split('\\0').map(v => v.trim()).filter(v => v?.length);\r\n        await Promise.all(values.map(v => this.metadata.addTag('AIFF', header.chunkID, v)));\r\n        return header.chunkSize;\r\n    }\r\n}\r\n"],"names":["compressionTypes","NONE","sowt","fl32","fl64","alaw","ulaw","ULAW","ALAW","FL32","AiffContentError","makeUnexpectedFileContentError","Common","constructor","header","isAifc","this","minimumChunkSize","chunkSize","len","get","buf","off","shift","Token","baseSampleRate","res","numChannels","numSampleFrames","sampleSize","sampleRate","Math","abs","compressionType","FourCcToken","strLen","padding","compressionName","undefined","Header","chunkID","Number","BigInt","debug","initDebug","AIFFParser","BasicParser","super","arguments","isCompressed","parse","tokenizer","readToken","iff","type","metadata","setFormat","setAudioOnly","fileInfo","size","position","chunkHeader","nextChunk","round","bytesRead","readData","ignore","err","strtok3","common","AiffToken","id3_data","rst","ID3v2Parser","options","format","duration","readTextChunk","value","values","split","map","v","trim","filter","length","Promise","all","addTag"],"ignoreList":[],"sourceRoot":""}