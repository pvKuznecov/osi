{"version":3,"file":"js/156.9c4ac5f9.js","mappings":"qPAQO,MAAMA,EACT,iBAAOC,CAAWC,GACd,OAAOF,EAAmBG,WAAWC,WAAWC,KAAKC,KAAKJ,GAAYK,GAAKA,EAAEC,WAAW,IAC5F,CACA,iBAAOL,CAAWM,GACd,MAAMC,EAAM,IAAIV,EAAmBS,EAAOE,QAC1C,OAAOD,EAAIE,IAAIH,EAAQ,EAC3B,CACAI,WAAAA,CAAYC,GACRC,KAAKD,IAAMA,CACf,CACAF,GAAAA,CAAIH,EAAQO,GACR,MAAMC,EAAOC,EAAAA,GAAoBC,EAAAA,UAAgBP,IAAIH,EAAQO,IAC7DA,GAAU,EACV,MAAMI,EAAUD,EAAAA,UAAgBP,IAAIH,EAAQO,GAC5CA,GAAU,EACV,MAAMK,EAAS,IAAIF,EAAAA,WAAiBC,EAAS,SAASR,IAAIH,EAAQO,GAClEA,GAAUI,EACV,MAAME,EAAUH,EAAAA,UAAgBP,IAAIH,EAAQO,GAC5CA,GAAU,EACV,MAAMO,EAAc,IAAIJ,EAAAA,WAAiBG,EAAS,SAASV,IAAIH,EAAQO,GACvEA,GAAUM,EACV,MAAME,EAAQL,EAAAA,UAAgBP,IAAIH,EAAQO,GAC1CA,GAAU,EACV,MAAMS,EAASN,EAAAA,UAAgBP,IAAIH,EAAQO,GAC3CA,GAAU,EACV,MAAMU,EAAeP,EAAAA,UAAgBP,IAAIH,EAAQO,GACjDA,GAAU,EACV,MAAMW,EAAgBR,EAAAA,UAAgBP,IAAIH,EAAQO,GAClDA,GAAU,EACV,MAAMY,EAAaT,EAAAA,UAAgBP,IAAIH,EAAQO,GAC/CA,GAAU,EACV,MAAMa,EAAOpB,EAAOqB,MAAMd,EAAQA,EAASY,GAC3C,MAAO,CACHX,OACAI,SACAE,cACAC,QACAC,SACAC,eACAC,gBACAE,OAER,EAMG,MAAME,EAAe,CACxBjB,IAAK,EACLF,IAAKA,CAACoB,EAAKC,KACA,CACHC,WAAYf,EAAAA,MAAYP,IAAIoB,EAAKC,GACjCE,OAAQ,IAAIhB,EAAAA,WAAiB,EAAG,SAASP,IAAIoB,EAAKC,EAAM,MAQvDG,EAAuB,CAChCtB,IAAK,GACLF,IAAKA,CAACyB,EAAYJ,KACP,CACHK,QAASnB,EAAAA,UAAgBP,IAAIyB,EAAYJ,EAAM,GAC/CM,YAAapB,EAAAA,MAAYP,IAAIyB,EAAYJ,EAAM,GAC/CO,WAAYrB,EAAAA,UAAgBP,IAAIyB,EAAYJ,EAAM,GAClDQ,WAAYtB,EAAAA,UAAgBP,IAAIyB,EAAYJ,EAAM,GAClDS,eAAgBvB,EAAAA,UAAgBP,IAAIyB,EAAYJ,EAAM,IACtDU,WAAYxB,EAAAA,UAAgBP,IAAIyB,EAAYJ,EAAM,M,6MC1E9D,MAAMW,EAAQC,EAAU,qCACjB,MAAMC,WAA2BC,EAAAA,EAAAA,IAA+B,YAMhE,MAAMC,EACTnC,WAAAA,CAAYoC,EAAUC,GAClBnC,KAAKoC,aAAe,GACpBpC,KAAKqC,oBAAqB,EAC1BrC,KAAKkC,SAAWA,EAChBlC,KAAKmC,QAAUA,CACnB,CAMA,eAAMG,CAAUC,EAAQC,GAEpB,GADAxC,KAAKyC,eAAiBF,EAClBA,EAAOG,WAAWC,UAClB3C,KAAK4C,eAAeL,EAAQC,OAE3B,CACD,GAAID,EAAOG,WAAWG,UAAW,CAC7B,GAAiC,IAA7B7C,KAAKoC,aAAaxC,OAClB,MAAM,IAAImC,EAAmB,oCAEjC/B,KAAKoC,aAAaU,KAAKN,EAC3B,CACA,GAAID,EAAOG,WAAWK,WAAaR,EAAOG,WAAWG,UAAW,CAE5D,GAAI7C,KAAKoC,aAAaxC,OAAS,EAAG,CAC9B,MAAMoD,EAAWf,EAAagB,iBAAiBjD,KAAKoC,oBAC9CpC,KAAKkD,cAAcF,EAC7B,CAEAhD,KAAKoC,aAAeG,EAAOG,WAAWK,SAAW,GAAK,CAACP,EAC3D,CACJ,CACJ,CACA,uBAAOS,CAAiBE,GACpB,MAAMC,EAAYD,EAAOE,OAAO,CAACC,EAAKC,IAAMD,EAAMC,EAAE3D,OAAQ,GACtD4D,EAAS,IAAInE,WAAW+D,GAK9B,OAJAD,EAAOM,QAAQ,CAACC,EAAOC,EAAGC,KACtB,MAAM3D,EAAS2D,EAAQ7C,MAAM,EAAG4C,GAAGN,OAAO,CAACC,EAAKC,IAAMD,EAAMC,EAAE3D,OAAQ,GACtE4D,EAAOK,IAAIH,EAAOzD,KAEfuD,CACX,CACA,WAAMM,SACI9D,KAAKkD,cAAcjB,EAAagB,iBAAiBjD,KAAKoC,cAChE,CACA,sBAAM2B,CAAiBvB,EAAUvC,GAC7B,MAAM+D,EAAU,IAAIC,EAAAA,EAAczB,EAAUvC,GACtCiE,EAAMF,EAAQD,mBAEpB,aADM/D,KAAKmE,OAAOD,EAAIE,IAAKF,EAAIG,OACxBH,EAAInE,GACf,CACA,YAAMoE,CAAOG,EAAID,GACb,GAAW,2BAAPC,GAAqD,kBAAVD,EAAqB,CAChE,GAAIrE,KAAKmC,QAAQoC,WAEb,YADA1C,EAAM,kBAGVwC,EAAQpF,EAAAA,GAAmBC,WAAWmF,GACtCxC,EAAM,oBAAoByC,aAAcD,EAAM/D,SAClD,MAEIuB,EAAM,gBAAgByC,YAAaD,WAEjCrE,KAAKkC,SAASiC,OAAO,SAAUG,EAAID,EAC7C,CACAG,iBAAAA,CAAkBC,GACVzE,KAAKyC,gBAAkBzC,KAAKkC,SAAS5B,OAAOmB,YAAczB,KAAKyC,eAAeiC,yBAA2B,IAEzG1E,KAAKkC,SAASyC,UAAU,kBAAmB3E,KAAKyC,eAAeiC,yBAC/D1E,KAAKkC,SAASyC,UAAU,WAAY3E,KAAKyC,eAAeiC,wBAA0B1E,KAAKkC,SAAS5B,OAAOmB,YAE/G,CAMAmB,cAAAA,CAAegC,EAASpC,GACpBxC,KAAKkC,SAASyC,UAAU,QAAS,YACjC3E,KAAKkC,SAASyC,UAAU,YAAY,GACpC9C,EAAM,oBAEN,MAAMgD,EAAe7D,EAAAA,EAAanB,IAAI2C,EAAU,GAChD,GAA4B,WAAxBqC,EAAazD,OACb,MAAM,IAAIW,EAAmB,sCACjC,GAAgC,IAA5B8C,EAAa1D,WAQb,MAAM,IAAIY,EAAmB,8DARE,CAC/B,MAAM+C,EAAWzD,EAAAA,GAAqBxB,IAAI2C,EAAUxB,EAAAA,EAAajB,KACjEC,KAAKkC,SAASyC,UAAU,aAAcG,EAASrD,YAC/CzB,KAAKkC,SAASyC,UAAU,UAAWG,EAASnD,gBAC5C3B,KAAKkC,SAASyC,UAAU,mBAAoBG,EAAStD,aACrDK,EAAM,uDAAwDiD,EAASrD,WAAYqD,EAASnD,eAAgBmD,EAAStD,YACzH,CAGJ,CACA,mBAAM0B,CAAcV,GAEhB,MAAMqC,EAAe7D,EAAAA,EAAanB,IAAI2C,EAAU,GAEhD,OADAX,EAAM,0CAA2CgD,EAAa1D,WAAYqB,EAASuC,YAC3EF,EAAa1D,YACjB,KAAK,EACD,OAAOnB,KAAKgF,qBAAqBxC,EAAUxB,EAAAA,EAAajB,KAC5D,KAAK,EACL,KAAK,EACD,MAEZ,CAIA,0BAAMiF,CAAqBxC,EAAUvC,GACjC,MAAMgF,EAAS7E,EAAAA,UAAgBP,IAAI2C,EAAUvC,GAC7CA,GAAU,EAEVA,GAAUgF,EACV,IAAIC,EAAwB9E,EAAAA,UAAgBP,IAAI2C,EAAUvC,GAC1DA,GAAU,EACV,MAAOiF,KAA0B,EAC7BjF,SAAiBD,KAAK+D,iBAAiBvB,EAAUvC,EAEzD,E,qLC7HJ,MAAM4B,EAAQsD,EAAU,8BACxB,MAAMC,WAAyBpD,EAAAA,EAAAA,IAA+B,UAEvD,MAAMqD,UAAmBC,EAAAA,EAC5BxF,WAAAA,GACIyF,SAASC,WACTxF,KAAKyF,aAAe,IAAIxD,EAAAA,EAAajC,KAAKkC,SAAUlC,KAAKmC,SACzDnC,KAAK0F,QAAU,CACnB,CACA,oBAAMC,GACF,MAAMC,QAAe5F,KAAK6F,UAAUC,UAAUC,EAAAA,GAC9C,GAA0B,SAAtBH,EAAOI,WACP,MAAM,IAAIZ,EAAiB,yBAE/B,IAAIa,EACJ,GAEIA,QAAoBjG,KAAK6F,UAAUC,UAAUI,EAAAA,UAEvClG,KAAKmG,eAAeF,UACpBA,EAAYG,WACtB,GAAIpG,KAAK6F,UAAUQ,SAASC,MAAQtG,KAAKkC,SAAS5B,OAAOiG,SAAU,CAC/D,MAAMC,EAAWxG,KAAK6F,UAAUQ,SAASC,KAAOtG,KAAK6F,UAAUY,SAC/DzG,KAAKkC,SAASyC,UAAU,UAAW,EAAI6B,EAAWxG,KAAKkC,SAAS5B,OAAOiG,SAC3E,CACJ,CACA,oBAAMJ,CAAeF,GAEjB,OADApE,EAAM,oBAAoBoE,EAAY/F,gBAAgB+F,EAAYrG,UAC1DqG,EAAY/F,MAChB,KAAKgG,EAAAA,GAAeQ,WAChB,OAAO1G,KAAK2G,oBAAoBV,EAAYrG,QAChD,KAAKsG,EAAAA,GAAeU,QAChB5G,KAAK0F,SAAWO,EAAYrG,OAC5B,MACJ,KAAKsG,EAAAA,GAAeW,YAChB,MACJ,KAAKX,EAAAA,GAAeY,UAChB,MACJ,KAAKZ,EAAAA,GAAea,eAChB,OAAO/G,KAAKgH,YAAYf,EAAYrG,QACxC,KAAKsG,EAAAA,GAAee,SAChB,MACJ,KAAKf,EAAAA,GAAegB,QAEhB,kBADMlH,KAAKmH,aAAalB,EAAYrG,QAExC,QACII,KAAKkC,SAASkF,WAAW,uBAAuBnB,EAAY/F,QAGpE,OAAOF,KAAK6F,UAAUwB,OAAOpB,EAAYrG,QAAQ0H,MACrD,CAIA,yBAAMX,CAAoBY,GACtB,GAAIA,IAAYrB,EAAAA,GAAqBnG,IACjC,MAAM,IAAIqF,EAAiB,uCAC/B,MAAMoC,QAAmBxH,KAAK6F,UAAUC,UAAUI,EAAAA,IAClDlG,KAAKkC,SAASyC,UAAU,YAAa,QACrC3E,KAAKyH,mBAAmBD,EAC5B,CAIAC,kBAAAA,CAAmBD,GACfxH,KAAKkC,SAASyC,UAAU,QAAS,QACjC3E,KAAKkC,SAASyC,UAAU,YAAY,GACpC3E,KAAKkC,SAASyC,UAAU,YAAY,GACpC3E,KAAKkC,SAASyC,UAAU,mBAAoB6C,EAAWE,UACvD1H,KAAKkC,SAASyC,UAAU,gBAAiB6C,EAAWG,eACpD3H,KAAKkC,SAASyC,UAAU,aAAc6C,EAAW/F,YAC7C+F,EAAWI,aAAe,GAC1B5H,KAAKkC,SAASyC,UAAU,WAAY6C,EAAWI,aAAeJ,EAAW/F,WAEjF,CAKA,iBAAMuF,CAAYO,GACd,MAAMzG,QAAad,KAAK6F,UAAUC,UAAU,IAAI+B,EAAAA,eAAeN,IAC/D,OAAOvH,KAAK8H,aAAahH,EAC7B,CAKA,kBAAMgH,CAAahH,GACf,MAAMkD,EAAU,IAAIC,EAAAA,EAAcnD,EAAM,GAClCiH,EAAS/D,EAAQgE,iBACnBD,EAAOnI,OAAS,GAChBI,KAAKkC,SAASyC,UAAU,OAAQoD,GAEpC,MAAME,EAAoBjE,EAAQkE,YAC5BC,EAAO,IAAIC,MAAMH,GACvB,IAAK,IAAItE,EAAI,EAAGA,EAAIsE,EAAmBtE,IACnCwE,EAAKxE,GAAKK,EAAQD,yBAEhBsE,QAAQC,IAAIH,EAAKI,IAAIrE,IACP,YAAZA,EAAIE,KACJpE,KAAKkC,SAASyC,UAAU,OAAQT,EAAIG,OAEjCrE,KAAKmE,OAAOD,EAAIE,IAAKF,EAAIG,SAExC,CACA,kBAAM8C,CAAaI,GACf,OAAIvH,KAAKmC,QAAQoC,WACNvE,KAAK6F,UAAUwB,OAAOE,GAE1BvH,KAAKwI,oBAAoBxI,KAAK6F,UAAUC,UAAU,IAAI7G,EAAAA,GAAmBsI,IACpF,CACAiB,aAAAA,CAAcC,GACV,OAAOzI,KAAKmE,OAAO,yBAA0BsE,EACjD,CACAtE,MAAAA,CAAOG,EAAID,GACP,OAAOrE,KAAKyF,aAAatB,OAAOG,EAAID,EACxC,E,gICvHG,MAAMqE,EAAY,CACrBhC,WAAY,EACZE,QAAS,EACTC,YAAa,EACbC,UAAW,EACXC,eAAgB,EAChBE,SAAU,EACVC,QAAS,GAEAyB,EAAc,CACvB5I,IAAK,EACLF,IAAKA,CAACoB,EAAKC,KACA,CACHkF,UAAWwC,EAAAA,GAAY3H,EAAKC,EAAK,GACjChB,KAAM0I,EAAAA,GAA0B3H,EAAKC,EAAK,EAAG,GAC7CtB,OAAQiJ,EAAAA,UAAUhJ,IAAIoB,EAAKC,EAAM,MAQhC4H,EAAkB,CAC3B/I,IAAK,GACLF,IAAKA,CAACoB,EAAKC,KACA,CAEH6H,iBAAkBC,EAAAA,UAAUnJ,IAAIoB,EAAKC,GAGrC+H,iBAAkBD,EAAAA,UAAUnJ,IAAIoB,EAAKC,EAAM,GAAK,IAGhDgI,iBAAkBL,EAAAA,UAAUhJ,IAAIoB,EAAKC,EAAM,GAG3CiI,iBAAkBN,EAAAA,UAAUhJ,IAAIoB,EAAKC,EAAM,GAI3CO,WAAYoH,EAAAA,UAAUhJ,IAAIoB,EAAKC,EAAM,KAAO,EAG5CwG,SAAUkB,EAAAA,GAA0B3H,EAAKC,EAAM,GAAI,EAAG,GAAK,EAG3DyG,cAAeiB,EAAAA,GAA0B3H,EAAKC,EAAM,GAAI,EAAG,GAAK,EAIhE0G,aAAcgB,EAAAA,GAA0B3H,EAAKC,EAAM,GAAI,EAAG,IAE1DkI,QAAS,IAAIvB,EAAAA,eAAe,IAAIhI,IAAIoB,EAAKC,EAAM,M,uHCrD3D,MAAMW,EAAQsD,EAAU,6BAIjB,MAAMG,UAA0B+D,EAAAA,EACnCvJ,WAAAA,GACIyF,SAASC,WACTxF,KAAKsJ,UAAY,IAAIC,EAAAA,CACzB,CACA,kCAAaC,CAAsB3D,GAC/B,MAAmE,eAArDA,EAAU4D,UAAUC,EAAAA,KAAcC,cACpD,CACA,WAAMC,GACF,UACU5J,KAAK6J,YACf,CACA,MAAOC,GACH,KAAIA,aAAeC,EAAAA,IAIf,MAAMD,EAHNjI,EAAM,gBAKd,CACJ,CACAmI,QAAAA,GAEA,CACA,gBAAMH,GAIF,SAHM7J,KAAKiK,sBACXpI,EAAM,iDAAkD7B,KAAK6F,UAAUY,gBACjEzG,KAAK2F,iBACP3F,KAAKmC,QAAQ+H,iBAAmBlK,KAAKkC,SAASiI,SAC9CnK,KAAKgK,eAEJ,CACD,MAAMI,EAAc,IAAIC,EAAAA,GAAYrK,KAAKkC,SAAUlC,KAAK6F,UAAW7F,KAAKmC,eAClEiI,EAAYR,QAClB5J,KAAKgK,UACT,CACJ,CACA,yBAAMC,GACF,MAAMK,QAAkBtK,KAAK6F,UAAU4D,UAAUC,EAAAA,IACjD,GAAiC,QAA7BY,EAAUX,eAGV,OAFA9H,EAAM,6BAA8B7B,KAAK6F,UAAUY,gBAC7CzG,KAAKsJ,UAAUM,MAAM5J,KAAKkC,SAAUlC,KAAK6F,UAAW7F,KAAKmC,SACxDnC,KAAKiK,qBAEpB,E,+ECpDG,MAAMhG,EACTnE,WAAAA,CAAYgB,EAAMb,GACdD,KAAKc,KAAOA,EACZd,KAAKC,OAASA,CAClB,CACAiI,SAAAA,GACI,MAAM7D,EAAQjE,EAAAA,UAAgBP,IAAIG,KAAKc,KAAMd,KAAKC,QAElD,OADAD,KAAKC,QAAU,EACRoE,CACX,CACA2D,cAAAA,GACI,MAAMjI,EAAMC,KAAKkI,YACX7D,GAAQkG,EAAAA,EAAAA,GAAWvK,KAAKc,KAAK0J,SAASxK,KAAKC,OAAQD,KAAKC,OAASF,GAAM,SAE7E,OADAC,KAAKC,QAAUF,EACRsE,CACX,CACAN,gBAAAA,GACI,MAAM0G,EAAUzK,KAAKC,OACfyK,EAAI1K,KAAKgI,iBACT2C,EAAMD,EAAEE,QAAQ,KACtB,MAAO,CACHxG,IAAKsG,EAAEG,UAAU,EAAGF,GAAKG,cACzBzG,MAAOqG,EAAEG,UAAUF,EAAM,GACzB5K,IAAKC,KAAKC,OAASwK,EAE3B,E","sources":["webpack://osi/./node_modules/music-metadata/lib/ogg/vorbis/Vorbis.js","webpack://osi/./node_modules/music-metadata/lib/ogg/vorbis/VorbisStream.js","webpack://osi/./node_modules/music-metadata/lib/flac/FlacParser.js","webpack://osi/./node_modules/music-metadata/lib/flac/FlacToken.js","webpack://osi/./node_modules/music-metadata/lib/id3v2/AbstractID3Parser.js","webpack://osi/./node_modules/music-metadata/lib/ogg/vorbis/VorbisDecoder.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport { AttachedPictureType } from '../../id3v2/ID3v2Token.js';\r\n/**\r\n * Parse the METADATA_BLOCK_PICTURE\r\n * Ref: https://wiki.xiph.org/VorbisComment#METADATA_BLOCK_PICTURE\r\n * Ref: https://xiph.org/flac/format.html#metadata_block_picture\r\n * // ToDo: move to ID3 / APIC?\r\n */\r\nexport class VorbisPictureToken {\r\n    static fromBase64(base64str) {\r\n        return VorbisPictureToken.fromBuffer(Uint8Array.from(atob(base64str), c => c.charCodeAt(0)));\r\n    }\r\n    static fromBuffer(buffer) {\r\n        const pic = new VorbisPictureToken(buffer.length);\r\n        return pic.get(buffer, 0);\r\n    }\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buffer, offset) {\r\n        const type = AttachedPictureType[Token.UINT32_BE.get(buffer, offset)];\r\n        offset += 4;\r\n        const mimeLen = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const format = new Token.StringType(mimeLen, 'utf-8').get(buffer, offset);\r\n        offset += mimeLen;\r\n        const descLen = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const description = new Token.StringType(descLen, 'utf-8').get(buffer, offset);\r\n        offset += descLen;\r\n        const width = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const height = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const colour_depth = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const indexed_color = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const picDataLen = Token.UINT32_BE.get(buffer, offset);\r\n        offset += 4;\r\n        const data = buffer.slice(offset, offset + picDataLen);\r\n        return {\r\n            type,\r\n            format,\r\n            description,\r\n            width,\r\n            height,\r\n            colour_depth,\r\n            indexed_color,\r\n            data\r\n        };\r\n    }\r\n}\r\n/**\r\n * Comment header decoder\r\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-620004.2.1\r\n */\r\nexport const CommonHeader = {\r\n    len: 7,\r\n    get: (buf, off) => {\r\n        return {\r\n            packetType: Token.UINT8.get(buf, off),\r\n            vorbis: new Token.StringType(6, 'ascii').get(buf, off + 1)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Identification header decoder\r\n * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-630004.2.2\r\n */\r\nexport const IdentificationHeader = {\r\n    len: 23,\r\n    get: (uint8Array, off) => {\r\n        return {\r\n            version: Token.UINT32_LE.get(uint8Array, off + 0),\r\n            channelMode: Token.UINT8.get(uint8Array, off + 4),\r\n            sampleRate: Token.UINT32_LE.get(uint8Array, off + 5),\r\n            bitrateMax: Token.UINT32_LE.get(uint8Array, off + 9),\r\n            bitrateNominal: Token.UINT32_LE.get(uint8Array, off + 13),\r\n            bitrateMin: Token.UINT32_LE.get(uint8Array, off + 17)\r\n        };\r\n    }\r\n};\r\n","import * as Token from 'token-types';\r\nimport debugInit from 'debug';\r\nimport { VorbisDecoder } from './VorbisDecoder.js';\r\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\r\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\r\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\r\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\r\n}\r\n/**\r\n * Vorbis 1 Parser.\r\n * Used by OggStream\r\n */\r\nexport class VorbisStream {\r\n    constructor(metadata, options) {\r\n        this.pageSegments = [];\r\n        this.durationOnLastPage = true;\r\n        this.metadata = metadata;\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Vorbis 1 parser\r\n     * @param header Ogg Page Header\r\n     * @param pageData Page data\r\n     */\r\n    async parsePage(header, pageData) {\r\n        this.lastPageHeader = header;\r\n        if (header.headerType.firstPage) {\r\n            this.parseFirstPage(header, pageData);\r\n        }\r\n        else {\r\n            if (header.headerType.continued) {\r\n                if (this.pageSegments.length === 0) {\r\n                    throw new VorbisContentError('Cannot continue on previous page');\r\n                }\r\n                this.pageSegments.push(pageData);\r\n            }\r\n            if (header.headerType.lastPage || !header.headerType.continued) {\r\n                // Flush page segments\r\n                if (this.pageSegments.length > 0) {\r\n                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\r\n                    await this.parseFullPage(fullPage);\r\n                }\r\n                // Reset page segments\r\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\r\n            }\r\n        }\r\n    }\r\n    static mergeUint8Arrays(arrays) {\r\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\r\n        const merged = new Uint8Array(totalSize);\r\n        arrays.forEach((array, i, _arrays) => {\r\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\r\n            merged.set(array, offset);\r\n        });\r\n        return merged;\r\n    }\r\n    async flush() {\r\n        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\r\n    }\r\n    async parseUserComment(pageData, offset) {\r\n        const decoder = new VorbisDecoder(pageData, offset);\r\n        const tag = decoder.parseUserComment();\r\n        await this.addTag(tag.key, tag.value);\r\n        return tag.len;\r\n    }\r\n    async addTag(id, value) {\r\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\r\n            if (this.options.skipCovers) {\r\n                debug(\"Ignore picture\");\r\n                return;\r\n            }\r\n            value = VorbisPictureToken.fromBase64(value);\r\n            debug(`Push picture: id=${id}, format=${value.format}`);\r\n        }\r\n        else {\r\n            debug(`Push tag: id=${id}, value=${value}`);\r\n        }\r\n        await this.metadata.addTag('vorbis', id, value);\r\n    }\r\n    calculateDuration(enfOfStream) {\r\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\r\n            // Calculate duration\r\n            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\r\n            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\r\n        }\r\n    }\r\n    /**\r\n     * Parse first Ogg/Vorbis page\r\n     * @param _header\r\n     * @param pageData\r\n     */\r\n    parseFirstPage(_header, pageData) {\r\n        this.metadata.setFormat('codec', 'Vorbis I');\r\n        this.metadata.setFormat('hasAudio', true);\r\n        debug('Parse first page');\r\n        // Parse  Vorbis common header\r\n        const commonHeader = CommonHeader.get(pageData, 0);\r\n        if (commonHeader.vorbis !== 'vorbis')\r\n            throw new VorbisContentError('Metadata does not look like Vorbis');\r\n        if (commonHeader.packetType === 1) {\r\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\r\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\r\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\r\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\r\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\r\n        }\r\n        else\r\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\r\n    }\r\n    async parseFullPage(pageData) {\r\n        // New page\r\n        const commonHeader = CommonHeader.get(pageData, 0);\r\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\r\n        switch (commonHeader.packetType) {\r\n            case 3: //  type 3: comment header\r\n                return this.parseUserCommentList(pageData, CommonHeader.len);\r\n            case 1: // type 1: the identification header\r\n            case 5: // type 5: setup header type\r\n                break; // ignore\r\n        }\r\n    }\r\n    /**\r\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\r\n     */\r\n    async parseUserCommentList(pageData, offset) {\r\n        const strLen = Token.UINT32_LE.get(pageData, offset);\r\n        offset += 4;\r\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\r\n        offset += strLen;\r\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\r\n        offset += 4;\r\n        while (userCommentListLength-- > 0) {\r\n            offset += (await this.parseUserComment(pageData, offset));\r\n        }\r\n    }\r\n}\r\n","import initDebug from 'debug';\r\nimport { Uint8ArrayType } from 'token-types';\r\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\r\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { VorbisStream } from '../ogg/vorbis/VorbisStream.js';\r\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nimport * as Flac from './FlacToken.js';\r\nconst debug = initDebug('music-metadata:parser:FLAC');\r\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\r\n}\r\nexport class FlacParser extends AbstractID3Parser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.vorbisParser = new VorbisStream(this.metadata, this.options);\r\n        this.padding = 0;\r\n    }\r\n    async postId3v2Parse() {\r\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\r\n        if (fourCC.toString() !== 'fLaC') {\r\n            throw new FlacContentError('Invalid FLAC preamble');\r\n        }\r\n        let blockHeader;\r\n        do {\r\n            // Read block header\r\n            blockHeader = await this.tokenizer.readToken(Flac.BlockHeader);\r\n            // Parse block data\r\n            await this.parseDataBlock(blockHeader);\r\n        } while (!blockHeader.lastBlock);\r\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\r\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\r\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\r\n        }\r\n    }\r\n    async parseDataBlock(blockHeader) {\r\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\r\n        switch (blockHeader.type) {\r\n            case Flac.BlockType.STREAMINFO:\r\n                return this.readBlockStreamInfo(blockHeader.length);\r\n            case Flac.BlockType.PADDING:\r\n                this.padding += blockHeader.length;\r\n                break;\r\n            case Flac.BlockType.APPLICATION:\r\n                break;\r\n            case Flac.BlockType.SEEKTABLE:\r\n                break;\r\n            case Flac.BlockType.VORBIS_COMMENT:\r\n                return this.readComment(blockHeader.length);\r\n            case Flac.BlockType.CUESHEET:\r\n                break;\r\n            case Flac.BlockType.PICTURE:\r\n                await this.parsePicture(blockHeader.length);\r\n                return;\r\n            default:\r\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\r\n        }\r\n        // Ignore data block\r\n        return this.tokenizer.ignore(blockHeader.length).then();\r\n    }\r\n    /**\r\n     * Parse STREAMINFO\r\n     */\r\n    async readBlockStreamInfo(dataLen) {\r\n        if (dataLen !== Flac.BlockStreamInfo.len)\r\n            throw new FlacContentError('Unexpected block-stream-info length');\r\n        const streamInfo = await this.tokenizer.readToken(Flac.BlockStreamInfo);\r\n        this.metadata.setFormat('container', 'FLAC');\r\n        this.processsStreamInfo(streamInfo);\r\n    }\r\n    /**\r\n     * Parse STREAMINFO\r\n     */\r\n    processsStreamInfo(streamInfo) {\r\n        this.metadata.setFormat('codec', 'FLAC');\r\n        this.metadata.setFormat('hasAudio', true);\r\n        this.metadata.setFormat('lossless', true);\r\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\r\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\r\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\r\n        if (streamInfo.totalSamples > 0) {\r\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\r\n        }\r\n    }\r\n    /**\r\n     * Read VORBIS_COMMENT from tokenizer\r\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\r\n     */\r\n    async readComment(dataLen) {\r\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\r\n        return this.parseComment(data);\r\n    }\r\n    /**\r\n     * Parse VORBIS_COMMENT\r\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\r\n     */\r\n    async parseComment(data) {\r\n        const decoder = new VorbisDecoder(data, 0);\r\n        const vendor = decoder.readStringUtf8();\r\n        if (vendor.length > 0) {\r\n            this.metadata.setFormat('tool', vendor);\r\n        }\r\n        const commentListLength = decoder.readInt32();\r\n        const tags = new Array(commentListLength);\r\n        for (let i = 0; i < commentListLength; i++) {\r\n            tags[i] = decoder.parseUserComment();\r\n        }\r\n        await Promise.all(tags.map(tag => {\r\n            if (tag.key === 'ENCODER') {\r\n                this.metadata.setFormat('tool', tag.value);\r\n            }\r\n            return this.addTag(tag.key, tag.value);\r\n        }));\r\n    }\r\n    async parsePicture(dataLen) {\r\n        if (this.options.skipCovers) {\r\n            return this.tokenizer.ignore(dataLen);\r\n        }\r\n        return this.addPictureTag(await this.tokenizer.readToken(new VorbisPictureToken(dataLen)));\r\n    }\r\n    addPictureTag(picture) {\r\n        return this.addTag('METADATA_BLOCK_PICTURE', picture);\r\n    }\r\n    addTag(id, value) {\r\n        return this.vorbisParser.addTag(id, value);\r\n    }\r\n}\r\n","import * as util from '../common/Util.js';\r\nimport { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\r\n/**\r\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\r\n * ref: https://xiph.org/flac/format.html#metadata_block\r\n */\r\nexport const BlockType = {\r\n    STREAMINFO: 0, // STREAMINFO\r\n    PADDING: 1, // PADDING\r\n    APPLICATION: 2, // APPLICATION\r\n    SEEKTABLE: 3, // SEEKTABLE\r\n    VORBIS_COMMENT: 4, // VORBIS_COMMENT\r\n    CUESHEET: 5, // CUESHEET\r\n    PICTURE: 6 // PICTURE\r\n};\r\nexport const BlockHeader = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return {\r\n            lastBlock: util.getBit(buf, off, 7),\r\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\r\n            length: UINT24_BE.get(buf, off + 1)\r\n        };\r\n    }\r\n};\r\n/**\r\n * METADATA_BLOCK_DATA\r\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\r\n */\r\nexport const BlockStreamInfo = {\r\n    len: 34,\r\n    get: (buf, off) => {\r\n        return {\r\n            // The minimum block size (in samples) used in the stream.\r\n            minimumBlockSize: UINT16_BE.get(buf, off),\r\n            // The maximum block size (in samples) used in the stream.\r\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\r\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\r\n            // The minimum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\r\n            // The maximum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\r\n            // Sample rate in Hz. Though 20 bits are available,\r\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\r\n            // Also, a value of 0 is invalid.\r\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\r\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\r\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\r\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\r\n            // bits per sample)-1.\r\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\r\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\r\n            // Total samples in stream.\r\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\r\n            // A value of zero here means the number of total samples is unknown.\r\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\r\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\r\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\r\n        };\r\n    }\r\n};\r\n","import { EndOfStreamError } from 'strtok3';\r\nimport initDebug from 'debug';\r\nimport { ID3v2Header } from './ID3v2Token.js';\r\nimport { ID3v2Parser } from './ID3v2Parser.js';\r\nimport { ID3v1Parser } from '../id3v1/ID3v1Parser.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nconst debug = initDebug('music-metadata:parser:ID3');\r\n/**\r\n * Abstract parser which tries take ID3v2 and ID3v1 headers.\r\n */\r\nexport class AbstractID3Parser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.id3parser = new ID3v2Parser();\r\n    }\r\n    static async startsWithID3v2Header(tokenizer) {\r\n        return (await tokenizer.peekToken(ID3v2Header)).fileIdentifier === 'ID3';\r\n    }\r\n    async parse() {\r\n        try {\r\n            await this.parseID3v2();\r\n        }\r\n        catch (err) {\r\n            if (err instanceof EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    finalize() {\r\n        return;\r\n    }\r\n    async parseID3v2() {\r\n        await this.tryReadId3v2Headers();\r\n        debug('End of ID3v2 header, go to MPEG-parser: pos=%s', this.tokenizer.position);\r\n        await this.postId3v2Parse();\r\n        if (this.options.skipPostHeaders && this.metadata.hasAny()) {\r\n            this.finalize();\r\n        }\r\n        else {\r\n            const id3v1parser = new ID3v1Parser(this.metadata, this.tokenizer, this.options);\r\n            await id3v1parser.parse();\r\n            this.finalize();\r\n        }\r\n    }\r\n    async tryReadId3v2Headers() {\r\n        const id3Header = await this.tokenizer.peekToken(ID3v2Header);\r\n        if (id3Header.fileIdentifier === 'ID3') {\r\n            debug('Found ID3v2 header, pos=%s', this.tokenizer.position);\r\n            await this.id3parser.parse(this.metadata, this.tokenizer, this.options);\r\n            return this.tryReadId3v2Headers();\r\n        }\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport { textDecode } from '@borewit/text-codec';\r\nexport class VorbisDecoder {\r\n    constructor(data, offset) {\r\n        this.data = data;\r\n        this.offset = offset;\r\n    }\r\n    readInt32() {\r\n        const value = Token.UINT32_LE.get(this.data, this.offset);\r\n        this.offset += 4;\r\n        return value;\r\n    }\r\n    readStringUtf8() {\r\n        const len = this.readInt32();\r\n        const value = textDecode(this.data.subarray(this.offset, this.offset + len), 'utf-8');\r\n        this.offset += len;\r\n        return value;\r\n    }\r\n    parseUserComment() {\r\n        const offset0 = this.offset;\r\n        const v = this.readStringUtf8();\r\n        const idx = v.indexOf('=');\r\n        return {\r\n            key: v.substring(0, idx).toUpperCase(),\r\n            value: v.substring(idx + 1),\r\n            len: this.offset - offset0\r\n        };\r\n    }\r\n}\r\n"],"names":["VorbisPictureToken","fromBase64","base64str","fromBuffer","Uint8Array","from","atob","c","charCodeAt","buffer","pic","length","get","constructor","len","this","offset","type","AttachedPictureType","Token","mimeLen","format","descLen","description","width","height","colour_depth","indexed_color","picDataLen","data","slice","CommonHeader","buf","off","packetType","vorbis","IdentificationHeader","uint8Array","version","channelMode","sampleRate","bitrateMax","bitrateNominal","bitrateMin","debug","debugInit","VorbisContentError","makeUnexpectedFileContentError","VorbisStream","metadata","options","pageSegments","durationOnLastPage","parsePage","header","pageData","lastPageHeader","headerType","firstPage","parseFirstPage","continued","push","lastPage","fullPage","mergeUint8Arrays","parseFullPage","arrays","totalSize","reduce","acc","e","merged","forEach","array","i","_arrays","set","flush","parseUserComment","decoder","VorbisDecoder","tag","addTag","key","value","id","skipCovers","calculateDuration","enfOfStream","absoluteGranulePosition","setFormat","_header","commonHeader","idHeader","byteLength","parseUserCommentList","strLen","userCommentListLength","initDebug","FlacContentError","FlacParser","AbstractID3Parser","super","arguments","vorbisParser","padding","postId3v2Parse","fourCC","tokenizer","readToken","FourCcToken","toString","blockHeader","Flac","parseDataBlock","lastBlock","fileInfo","size","duration","dataSize","position","STREAMINFO","readBlockStreamInfo","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","readComment","CUESHEET","PICTURE","parsePicture","addWarning","ignore","then","dataLen","streamInfo","processsStreamInfo","channels","bitsPerSample","totalSamples","Uint8ArrayType","parseComment","vendor","readStringUtf8","commentListLength","readInt32","tags","Array","Promise","all","map","addPictureTag","picture","BlockType","BlockHeader","util","UINT24_BE","BlockStreamInfo","minimumBlockSize","UINT16_BE","maximumBlockSize","minimumFrameSize","maximumFrameSize","fileMD5","BasicParser","id3parser","ID3v2Parser","startsWithID3v2Header","peekToken","ID3v2Header","fileIdentifier","parse","parseID3v2","err","EndOfStreamError","finalize","tryReadId3v2Headers","skipPostHeaders","hasAny","id3v1parser","ID3v1Parser","id3Header","textDecode","subarray","offset0","v","idx","indexOf","substring","toUpperCase"],"ignoreList":[],"sourceRoot":""}