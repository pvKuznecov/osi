{"version":3,"file":"js/245.3abe09c4.js","mappings":"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","sources":["webpack://osi/./node_modules/music-metadata/lib/dsdiff/DsdiffToken.js","webpack://osi/./node_modules/music-metadata/lib/dsdiff/DsdiffParser.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\n/**\r\n * DSDIFF chunk header\r\n * The data-size encoding is deviating from EA-IFF 85\r\n * Ref: http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\r\n */\r\nexport const ChunkHeader64 = {\r\n    len: 12,\r\n    get: (buf, off) => {\r\n        return {\r\n            // Group-ID\r\n            chunkID: FourCcToken.get(buf, off),\r\n            // Size\r\n            chunkSize: Token.INT64_BE.get(buf, off + 4)\r\n        };\r\n    }\r\n};\r\n","import * as Token from 'token-types';\r\nimport initDebug from 'debug';\r\nimport * as strtok3 from 'strtok3';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\r\nimport { ChunkHeader64 } from './DsdiffToken.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:aiff');\r\nexport class DsdiffContentParseError extends makeUnexpectedFileContentError('DSDIFF') {\r\n}\r\n/**\r\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\r\n *\r\n * Ref:\r\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\r\n */\r\nexport class DsdiffParser extends BasicParser {\r\n    async parse() {\r\n        const header = await this.tokenizer.readToken(ChunkHeader64);\r\n        if (header.chunkID !== 'FRM8')\r\n            throw new DsdiffContentParseError('Unexpected chunk-ID');\r\n        this.metadata.setAudioOnly();\r\n        const type = (await this.tokenizer.readToken(FourCcToken)).trim();\r\n        switch (type) {\r\n            case 'DSD':\r\n                this.metadata.setFormat('container', `DSDIFF/${type}`);\r\n                this.metadata.setFormat('lossless', true);\r\n                return this.readFmt8Chunks(header.chunkSize - BigInt(FourCcToken.len));\r\n            default:\r\n                throw new DsdiffContentParseError(`Unsupported DSDIFF type: ${type}`);\r\n        }\r\n    }\r\n    async readFmt8Chunks(remainingSize) {\r\n        while (remainingSize >= ChunkHeader64.len) {\r\n            const chunkHeader = await this.tokenizer.readToken(ChunkHeader64);\r\n            //  If the data is an odd number of bytes in length, a pad byte must be added at the end\r\n            debug(`Chunk id=${chunkHeader.chunkID}`);\r\n            await this.readData(chunkHeader);\r\n            remainingSize -= (BigInt(ChunkHeader64.len) + chunkHeader.chunkSize);\r\n        }\r\n    }\r\n    async readData(header) {\r\n        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\r\n        const p0 = this.tokenizer.position;\r\n        switch (header.chunkID.trim()) {\r\n            case 'FVER': { // 3.1 FORMAT VERSION CHUNK\r\n                const version = await this.tokenizer.readToken(Token.UINT32_LE);\r\n                debug(`DSDIFF version=${version}`);\r\n                break;\r\n            }\r\n            case 'PROP': { // 3.2 PROPERTY CHUNK\r\n                const propType = await this.tokenizer.readToken(FourCcToken);\r\n                if (propType !== 'SND ')\r\n                    throw new DsdiffContentParseError('Unexpected PROP-chunk ID');\r\n                await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCcToken.len));\r\n                break;\r\n            }\r\n            case 'ID3': { // Unofficial ID3 tag support\r\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\r\n                const rst = strtok3.fromBuffer(id3_data);\r\n                await new ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                break;\r\n            }\r\n            case 'DSD':\r\n                if (this.metadata.format.numberOfChannels) {\r\n                    this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\r\n                }\r\n                if (this.metadata.format.numberOfSamples && this.metadata.format.sampleRate) {\r\n                    this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\r\n                }\r\n                break;\r\n            default:\r\n                debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\r\n                break;\r\n        }\r\n        const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\r\n        if (remaining > 0) {\r\n            debug(`After Parsing chunk, remaining ${remaining} bytes`);\r\n            await this.tokenizer.ignore(Number(remaining));\r\n        }\r\n    }\r\n    async handleSoundPropertyChunks(remainingSize) {\r\n        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\r\n        while (remainingSize > 0) {\r\n            const sndPropHeader = await this.tokenizer.readToken(ChunkHeader64);\r\n            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\r\n            const p0 = this.tokenizer.position;\r\n            switch (sndPropHeader.chunkID.trim()) {\r\n                case 'FS': { // 3.2.1 Sample Rate Chunk\r\n                    const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\r\n                    this.metadata.setFormat('sampleRate', sampleRate);\r\n                    break;\r\n                }\r\n                case 'CHNL': { // 3.2.2 Channels Chunk\r\n                    const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\r\n                    this.metadata.setFormat('numberOfChannels', numChannels);\r\n                    await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\r\n                    break;\r\n                }\r\n                case 'CMPR': { // 3.2.3 Compression Type Chunk\r\n                    const compressionIdCode = (await this.tokenizer.readToken(FourCcToken)).trim();\r\n                    const count = await this.tokenizer.readToken(Token.UINT8);\r\n                    const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\r\n                    if (compressionIdCode === 'DSD') {\r\n                        this.metadata.setFormat('lossless', true);\r\n                        this.metadata.setFormat('bitsPerSample', 1);\r\n                    }\r\n                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\r\n                    break;\r\n                }\r\n                case 'ABSS': { // 3.2.4 Absolute Start Time Chunk\r\n                    const hours = await this.tokenizer.readToken(Token.UINT16_BE);\r\n                    const minutes = await this.tokenizer.readToken(Token.UINT8);\r\n                    const seconds = await this.tokenizer.readToken(Token.UINT8);\r\n                    const samples = await this.tokenizer.readToken(Token.UINT32_BE);\r\n                    debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\r\n                    break;\r\n                }\r\n                case 'LSCO': { // 3.2.5 Loudspeaker Configuration Chunk\r\n                    const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\r\n                    debug(`LSCO lsConfig=${lsConfig}`);\r\n                    break;\r\n                }\r\n                default:\r\n                    debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\r\n                    await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\r\n            }\r\n            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\r\n            if (remaining > 0) {\r\n                debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\r\n                await this.tokenizer.ignore(Number(remaining));\r\n            }\r\n            remainingSize -= BigInt(ChunkHeader64.len) + sndPropHeader.chunkSize;\r\n            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\r\n        }\r\n        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\r\n            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\r\n            this.metadata.setFormat('bitrate', bitrate);\r\n        }\r\n    }\r\n    async handleChannelChunks(remainingSize) {\r\n        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\r\n        const channels = [];\r\n        while (remainingSize >= FourCcToken.len) {\r\n            const channelId = await this.tokenizer.readToken(FourCcToken);\r\n            debug(`Channel[ID=${channelId}]`);\r\n            channels.push(channelId);\r\n            remainingSize -= BigInt(FourCcToken.len);\r\n        }\r\n        debug(`Channels: ${channels.join(', ')}`);\r\n        return channels;\r\n    }\r\n}\r\n"],"names":["ChunkHeader64","len","get","buf","off","chunkID","FourCcToken","chunkSize","Token","debug","initDebug","DsdiffContentParseError","makeUnexpectedFileContentError","DsdiffParser","BasicParser","parse","header","this","tokenizer","readToken","metadata","setAudioOnly","type","trim","setFormat","readFmt8Chunks","BigInt","remainingSize","chunkHeader","readData","p0","position","version","propType","handleSoundPropertyChunks","id3_data","Number","rst","strtok3","ID3v2Parser","options","format","numberOfChannels","numberOfSamples","sampleRate","remaining","ignore","sndPropHeader","numChannels","handleChannelChunks","compressionIdCode","count","compressionName","hours","minutes","seconds","samples","lsConfig","lossless","bitsPerSample","bitrate","channels","channelId","push","join"],"ignoreList":[],"sourceRoot":""}