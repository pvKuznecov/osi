{"version":3,"file":"js/479.fee158ab.js","mappings":"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","sources":["webpack://osi/./node_modules/music-metadata/lib/mp4/AtomToken.js","webpack://osi/./node_modules/music-metadata/lib/mp4/Atom.js","webpack://osi/./node_modules/music-metadata/lib/mp4/MP4Parser.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport initDebug from 'debug';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nimport * as util from '../common/Util.js';\r\nconst debug = initDebug('music-metadata:parser:MP4:atom');\r\nexport class Mp4ContentError extends makeUnexpectedFileContentError('MP4') {\r\n}\r\nexport const Header = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        const length = Token.UINT32_BE.get(buf, off);\r\n        if (length < 0)\r\n            throw new Mp4ContentError('Invalid atom header length');\r\n        return {\r\n            length: BigInt(length),\r\n            name: new Token.StringType(4, 'latin1').get(buf, off + 4)\r\n        };\r\n    },\r\n    put: (buf, off, hdr) => {\r\n        Token.UINT32_BE.put(buf, off, Number(hdr.length));\r\n        return FourCcToken.put(buf, off + 4, hdr.name);\r\n    }\r\n};\r\n/**\r\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap1/qtff1.html#//apple_ref/doc/uid/TP40000939-CH203-38190\r\n */\r\nexport const ExtendedSize = Token.UINT64_BE;\r\nexport const ftyp = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return {\r\n            type: new Token.StringType(4, 'ascii').get(buf, off)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Token: Movie Header Atom\r\n */\r\nexport const mhdr = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        return {\r\n            version: Token.UINT8.get(buf, off),\r\n            flags: Token.UINT24_BE.get(buf, off + 1),\r\n            nextItemID: Token.UINT32_BE.get(buf, off + 4)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Base class for 'fixed' length atoms.\r\n * In some cases these atoms are longer then the sum of the described fields.\r\n * Issue: https://github.com/Borewit/music-metadata/issues/120\r\n */\r\nexport class FixedLengthAtom {\r\n    /**\r\n     *\r\n     * @param {number} len Length as specified in the size field\r\n     * @param {number} expLen Total length of sum of specified fields in the standard\r\n     * @param atomId Atom ID\r\n     */\r\n    constructor(len, expLen, atomId) {\r\n        if (len < expLen) {\r\n            throw new Mp4ContentError(`Atom ${atomId} expected to be ${expLen}, but specifies ${len} bytes long.`);\r\n        }\r\n        if (len > expLen) {\r\n            debug(`Warning: atom ${atomId} expected to be ${expLen}, but was actually ${len} bytes long.`);\r\n        }\r\n        this.len = len;\r\n    }\r\n}\r\n/**\r\n * Timestamp stored in seconds since Mac Epoch (1 January 1904)\r\n */\r\nconst SecondsSinceMacEpoch = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        const secondsSinceUnixEpoch = Token.UINT32_BE.get(buf, off) - 2082844800;\r\n        return new Date(secondsSinceUnixEpoch * 1000);\r\n    }\r\n};\r\n/**\r\n * Token: Media Header Atom\r\n * Ref:\r\n * - https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-SW34\r\n * - https://wiki.multimedia.cx/index.php/QuickTime_container#mdhd\r\n */\r\nexport class MdhdAtom extends FixedLengthAtom {\r\n    constructor(len) {\r\n        super(len, 24, 'mdhd');\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            version: Token.UINT8.get(buf, off + 0),\r\n            flags: Token.UINT24_BE.get(buf, off + 1),\r\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\r\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\r\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\r\n            duration: Token.UINT32_BE.get(buf, off + 16),\r\n            language: Token.UINT16_BE.get(buf, off + 20),\r\n            quality: Token.UINT16_BE.get(buf, off + 22)\r\n        };\r\n    }\r\n}\r\n/**\r\n * Token: Movie Header Atom\r\n */\r\nexport class MvhdAtom extends FixedLengthAtom {\r\n    constructor(len) {\r\n        super(len, 100, 'mvhd');\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            version: Token.UINT8.get(buf, off),\r\n            flags: Token.UINT24_BE.get(buf, off + 1),\r\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\r\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\r\n            timeScale: Token.UINT32_BE.get(buf, off + 12),\r\n            duration: Token.UINT32_BE.get(buf, off + 16),\r\n            preferredRate: Token.UINT32_BE.get(buf, off + 20),\r\n            preferredVolume: Token.UINT16_BE.get(buf, off + 24),\r\n            // ignore reserver: 10 bytes\r\n            // ignore matrix structure: 36 bytes\r\n            previewTime: Token.UINT32_BE.get(buf, off + 72),\r\n            previewDuration: Token.UINT32_BE.get(buf, off + 76),\r\n            posterTime: Token.UINT32_BE.get(buf, off + 80),\r\n            selectionTime: Token.UINT32_BE.get(buf, off + 84),\r\n            selectionDuration: Token.UINT32_BE.get(buf, off + 88),\r\n            currentTime: Token.UINT32_BE.get(buf, off + 92),\r\n            nextTrackID: Token.UINT32_BE.get(buf, off + 96)\r\n        };\r\n    }\r\n}\r\n/**\r\n * Data Atom Structure\r\n */\r\nexport class DataAtom {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            type: {\r\n                set: Token.UINT8.get(buf, off + 0),\r\n                type: Token.UINT24_BE.get(buf, off + 1)\r\n            },\r\n            locale: Token.UINT24_BE.get(buf, off + 4),\r\n            value: new Token.Uint8ArrayType(this.len - 8).get(buf, off + 8)\r\n        };\r\n    }\r\n}\r\n/**\r\n * Data Atom Structure\r\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW31\r\n */\r\nexport class NameAtom {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            version: Token.UINT8.get(buf, off),\r\n            flags: Token.UINT24_BE.get(buf, off + 1),\r\n            name: new Token.StringType(this.len - 4, 'utf-8').get(buf, off + 4)\r\n        };\r\n    }\r\n}\r\n/**\r\n * Track Header Atoms structure (`tkhd`)\r\n * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25550\r\n */\r\nexport class TrackHeaderAtom {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            version: Token.UINT8.get(buf, off),\r\n            flags: Token.UINT24_BE.get(buf, off + 1),\r\n            creationTime: SecondsSinceMacEpoch.get(buf, off + 4),\r\n            modificationTime: SecondsSinceMacEpoch.get(buf, off + 8),\r\n            trackId: Token.UINT32_BE.get(buf, off + 12),\r\n            // reserved 4 bytes\r\n            duration: Token.UINT32_BE.get(buf, off + 20),\r\n            layer: Token.UINT16_BE.get(buf, off + 24),\r\n            alternateGroup: Token.UINT16_BE.get(buf, off + 26),\r\n            volume: Token.UINT16_BE.get(buf, off + 28) // ToDo: fixed point\r\n            // ToDo: add remaining fields\r\n        };\r\n    }\r\n}\r\n/**\r\n * Atom: Sample Description Atom ('stsd')\r\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\r\n */\r\nconst stsdHeader = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        return {\r\n            version: Token.UINT8.get(buf, off),\r\n            flags: Token.UINT24_BE.get(buf, off + 1),\r\n            numberOfEntries: Token.UINT32_BE.get(buf, off + 4)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Atom: Sample Description Atom ('stsd')\r\n * Ref: https://developer.apple.com/documentation/quicktime-file-format/sample_description_atom\r\n */\r\nclass SampleDescriptionTable {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        const descrLen = this.len - 12;\r\n        return {\r\n            dataFormat: FourCcToken.get(buf, off),\r\n            dataReferenceIndex: Token.UINT16_BE.get(buf, off + 10),\r\n            description: descrLen > 0 ? new Token.Uint8ArrayType(descrLen).get(buf, off + 12) : undefined\r\n        };\r\n    }\r\n}\r\n/**\r\n * Atom: Sample-description Atom ('stsd')\r\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25691\r\n */\r\nexport class StsdAtom {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        const header = stsdHeader.get(buf, off);\r\n        off += stsdHeader.len;\r\n        const table = [];\r\n        for (let n = 0; n < header.numberOfEntries; ++n) {\r\n            const size = Token.UINT32_BE.get(buf, off); // Sample description size\r\n            off += Token.UINT32_BE.len;\r\n            table.push(new SampleDescriptionTable(size - Token.UINT32_BE.len).get(buf, off));\r\n            off += size;\r\n        }\r\n        return {\r\n            header,\r\n            table\r\n        };\r\n    }\r\n}\r\n/**\r\n * Common Sound Sample Description (version & revision)\r\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-57317\r\n */\r\nexport const SoundSampleDescriptionVersion = {\r\n    len: 8,\r\n    get(buf, off) {\r\n        return {\r\n            version: Token.INT16_BE.get(buf, off),\r\n            revision: Token.INT16_BE.get(buf, off + 2),\r\n            vendor: Token.INT32_BE.get(buf, off + 4)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Sound Sample Description (Version 0)\r\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-130736\r\n */\r\nexport const SoundSampleDescriptionV0 = {\r\n    len: 12,\r\n    get(buf, off) {\r\n        return {\r\n            numAudioChannels: Token.INT16_BE.get(buf, off + 0),\r\n            sampleSize: Token.INT16_BE.get(buf, off + 2),\r\n            compressionId: Token.INT16_BE.get(buf, off + 4),\r\n            packetSize: Token.INT16_BE.get(buf, off + 6),\r\n            sampleRate: Token.UINT16_BE.get(buf, off + 8) + Token.UINT16_BE.get(buf, off + 10) / 10000\r\n        };\r\n    }\r\n};\r\nclass SimpleTableAtom {\r\n    constructor(len, token) {\r\n        this.len = len;\r\n        this.token = token;\r\n    }\r\n    get(buf, off) {\r\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 4);\r\n        return {\r\n            version: Token.INT8.get(buf, off + 0),\r\n            flags: Token.INT24_BE.get(buf, off + 1),\r\n            numberOfEntries: nrOfEntries,\r\n            entries: readTokenTable(buf, this.token, off + 8, this.len - 8, nrOfEntries)\r\n        };\r\n    }\r\n}\r\nexport const TimeToSampleToken = {\r\n    len: 8,\r\n    get(buf, off) {\r\n        return {\r\n            count: Token.INT32_BE.get(buf, off + 0),\r\n            duration: Token.INT32_BE.get(buf, off + 4)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Time-to-sample('stts') atom.\r\n * Store duration information for a mediaâ€™s samples.\r\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25696\r\n */\r\nexport class SttsAtom extends SimpleTableAtom {\r\n    constructor(len) {\r\n        super(len, TimeToSampleToken);\r\n    }\r\n}\r\nexport const SampleToChunkToken = {\r\n    len: 12,\r\n    get(buf, off) {\r\n        return {\r\n            firstChunk: Token.INT32_BE.get(buf, off),\r\n            samplesPerChunk: Token.INT32_BE.get(buf, off + 4),\r\n            sampleDescriptionId: Token.INT32_BE.get(buf, off + 8)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Sample-to-Chunk ('stsc') atom interface\r\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25706\r\n */\r\nexport class StscAtom extends SimpleTableAtom {\r\n    constructor(len) {\r\n        super(len, SampleToChunkToken);\r\n    }\r\n}\r\n/**\r\n * Sample-size ('stsz') atom\r\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25710\r\n */\r\nexport class StszAtom {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        const nrOfEntries = Token.INT32_BE.get(buf, off + 8);\r\n        return {\r\n            version: Token.INT8.get(buf, off),\r\n            flags: Token.INT24_BE.get(buf, off + 1),\r\n            sampleSize: Token.INT32_BE.get(buf, off + 4),\r\n            numberOfEntries: nrOfEntries,\r\n            entries: readTokenTable(buf, Token.INT32_BE, off + 12, this.len - 12, nrOfEntries)\r\n        };\r\n    }\r\n}\r\n/**\r\n * Chunk offset atom, 'stco'\r\n * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-25715\r\n */\r\nexport class StcoAtom extends SimpleTableAtom {\r\n    constructor(len) {\r\n        super(len, Token.INT32_BE);\r\n        this.len = len;\r\n    }\r\n}\r\n/**\r\n * Token used to decode text-track from 'mdat' atom (raw data stream)\r\n */\r\nexport class ChapterText {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        const titleLen = Token.INT16_BE.get(buf, off + 0);\r\n        const str = new Token.StringType(titleLen, 'utf-8');\r\n        return str.get(buf, off + 2);\r\n    }\r\n}\r\nfunction readTokenTable(buf, token, off, remainingLen, numberOfEntries) {\r\n    debug(`remainingLen=${remainingLen}, numberOfEntries=${numberOfEntries} * token-len=${token.len}`);\r\n    if (remainingLen === 0)\r\n        return [];\r\n    if (remainingLen !== numberOfEntries * token.len)\r\n        throw new Mp4ContentError('mismatch number-of-entries with remaining atom-length');\r\n    const entries = [];\r\n    // parse offset-table\r\n    for (let n = 0; n < numberOfEntries; ++n) {\r\n        entries.push(token.get(buf, off));\r\n        off += token.len;\r\n    }\r\n    return entries;\r\n}\r\n/**\r\n * Sample-size ('tfhd') TrackFragmentHeaderBox\r\n */\r\nexport class TrackFragmentHeaderBox {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        const flagOffset = off + 1;\r\n        const header = {\r\n            version: Token.INT8.get(buf, off),\r\n            flags: {\r\n                baseDataOffsetPresent: util.getBit(buf, flagOffset + 2, 0),\r\n                sampleDescriptionIndexPresent: util.getBit(buf, flagOffset + 2, 1),\r\n                defaultSampleDurationPresent: util.getBit(buf, flagOffset + 2, 3),\r\n                defaultSampleSizePresent: util.getBit(buf, flagOffset + 2, 4),\r\n                defaultSampleFlagsPresent: util.getBit(buf, flagOffset + 2, 5),\r\n                defaultDurationIsEmpty: util.getBit(buf, flagOffset, 0),\r\n                defaultBaseIsMoof: util.getBit(buf, flagOffset, 1)\r\n            },\r\n            trackId: Token.UINT32_BE.get(buf, 4)\r\n        };\r\n        let dynOffset = 8;\r\n        if (header.flags.baseDataOffsetPresent) {\r\n            header.baseDataOffset = Token.UINT64_BE.get(buf, dynOffset);\r\n            dynOffset += 8;\r\n        }\r\n        if (header.flags.sampleDescriptionIndexPresent) {\r\n            header.sampleDescriptionIndex = Token.UINT32_BE.get(buf, dynOffset);\r\n            dynOffset += 4;\r\n        }\r\n        if (header.flags.defaultSampleDurationPresent) {\r\n            header.defaultSampleDuration = Token.UINT32_BE.get(buf, dynOffset);\r\n            dynOffset += 4;\r\n        }\r\n        if (header.flags.defaultSampleSizePresent) {\r\n            header.defaultSampleSize = Token.UINT32_BE.get(buf, dynOffset);\r\n            dynOffset += 4;\r\n        }\r\n        if (header.flags.defaultSampleFlagsPresent) {\r\n            header.defaultSampleFlags = Token.UINT32_BE.get(buf, dynOffset);\r\n        }\r\n        return header;\r\n    }\r\n}\r\n/**\r\n * Sample-size ('trun') TrackRunBox\r\n */\r\nexport class TrackRunBox {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        const flagOffset = off + 1;\r\n        const trun = {\r\n            version: Token.INT8.get(buf, off),\r\n            flags: {\r\n                dataOffsetPresent: util.getBit(buf, flagOffset + 2, 0),\r\n                firstSampleFlagsPresent: util.getBit(buf, flagOffset + 2, 2),\r\n                sampleDurationPresent: util.getBit(buf, flagOffset + 1, 0),\r\n                sampleSizePresent: util.getBit(buf, flagOffset + 1, 1),\r\n                sampleFlagsPresent: util.getBit(buf, flagOffset + 1, 2),\r\n                sampleCompositionTimeOffsetsPresent: util.getBit(buf, flagOffset + 1, 3)\r\n            },\r\n            sampleCount: Token.UINT32_BE.get(buf, off + 4),\r\n            samples: []\r\n        };\r\n        let dynOffset = off + 8;\r\n        if (trun.flags.dataOffsetPresent) {\r\n            trun.dataOffset = Token.UINT32_BE.get(buf, dynOffset);\r\n            dynOffset += 4;\r\n        }\r\n        if (trun.flags.firstSampleFlagsPresent) {\r\n            trun.firstSampleFlags = Token.UINT32_BE.get(buf, dynOffset);\r\n            dynOffset += 4;\r\n        }\r\n        for (let n = 0; n < trun.sampleCount; ++n) {\r\n            if (dynOffset >= this.len) {\r\n                debug(\"TrackRunBox size mismatch\");\r\n                break;\r\n            }\r\n            const sample = {};\r\n            if (trun.flags.sampleDurationPresent) {\r\n                sample.sampleDuration = Token.UINT32_BE.get(buf, dynOffset);\r\n                dynOffset += 4;\r\n            }\r\n            if (trun.flags.sampleSizePresent) {\r\n                sample.sampleSize = Token.UINT32_BE.get(buf, dynOffset);\r\n                dynOffset += 4;\r\n            }\r\n            if (trun.flags.sampleFlagsPresent) {\r\n                sample.sampleFlags = Token.UINT32_BE.get(buf, dynOffset);\r\n                dynOffset += 4;\r\n            }\r\n            if (trun.flags.sampleCompositionTimeOffsetsPresent) {\r\n                sample.sampleCompositionTimeOffset = Token.UINT32_BE.get(buf, dynOffset);\r\n                dynOffset += 4;\r\n            }\r\n            trun.samples.push(sample);\r\n        }\r\n        return trun;\r\n    }\r\n}\r\n/**\r\n * HandlerBox (`hdlr`)\r\n */\r\nexport class HandlerBox {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        const _flagOffset = off + 1;\r\n        const charTypeToken = new Token.StringType(4, 'utf-8');\r\n        return {\r\n            version: Token.INT8.get(buf, off),\r\n            flags: Token.UINT24_BE.get(buf, off + 1),\r\n            componentType: charTypeToken.get(buf, off + 4),\r\n            handlerType: charTypeToken.get(buf, off + 8),\r\n            componentName: new Token.StringType(this.len - 28, 'utf-8').get(buf, off + 28),\r\n        };\r\n    }\r\n}\r\n/**\r\n * Chapter Track Reference Box (`chap`)\r\n */\r\nexport class ChapterTrackReferenceBox {\r\n    constructor(len) {\r\n        this.len = len;\r\n    }\r\n    get(buf, off) {\r\n        let dynOffset = 0;\r\n        const trackIds = [];\r\n        while (dynOffset < this.len) {\r\n            trackIds.push(Token.UINT32_BE.get(buf, off + dynOffset));\r\n            dynOffset += 4;\r\n        }\r\n        return trackIds;\r\n    }\r\n}\r\n","import initDebug from 'debug';\r\nimport * as AtomToken from './AtomToken.js';\r\nimport { Header } from './AtomToken.js';\r\nconst debug = initDebug('music-metadata:parser:MP4:Atom');\r\nexport class Atom {\r\n    static async readAtom(tokenizer, dataHandler, parent, remaining) {\r\n        // Parse atom header\r\n        const offset = tokenizer.position;\r\n        debug(`Reading next token on offset=${offset}...`); //  buf.toString('ascii')\r\n        const header = await tokenizer.readToken(AtomToken.Header);\r\n        const extended = header.length === 1n;\r\n        if (extended) {\r\n            header.length = await tokenizer.readToken(AtomToken.ExtendedSize);\r\n        }\r\n        const atomBean = new Atom(header, extended, parent);\r\n        const payloadLength = atomBean.getPayloadLength(remaining);\r\n        debug(`parse atom name=${atomBean.atomPath}, extended=${atomBean.extended}, offset=${offset}, len=${atomBean.header.length}`); //  buf.toString('ascii')\r\n        await atomBean.readData(tokenizer, dataHandler, payloadLength);\r\n        return atomBean;\r\n    }\r\n    constructor(header, extended, parent) {\r\n        this.header = header;\r\n        this.extended = extended;\r\n        this.parent = parent;\r\n        this.children = [];\r\n        this.atomPath = (this.parent ? `${this.parent.atomPath}.` : '') + this.header.name;\r\n    }\r\n    getHeaderLength() {\r\n        return this.extended ? 16 : 8;\r\n    }\r\n    getPayloadLength(remaining) {\r\n        return (this.header.length === 0n ? remaining : Number(this.header.length)) - this.getHeaderLength();\r\n    }\r\n    async readAtoms(tokenizer, dataHandler, size) {\r\n        while (size > 0) {\r\n            const atomBean = await Atom.readAtom(tokenizer, dataHandler, this, size);\r\n            this.children.push(atomBean);\r\n            size -= atomBean.header.length === 0n ? size : Number(atomBean.header.length);\r\n        }\r\n    }\r\n    async readData(tokenizer, dataHandler, remaining) {\r\n        switch (this.header.name) {\r\n            // \"Container\" atoms, contains nested atoms\r\n            case 'moov': // The Movie Atom: contains other atoms\r\n            case 'udta': // User defined atom\r\n            case 'mdia': // Media atom\r\n            case 'minf': // Media Information Atom\r\n            case 'stbl': // The Sample Table Atom\r\n            case '<id>':\r\n            case 'ilst':\r\n            case 'tref':\r\n            case 'moof':\r\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining));\r\n            case 'meta': { // Metadata Atom, ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\r\n                // meta has 4 bytes of padding, ignore\r\n                const peekHeader = await tokenizer.peekToken(Header);\r\n                const paddingLength = peekHeader.name === 'hdlr' ? 0 : 4;\r\n                await tokenizer.ignore(paddingLength);\r\n                return this.readAtoms(tokenizer, dataHandler, this.getPayloadLength(remaining) - paddingLength);\r\n            }\r\n            default:\r\n                return dataHandler(this, remaining);\r\n        }\r\n    }\r\n}\r\n","import initDebug from 'debug';\r\nimport * as Token from 'token-types';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { Genres } from '../id3v1/ID3v1Parser.js';\r\nimport { Atom } from './Atom.js';\r\nimport * as AtomToken from './AtomToken.js';\r\nimport { ChapterTrackReferenceBox, Mp4ContentError } from './AtomToken.js';\r\nimport { TrackType } from '../type.js';\r\nimport { uint8ArrayToHex } from 'uint8array-extras';\r\nimport { textDecode } from '@borewit/text-codec';\r\nconst debug = initDebug('music-metadata:parser:MP4');\r\nconst tagFormat = 'iTunes';\r\nconst encoderDict = {\r\n    raw: {\r\n        lossy: false,\r\n        format: 'raw'\r\n    },\r\n    MAC3: {\r\n        lossy: true,\r\n        format: 'MACE 3:1'\r\n    },\r\n    MAC6: {\r\n        lossy: true,\r\n        format: 'MACE 6:1'\r\n    },\r\n    ima4: {\r\n        lossy: true,\r\n        format: 'IMA 4:1'\r\n    },\r\n    ulaw: {\r\n        lossy: true,\r\n        format: 'uLaw 2:1'\r\n    },\r\n    alaw: {\r\n        lossy: true,\r\n        format: 'uLaw 2:1'\r\n    },\r\n    Qclp: {\r\n        lossy: true,\r\n        format: 'QUALCOMM PureVoice'\r\n    },\r\n    '.mp3': {\r\n        lossy: true,\r\n        format: 'MPEG-1 layer 3'\r\n    },\r\n    alac: {\r\n        lossy: false,\r\n        format: 'ALAC'\r\n    },\r\n    'ac-3': {\r\n        lossy: true,\r\n        format: 'AC-3'\r\n    },\r\n    mp4a: {\r\n        lossy: true,\r\n        format: 'MPEG-4/AAC'\r\n    },\r\n    mp4s: {\r\n        lossy: true,\r\n        format: 'MP4S'\r\n    },\r\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\r\n    c608: {\r\n        lossy: true,\r\n        format: 'CEA-608'\r\n    },\r\n    c708: {\r\n        lossy: true,\r\n        format: 'CEA-708'\r\n    }\r\n};\r\nfunction distinct(value, index, self) {\r\n    return self.indexOf(value) === index;\r\n}\r\n/*\r\n * Parser for the MP4 (MPEG-4 Part 14) container format\r\n * Standard: ISO/IEC 14496-14\r\n * supporting:\r\n * - QuickTime container\r\n * - MP4 File Format\r\n * - 3GPP file format\r\n * - 3GPP2 file format\r\n *\r\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\r\n * Support for Apple iTunes tags as found in a M4A/M4V files.\r\n * Ref:\r\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\r\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\r\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\r\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\r\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\r\n */\r\nexport class MP4Parser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.tracks = new Map();\r\n        this.hasVideoTrack = false;\r\n        this.hasAudioTrack = true;\r\n        this.atomParsers = {\r\n            /**\r\n             * Parse movie header (mvhd) atom\r\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\r\n             */\r\n            mvhd: async (len) => {\r\n                const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\r\n                this.metadata.setFormat('creationTime', mvhd.creationTime);\r\n                this.metadata.setFormat('modificationTime', mvhd.modificationTime);\r\n            },\r\n            chap: async (len) => {\r\n                const td = this.getTrackDescription();\r\n                const trackIds = [];\r\n                while (len >= Token.UINT32_BE.len) {\r\n                    trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\r\n                    len -= Token.UINT32_BE.len;\r\n                }\r\n                td.chapterList = trackIds;\r\n            },\r\n            /**\r\n             * Parse mdat atom.\r\n             * Will scan for chapters\r\n             */\r\n            mdat: async (len) => {\r\n                if (this.options.includeChapters) {\r\n                    const trackWithChapters = [...this.tracks.values()].filter(track => track.chapterList);\r\n                    if (trackWithChapters.length === 1) {\r\n                        const chapterTrackIds = trackWithChapters[0].chapterList;\r\n                        const chapterTracks = [...this.tracks.values()].filter(track => chapterTrackIds.indexOf(track.header.trackId) !== -1);\r\n                        if (chapterTracks.length === 1) {\r\n                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\r\n                        }\r\n                    }\r\n                }\r\n                await this.tokenizer.ignore(len);\r\n            },\r\n            ftyp: async (len) => {\r\n                const types = [];\r\n                while (len > 0) {\r\n                    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\r\n                    len -= AtomToken.ftyp.len;\r\n                    const value = ftype.type.replace(/\\W/g, '');\r\n                    if (value.length > 0) {\r\n                        types.push(value); // unshift for backward compatibility\r\n                    }\r\n                }\r\n                debug(`ftyp: ${types.join('/')}`);\r\n                const x = types.filter(distinct).join('/');\r\n                this.metadata.setFormat('container', x);\r\n            },\r\n            /**\r\n             * Parse sample description atom\r\n             */\r\n            stsd: async (len) => {\r\n                const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\r\n                const trackDescription = this.getTrackDescription();\r\n                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\r\n            },\r\n            /**\r\n             * Parse sample-sizes atom ('stsz')\r\n             */\r\n            stsz: async (len) => {\r\n                const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\r\n                const td = this.getTrackDescription();\r\n                td.sampleSize = stsz.sampleSize;\r\n                td.sampleSizeTable = stsz.entries;\r\n            },\r\n            date: async (len) => {\r\n                const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\r\n                await this.addTag('date', date);\r\n            }\r\n        };\r\n    }\r\n    static read_BE_Integer(array, signed) {\r\n        const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\r\n        const token = Token[integerType];\r\n        if (!token) {\r\n            throw new Mp4ContentError(`Token for integer type not found: \"${integerType}\"`);\r\n        }\r\n        return Number(token.get(array, 0));\r\n    }\r\n    async parse() {\r\n        this.hasVideoTrack = false;\r\n        this.hasAudioTrack = true;\r\n        this.tracks.clear();\r\n        let remainingFileSize = this.tokenizer.fileInfo.size || 0;\r\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\r\n            try {\r\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\r\n                if (token.name === '\\0\\0\\0\\0') {\r\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\r\n                    debug(errMsg);\r\n                    this.addWarning(errMsg);\r\n                    break;\r\n                }\r\n            }\r\n            catch (error) {\r\n                if (error instanceof Error) {\r\n                    const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\r\n                    debug(errMsg);\r\n                    this.addWarning(errMsg);\r\n                }\r\n                else\r\n                    throw error;\r\n                break;\r\n            }\r\n            const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\r\n            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\r\n        }\r\n        // Post process metadata\r\n        const formatList = [];\r\n        this.tracks.forEach(track => {\r\n            const trackFormats = [];\r\n            track.soundSampleDescription.forEach(ssd => {\r\n                const streamInfo = {};\r\n                const encoderInfo = encoderDict[ssd.dataFormat];\r\n                if (encoderInfo) {\r\n                    trackFormats.push(encoderInfo.format);\r\n                    streamInfo.codecName = encoderInfo.format;\r\n                }\r\n                else {\r\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\r\n                }\r\n                if (ssd.description) {\r\n                    const { description } = ssd;\r\n                    if (description.sampleRate > 0) {\r\n                        streamInfo.type = TrackType.audio;\r\n                        streamInfo.audio = {\r\n                            samplingFrequency: description.sampleRate,\r\n                            bitDepth: description.sampleSize,\r\n                            channels: description.numAudioChannels\r\n                        };\r\n                    }\r\n                }\r\n                this.metadata.addStreamInfo(streamInfo);\r\n            });\r\n            if (trackFormats.length >= 1) {\r\n                formatList.push(trackFormats.join('/'));\r\n            }\r\n        });\r\n        if (formatList.length > 0) {\r\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\r\n        }\r\n        const audioTracks = [...this.tracks.values()].filter(track => {\r\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\r\n        });\r\n        // Calculate duration and bitrate of audio tracks\r\n        for (const audioTrack of audioTracks) {\r\n            if (audioTrack.media.header && audioTrack.media.header.timeScale > 0) {\r\n                audioTrack.sampleRate = audioTrack.media.header.timeScale;\r\n                if (audioTrack.media.header.duration > 0) {\r\n                    debug('Using duration defined on audio track');\r\n                    audioTrack.samples = audioTrack.media.header.duration;\r\n                    audioTrack.duration = audioTrack.samples / audioTrack.sampleRate;\r\n                }\r\n                if (audioTrack.fragments.length > 0) {\r\n                    debug('Calculate duration defined in track fragments');\r\n                    let totalTimeUnits = 0;\r\n                    audioTrack.sizeInBytes = 0;\r\n                    for (const fragment of audioTrack.fragments) {\r\n                        for (const sample of fragment.trackRun.samples) {\r\n                            const dur = sample.sampleDuration ?? fragment.header.defaultSampleDuration ?? 0;\r\n                            const size = sample.sampleSize ?? fragment.header.defaultSampleSize ?? 0;\r\n                            if (dur === 0) {\r\n                                throw new Error(\"Missing sampleDuration and no defaultSampleDuration in track fragment header\");\r\n                            }\r\n                            if (size === 0) {\r\n                                throw new Error(\"Missing sampleSize and no defaultSampleSize in track fragment header\");\r\n                            }\r\n                            totalTimeUnits += dur;\r\n                            audioTrack.sizeInBytes += size;\r\n                        }\r\n                    }\r\n                    if (!audioTrack.samples) {\r\n                        audioTrack.samples = totalTimeUnits;\r\n                    }\r\n                    if (!audioTrack.duration) {\r\n                        audioTrack.duration = totalTimeUnits / audioTrack.sampleRate;\r\n                    }\r\n                }\r\n                else if (audioTrack.sampleSizeTable.length > 0) {\r\n                    audioTrack.sizeInBytes = audioTrack.sampleSizeTable.reduce((sum, n) => sum + n, 0);\r\n                }\r\n            }\r\n            const ssd = audioTrack.soundSampleDescription[0];\r\n            if (ssd.description && audioTrack.media.header) {\r\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\r\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\r\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\r\n                if (audioTrack.media.header.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\r\n                    const totalSampleSize = audioTrack.timeToSampleTable\r\n                        .map(ttstEntry => ttstEntry.count * ttstEntry.duration)\r\n                        .reduce((total, sampleSize) => total + sampleSize);\r\n                    audioTrack.duration = totalSampleSize / ssd.description.sampleRate;\r\n                }\r\n            }\r\n            const encoderInfo = encoderDict[ssd.dataFormat];\r\n            if (encoderInfo) {\r\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\r\n            }\r\n        }\r\n        if (audioTracks.length >= 1) {\r\n            const firstAudioTrack = audioTracks[0];\r\n            if (firstAudioTrack.duration) {\r\n                this.metadata.setFormat('duration', firstAudioTrack.duration);\r\n                if (firstAudioTrack.sizeInBytes) {\r\n                    this.metadata.setFormat('bitrate', 8 * firstAudioTrack.sizeInBytes / firstAudioTrack.duration);\r\n                }\r\n            }\r\n        }\r\n        this.metadata.setFormat('hasAudio', this.hasAudioTrack);\r\n        this.metadata.setFormat('hasVideo', this.hasVideoTrack);\r\n    }\r\n    async handleAtom(atom, remaining) {\r\n        if (atom.parent) {\r\n            switch (atom.parent.header.name) {\r\n                case 'ilst':\r\n                case '<id>':\r\n                    return this.parseMetadataItemData(atom);\r\n                case 'moov':\r\n                    switch (atom.header.name) {\r\n                        case 'trak':\r\n                            return this.parseTrackBox(atom);\r\n                        case 'udta':\r\n                            return this.parseTrackBox(atom);\r\n                    }\r\n                    break;\r\n                case 'moof':\r\n                    switch (atom.header.name) {\r\n                        case 'traf':\r\n                            return this.parseTrackFragmentBox(atom);\r\n                    }\r\n            }\r\n        }\r\n        // const payloadLength = atom.getPayloadLength(remaining);\r\n        if (this.atomParsers[atom.header.name]) {\r\n            return this.atomParsers[atom.header.name](remaining);\r\n        }\r\n        debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\r\n        await this.tokenizer.ignore(remaining);\r\n    }\r\n    getTrackDescription() {\r\n        // ToDo: pick the right track, not the last track!!!!\r\n        const tracks = [...this.tracks.values()];\r\n        return tracks[tracks.length - 1];\r\n    }\r\n    async addTag(id, value) {\r\n        await this.metadata.addTag(tagFormat, id, value);\r\n    }\r\n    addWarning(message) {\r\n        debug(`Warning: ${message}`);\r\n        this.metadata.addWarning(message);\r\n    }\r\n    /**\r\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\r\n     * @param metaAtom\r\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\r\n     */\r\n    parseMetadataItemData(metaAtom) {\r\n        let tagKey = metaAtom.header.name;\r\n        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\r\n            const payLoadLength = child.getPayloadLength(remaining);\r\n            switch (child.header.name) {\r\n                case 'data': // value atom\r\n                    return this.parseValueAtom(tagKey, child);\r\n                case 'name': // name atom (optional)\r\n                case 'mean':\r\n                case 'rate': {\r\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\r\n                    tagKey += `:${name.name}`;\r\n                    break;\r\n                }\r\n                default: {\r\n                    const uint8Array = await this.tokenizer.readToken(new Token.Uint8ArrayType(payLoadLength));\r\n                    this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${textDecode(uint8Array, 'ascii')}`);\r\n                }\r\n            }\r\n        }, metaAtom.getPayloadLength(0));\r\n    }\r\n    async parseValueAtom(tagKey, metaAtom) {\r\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\r\n        if (dataAtom.type.set !== 0) {\r\n            throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);\r\n        }\r\n        // Use well-known-type table\r\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\r\n        switch (dataAtom.type.type) {\r\n            case 0: // reserved: Reserved for use where no type needs to be indicated\r\n                switch (tagKey) {\r\n                    case 'trkn':\r\n                    case 'disk': {\r\n                        const num = Token.UINT8.get(dataAtom.value, 3);\r\n                        const of = Token.UINT8.get(dataAtom.value, 5);\r\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\r\n                        await this.addTag(tagKey, `${num}/${of}`);\r\n                        break;\r\n                    }\r\n                    case 'gnre': {\r\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\r\n                        const genreStr = Genres[genreInt - 1];\r\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\r\n                        await this.addTag(tagKey, genreStr);\r\n                        break;\r\n                    }\r\n                    case 'rate': {\r\n                        const rate = textDecode(dataAtom.value, 'ascii');\r\n                        await this.addTag(tagKey, rate);\r\n                        break;\r\n                    }\r\n                    default:\r\n                        debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);\r\n                }\r\n                break;\r\n            case 1: // UTF-8: Without any count or NULL terminator\r\n            case 18: // Unknown: Found in m4b in combination with a 'Â©gen' tag\r\n                await this.addTag(tagKey, textDecode(dataAtom.value));\r\n                break;\r\n            case 13: // JPEG\r\n                if (this.options.skipCovers)\r\n                    break;\r\n                await this.addTag(tagKey, {\r\n                    format: 'image/jpeg',\r\n                    data: Uint8Array.from(dataAtom.value)\r\n                });\r\n                break;\r\n            case 14: // PNG\r\n                if (this.options.skipCovers)\r\n                    break;\r\n                await this.addTag(tagKey, {\r\n                    format: 'image/png',\r\n                    data: Uint8Array.from(dataAtom.value)\r\n                });\r\n                break;\r\n            case 21: // BE Signed Integer\r\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\r\n                break;\r\n            case 22: // BE Unsigned Integer\r\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\r\n                break;\r\n            case 65: // An 8-bit signed integer\r\n                await this.addTag(tagKey, Token.UINT8.get(dataAtom.value, 0));\r\n                break;\r\n            case 66: // A big-endian 16-bit signed integer\r\n                await this.addTag(tagKey, Token.UINT16_BE.get(dataAtom.value, 0));\r\n                break;\r\n            case 67: // A big-endian 32-bit signed integer\r\n                await this.addTag(tagKey, Token.UINT32_BE.get(dataAtom.value, 0));\r\n                break;\r\n            default:\r\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\r\n        }\r\n    }\r\n    async parseTrackBox(trakBox) {\r\n        // @ts-expect-error\r\n        const track = {\r\n            media: {},\r\n            fragments: []\r\n        };\r\n        await trakBox.readAtoms(this.tokenizer, async (child, remaining) => {\r\n            const payLoadLength = child.getPayloadLength(remaining);\r\n            switch (child.header.name) {\r\n                case 'chap': {\r\n                    const chap = await this.tokenizer.readToken(new ChapterTrackReferenceBox(remaining));\r\n                    track.chapterList = chap;\r\n                    break;\r\n                }\r\n                case 'tkhd': // TrackHeaderBox\r\n                    track.header = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(payLoadLength));\r\n                    break;\r\n                case 'hdlr': // TrackHeaderBox\r\n                    track.handler = await this.tokenizer.readToken(new AtomToken.HandlerBox(payLoadLength));\r\n                    track.isAudio = () => track.handler.handlerType === 'audi' || track.handler.handlerType === 'soun';\r\n                    track.isVideo = () => track.handler.handlerType === 'vide';\r\n                    if (track.isAudio()) {\r\n                        this.hasAudioTrack = true;\r\n                    }\r\n                    else if (track.isVideo()) {\r\n                        this.hasVideoTrack = true;\r\n                    }\r\n                    break;\r\n                case 'mdhd': { // Parse media header (mdhd) box\r\n                    const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(payLoadLength));\r\n                    track.media.header = mdhd_data;\r\n                    break;\r\n                }\r\n                case 'stco': {\r\n                    const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(payLoadLength));\r\n                    track.chunkOffsetTable = stco.entries; // remember chunk offsets\r\n                    break;\r\n                }\r\n                case 'stsc': { // sample-to-Chunk box\r\n                    const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(payLoadLength));\r\n                    track.sampleToChunkTable = stsc.entries;\r\n                    break;\r\n                }\r\n                case 'stsd': { // sample description box\r\n                    const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(payLoadLength));\r\n                    track.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\r\n                    break;\r\n                }\r\n                case 'stts': { // time-to-sample table\r\n                    const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(payLoadLength));\r\n                    track.timeToSampleTable = stts.entries;\r\n                    break;\r\n                }\r\n                case 'stsz': {\r\n                    const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(payLoadLength));\r\n                    track.sampleSize = stsz.sampleSize;\r\n                    track.sampleSizeTable = stsz.entries;\r\n                    break;\r\n                }\r\n                case 'dinf':\r\n                case 'vmhd':\r\n                case 'smhd':\r\n                    debug(`Ignoring: ${child.header.name}`);\r\n                    await this.tokenizer.ignore(payLoadLength);\r\n                    break;\r\n                default: {\r\n                    debug(`Unexpected track box: ${child.header.name}`);\r\n                    await this.tokenizer.ignore(payLoadLength);\r\n                }\r\n            }\r\n        }, trakBox.getPayloadLength(0));\r\n        // Register track\r\n        this.tracks.set(track.header.trackId, track);\r\n    }\r\n    parseTrackFragmentBox(trafBox) {\r\n        let tfhd;\r\n        return trafBox.readAtoms(this.tokenizer, async (child, remaining) => {\r\n            const payLoadLength = child.getPayloadLength(remaining);\r\n            switch (child.header.name) {\r\n                case 'tfhd': { // TrackFragmentHeaderBox\r\n                    const fragmentHeaderBox = new AtomToken.TrackFragmentHeaderBox(child.getPayloadLength(remaining));\r\n                    tfhd = await this.tokenizer.readToken(fragmentHeaderBox);\r\n                    break;\r\n                }\r\n                case 'tfdt': // TrackFragmentBaseMediaDecodeTimeBo\r\n                    await this.tokenizer.ignore(payLoadLength);\r\n                    break;\r\n                case 'trun': { // TrackRunBox\r\n                    const trackRunBox = new AtomToken.TrackRunBox(payLoadLength);\r\n                    const trun = await this.tokenizer.readToken(trackRunBox);\r\n                    if (tfhd) {\r\n                        const track = this.tracks.get(tfhd.trackId);\r\n                        track?.fragments.push({ header: tfhd, trackRun: trun });\r\n                    }\r\n                    break;\r\n                }\r\n                default: {\r\n                    debug(`Unexpected box: ${child.header.name}`);\r\n                    await this.tokenizer.ignore(payLoadLength);\r\n                }\r\n            }\r\n        }, trafBox.getPayloadLength(0));\r\n    }\r\n    /**\r\n     * @param sampleDescription\r\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\r\n     */\r\n    parseSoundSampleDescription(sampleDescription) {\r\n        const ssd = {\r\n            dataFormat: sampleDescription.dataFormat,\r\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\r\n        };\r\n        let offset = 0;\r\n        if (sampleDescription.description) {\r\n            const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\r\n            offset += AtomToken.SoundSampleDescriptionVersion.len;\r\n            if (version.version === 0 || version.version === 1) {\r\n                // Sound Sample Description (Version 0)\r\n                ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\r\n            }\r\n            else {\r\n                debug(`Warning: sound-sample-description ${version} not implemented`);\r\n            }\r\n        }\r\n        return ssd;\r\n    }\r\n    async parseChapterTrack(chapterTrack, track, len) {\r\n        if (!chapterTrack.sampleSize) {\r\n            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)\r\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\r\n        }\r\n        const chapters = [];\r\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\r\n            const start = chapterTrack.timeToSampleTable\r\n                .slice(0, i)\r\n                .reduce((acc, cur) => acc + cur.duration, 0);\r\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\r\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\r\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\r\n            len -= nextChunkLen + sampleSize;\r\n            if (len < 0)\r\n                throw new Mp4ContentError('Chapter chunk exceeding token length');\r\n            await this.tokenizer.ignore(nextChunkLen);\r\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\r\n            debug(`Chapter ${i + 1}: ${title}`);\r\n            const chapter = {\r\n                title,\r\n                timeScale: chapterTrack.media.header ? chapterTrack.media.header.timeScale : 0,\r\n                start,\r\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\r\n            };\r\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${track.header.duration}`); // ToDo, use media duration if required!!!\r\n            chapters.push(chapter);\r\n        }\r\n        this.metadata.setFormat('chapters', chapters);\r\n        await this.tokenizer.ignore(len);\r\n    }\r\n    findSampleOffset(track, chapterOffset) {\r\n        let chunkIndex = 0;\r\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\r\n            ++chunkIndex;\r\n        }\r\n        return this.getChunkDuration(chunkIndex + 1, track);\r\n    }\r\n    getChunkDuration(chunkId, track) {\r\n        let ttsi = 0;\r\n        let ttsc = track.timeToSampleTable[ttsi].count;\r\n        let ttsd = track.timeToSampleTable[ttsi].duration;\r\n        let curChunkId = 1;\r\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\r\n        let totalDuration = 0;\r\n        while (curChunkId < chunkId) {\r\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\r\n            totalDuration += nrOfSamples * ttsd;\r\n            ttsc -= nrOfSamples;\r\n            samplesPerChunk -= nrOfSamples;\r\n            if (samplesPerChunk === 0) {\r\n                ++curChunkId;\r\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\r\n            }\r\n            else {\r\n                ++ttsi;\r\n                ttsc = track.timeToSampleTable[ttsi].count;\r\n                ttsd = track.timeToSampleTable[ttsi].duration;\r\n            }\r\n        }\r\n        return totalDuration;\r\n    }\r\n    getSamplesPerChunk(chunkId, stcTable) {\r\n        for (let i = 0; i < stcTable.length - 1; ++i) {\r\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\r\n                return stcTable[i].samplesPerChunk;\r\n            }\r\n        }\r\n        return stcTable[stcTable.length - 1].samplesPerChunk;\r\n    }\r\n}\r\n"],"names":["debug","initDebug","Mp4ContentError","makeUnexpectedFileContentError","Header","len","get","buf","off","length","Token","BigInt","name","put","hdr","Number","FourCcToken","ExtendedSize","ftyp","type","FixedLengthAtom","constructor","expLen","atomId","this","SecondsSinceMacEpoch","secondsSinceUnixEpoch","Date","MdhdAtom","super","version","flags","creationTime","modificationTime","timeScale","duration","language","quality","MvhdAtom","preferredRate","preferredVolume","previewTime","previewDuration","posterTime","selectionTime","selectionDuration","currentTime","nextTrackID","DataAtom","set","locale","value","NameAtom","TrackHeaderAtom","trackId","layer","alternateGroup","volume","stsdHeader","numberOfEntries","SampleDescriptionTable","descrLen","dataFormat","dataReferenceIndex","description","undefined","StsdAtom","header","table","n","size","push","SoundSampleDescriptionVersion","revision","vendor","SoundSampleDescriptionV0","numAudioChannels","sampleSize","compressionId","packetSize","sampleRate","SimpleTableAtom","token","nrOfEntries","entries","readTokenTable","TimeToSampleToken","count","SttsAtom","SampleToChunkToken","firstChunk","samplesPerChunk","sampleDescriptionId","StscAtom","StszAtom","StcoAtom","ChapterText","titleLen","str","remainingLen","TrackFragmentHeaderBox","flagOffset","baseDataOffsetPresent","util","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","defaultDurationIsEmpty","defaultBaseIsMoof","dynOffset","baseDataOffset","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","TrackRunBox","trun","dataOffsetPresent","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetsPresent","sampleCount","samples","dataOffset","firstSampleFlags","sample","sampleDuration","sampleFlags","sampleCompositionTimeOffset","HandlerBox","charTypeToken","componentType","handlerType","componentName","ChapterTrackReferenceBox","trackIds","Atom","readAtom","tokenizer","dataHandler","parent","remaining","offset","position","readToken","AtomToken","extended","atomBean","payloadLength","getPayloadLength","atomPath","readData","children","getHeaderLength","readAtoms","peekHeader","peekToken","paddingLength","ignore","tagFormat","encoderDict","raw","lossy","format","MAC3","MAC6","ima4","ulaw","alaw","Qclp","alac","mp4a","mp4s","c608","c708","distinct","index","self","indexOf","MP4Parser","BasicParser","arguments","tracks","Map","hasVideoTrack","hasAudioTrack","atomParsers","mvhd","async","metadata","setFormat","chap","td","getTrackDescription","readNumber","chapterList","mdat","options","includeChapters","trackWithChapters","values","filter","track","chapterTrackIds","chapterTracks","parseChapterTrack","types","ftype","replace","join","x","stsd","trackDescription","soundSampleDescription","map","dfEntry","parseSoundSampleDescription","stsz","sampleSizeTable","date","addTag","read_BE_Integer","array","signed","integerType","parse","clear","remainingFileSize","fileInfo","errMsg","addWarning","error","Error","message","rootAtom","atom","handleAtom","formatList","forEach","trackFormats","ssd","streamInfo","encoderInfo","codecName","TrackType","audio","samplingFrequency","bitDepth","channels","addStreamInfo","audioTracks","audioTrack","media","fragments","totalTimeUnits","sizeInBytes","fragment","trackRun","dur","reduce","sum","timeToSampleTable","totalSampleSize","ttstEntry","total","firstAudioTrack","parseMetadataItemData","parseTrackBox","parseTrackFragmentBox","id","metaAtom","tagKey","child","payLoadLength","parseValueAtom","uint8Array","uint8ArrayToHex","textDecode","dataAtom","num","of","genreInt","genreStr","Genres","rate","skipCovers","data","Uint8Array","from","trakBox","handler","isAudio","isVideo","mdhd_data","stco","chunkOffsetTable","stsc","sampleToChunkTable","stts","trafBox","tfhd","fragmentHeaderBox","trackRunBox","sampleDescription","chapterTrack","chapters","i","start","slice","acc","cur","chunkOffset","nextChunkLen","title","chapter","sampleOffset","findSampleOffset","chapterOffset","chunkIndex","getChunkDuration","chunkId","ttsi","ttsc","ttsd","curChunkId","getSamplesPerChunk","totalDuration","nrOfSamples","Math","min","stcTable"],"ignoreList":[],"sourceRoot":""}