{"version":3,"file":"js/54.47a25c1f.js","mappings":"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","sources":["webpack://osi/./node_modules/music-metadata/lib/riff/RiffChunk.js","webpack://osi/./node_modules/music-metadata/lib/wav/WaveChunk.js","webpack://osi/./node_modules/music-metadata/lib/wav/BwfChunk.js","webpack://osi/./node_modules/music-metadata/lib/wav/WaveParser.js"],"sourcesContent":["import * as Token from 'token-types';\r\n/**\r\n * Common RIFF chunk header\r\n */\r\nexport const Header = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        return {\r\n            // Group-ID\r\n            chunkID: new Token.StringType(4, 'latin1').get(buf, off),\r\n            // Size\r\n            chunkSize: Token.UINT32_LE.get(buf, off + 4)\r\n        };\r\n    }\r\n};\r\n/**\r\n * Token to parse RIFF-INFO tag value\r\n */\r\nexport class ListInfoTagValue {\r\n    constructor(tagHeader) {\r\n        this.tagHeader = tagHeader;\r\n        this.len = tagHeader.chunkSize;\r\n        this.len += this.len & 1; // if it is an odd length, round up to even\r\n    }\r\n    get(buf, off) {\r\n        return new Token.StringType(this.tagHeader.chunkSize, 'ascii').get(buf, off);\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nexport class WaveContentError extends makeUnexpectedFileContentError('Wave') {\r\n}\r\n/**\r\n * Ref: https://msdn.microsoft.com/en-us/library/windows/desktop/dd317599(v=vs.85).aspx\r\n */\r\nexport const WaveFormat = {\r\n    PCM: 0x0001,\r\n    // MPEG-4 and AAC Audio Types\r\n    ADPCM: 0x0002,\r\n    IEEE_FLOAT: 0x0003,\r\n    MPEG_ADTS_AAC: 0x1600,\r\n    MPEG_LOAS: 0x1602,\r\n    RAW_AAC1: 0x00FF,\r\n    // Dolby Audio Types\r\n    DOLBY_AC3_SPDIF: 0x0092,\r\n    DVM: 0x2000,\r\n    RAW_SPORT: 0x0240,\r\n    ESST_AC3: 0x0241,\r\n    DRM: 0x0009,\r\n    DTS2: 0x2001,\r\n    MPEG: 0x0050\r\n};\r\nexport const WaveFormatNameMap = {\r\n    [WaveFormat.PCM]: 'PCM',\r\n    [WaveFormat.ADPCM]: 'ADPCM',\r\n    [WaveFormat.IEEE_FLOAT]: 'IEEE_FLOAT',\r\n    [WaveFormat.MPEG_ADTS_AAC]: 'MPEG_ADTS_AAC',\r\n    [WaveFormat.MPEG_LOAS]: 'MPEG_LOAS',\r\n    [WaveFormat.RAW_AAC1]: 'RAW_AAC1',\r\n    [WaveFormat.DOLBY_AC3_SPDIF]: 'DOLBY_AC3_SPDIF',\r\n    [WaveFormat.DVM]: 'DVM',\r\n    [WaveFormat.RAW_SPORT]: 'RAW_SPORT',\r\n    [WaveFormat.ESST_AC3]: 'ESST_AC3',\r\n    [WaveFormat.DRM]: 'DRM',\r\n    [WaveFormat.DTS2]: 'DTS2',\r\n    [WaveFormat.MPEG]: 'MPEG'\r\n};\r\n/**\r\n * format chunk; chunk-id is \"fmt \"\r\n * http://soundfile.sapp.org/doc/WaveFormat/\r\n */\r\nexport class Format {\r\n    constructor(header) {\r\n        if (header.chunkSize < 16)\r\n            throw new WaveContentError('Invalid chunk size');\r\n        this.len = header.chunkSize;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            wFormatTag: Token.UINT16_LE.get(buf, off),\r\n            nChannels: Token.UINT16_LE.get(buf, off + 2),\r\n            nSamplesPerSec: Token.UINT32_LE.get(buf, off + 4),\r\n            nAvgBytesPerSec: Token.UINT32_LE.get(buf, off + 8),\r\n            nBlockAlign: Token.UINT16_LE.get(buf, off + 12),\r\n            wBitsPerSample: Token.UINT16_LE.get(buf, off + 14)\r\n        };\r\n    }\r\n}\r\n/**\r\n * Fact chunk; chunk-id is \"fact\"\r\n * http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html\r\n * http://www.recordingblogs.com/wiki/fact-chunk-of-a-wave-file\r\n */\r\nexport class FactChunk {\r\n    constructor(header) {\r\n        if (header.chunkSize < 4) {\r\n            throw new WaveContentError('Invalid fact chunk size.');\r\n        }\r\n        this.len = header.chunkSize;\r\n    }\r\n    get(buf, off) {\r\n        return {\r\n            dwSampleLength: Token.UINT32_LE.get(buf, off)\r\n        };\r\n    }\r\n}\r\n","import * as Token from 'token-types';\r\nimport { stripNulls } from '../common/Util.js';\r\n/**\r\n * Broadcast Audio Extension Chunk\r\n * Ref: https://tech.ebu.ch/docs/tech/tech3285.pdf\r\n */\r\nexport const BroadcastAudioExtensionChunk = {\r\n    len: 420,\r\n    get: (uint8array, off) => {\r\n        return {\r\n            description: stripNulls(new Token.StringType(256, 'ascii').get(uint8array, off)).trim(),\r\n            originator: stripNulls(new Token.StringType(32, 'ascii').get(uint8array, off + 256)).trim(),\r\n            originatorReference: stripNulls(new Token.StringType(32, 'ascii').get(uint8array, off + 288)).trim(),\r\n            originationDate: stripNulls(new Token.StringType(10, 'ascii').get(uint8array, off + 320)).trim(),\r\n            originationTime: stripNulls(new Token.StringType(8, 'ascii').get(uint8array, off + 330)).trim(),\r\n            timeReferenceLow: Token.UINT32_LE.get(uint8array, off + 338),\r\n            timeReferenceHigh: Token.UINT32_LE.get(uint8array, off + 342),\r\n            version: Token.UINT16_LE.get(uint8array, off + 346),\r\n            umid: new Token.Uint8ArrayType(64).get(uint8array, off + 348),\r\n            loudnessValue: Token.UINT16_LE.get(uint8array, off + 412),\r\n            maxTruePeakLevel: Token.UINT16_LE.get(uint8array, off + 414),\r\n            maxMomentaryLoudness: Token.UINT16_LE.get(uint8array, off + 416),\r\n            maxShortTermLoudness: Token.UINT16_LE.get(uint8array, off + 418)\r\n        };\r\n    }\r\n};\r\n","import * as strtok3 from 'strtok3';\r\nimport * as Token from 'token-types';\r\nimport initDebug from 'debug';\r\nimport * as riff from '../riff/RiffChunk.js';\r\nimport * as WaveChunk from './WaveChunk.js';\r\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\r\nimport * as util from '../common/Util.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { BroadcastAudioExtensionChunk } from './BwfChunk.js';\r\nimport { WaveContentError } from './WaveChunk.js';\r\nconst debug = initDebug('music-metadata:parser:RIFF');\r\n/**\r\n * Resource Interchange File Format (RIFF) Parser\r\n *\r\n * WAVE PCM soundfile format\r\n *\r\n * Ref:\r\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\r\n * - http://soundfile.sapp.org/doc/WaveFormat\r\n *\r\n * ToDo: Split WAVE part from RIFF parser\r\n */\r\nexport class WaveParser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.blockAlign = 0;\r\n    }\r\n    async parse() {\r\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\r\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\r\n        if (riffHeader.chunkID !== 'RIFF')\r\n            return; // Not RIFF format\r\n        this.metadata.setAudioOnly();\r\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\r\n            if (!(err instanceof strtok3.EndOfStreamError)) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    async parseRiffChunk(chunkSize) {\r\n        const type = await this.tokenizer.readToken(FourCcToken);\r\n        this.metadata.setFormat('container', type);\r\n        switch (type) {\r\n            case 'WAVE':\r\n                return this.readWaveChunk(chunkSize - FourCcToken.len);\r\n            default:\r\n                throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);\r\n        }\r\n    }\r\n    async readWaveChunk(remaining) {\r\n        while (remaining >= riff.Header.len) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            remaining -= riff.Header.len + header.chunkSize;\r\n            if (header.chunkSize > remaining) {\r\n                this.metadata.addWarning('Data chunk size exceeds file size');\r\n            }\r\n            this.header = header;\r\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\r\n            switch (header.chunkID) {\r\n                case 'LIST':\r\n                    await this.parseListTag(header);\r\n                    break;\r\n                case 'fact': // extended Format chunk,\r\n                    this.metadata.setFormat('lossless', false);\r\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\r\n                    break;\r\n                case 'fmt ': { // The Util Chunk, non-PCM Formats\r\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\r\n                    let subFormat = WaveChunk.WaveFormatNameMap[fmt.wFormatTag];\r\n                    if (!subFormat) {\r\n                        debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);\r\n                        subFormat = `non-PCM (${fmt.wFormatTag})`;\r\n                    }\r\n                    this.metadata.setFormat('codec', subFormat);\r\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\r\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\r\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\r\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\r\n                    this.blockAlign = fmt.nBlockAlign;\r\n                    break;\r\n                }\r\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\r\n                case 'ID3 ': { // The way Mp3Tags stores ID3 meta-data\r\n                    const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\r\n                    const rst = strtok3.fromBuffer(id3_data);\r\n                    await new ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                    break;\r\n                }\r\n                case 'data': { // PCM-data\r\n                    if (this.metadata.format.lossless !== false) {\r\n                        this.metadata.setFormat('lossless', true);\r\n                    }\r\n                    let chunkSize = header.chunkSize;\r\n                    if (this.tokenizer.fileInfo.size) {\r\n                        const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\r\n                        if (calcRemaining < chunkSize) {\r\n                            this.metadata.addWarning('data chunk length exceeding file length');\r\n                            chunkSize = calcRemaining;\r\n                        }\r\n                    }\r\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign);\r\n                    if (numberOfSamples) {\r\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                        if (this.metadata.format.sampleRate) {\r\n                            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\r\n                        }\r\n                    }\r\n                    if (this.metadata.format.codec === 'ADPCM') { // ADPCM is 4 bits lossy encoding resulting in 352kbps\r\n                        this.metadata.setFormat('bitrate', 352000);\r\n                    }\r\n                    else if (this.metadata.format.sampleRate) {\r\n                        this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\r\n                    }\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n                    break;\r\n                }\r\n                case 'bext': { // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\r\n                    const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);\r\n                    Object.keys(bext).forEach(key => {\r\n                        this.metadata.addTag('exif', `bext.${key}`, bext[key]);\r\n                    });\r\n                    const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;\r\n                    await this.tokenizer.ignore(bextRemaining);\r\n                    break;\r\n                }\r\n                case '\\x00\\x00\\x00\\x00': // padding ??\r\n                    debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\r\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n                    break;\r\n                default:\r\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\r\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n            }\r\n            if (this.header.chunkSize % 2 === 1) {\r\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\r\n                await this.tokenizer.ignore(1);\r\n            }\r\n        }\r\n    }\r\n    async parseListTag(listHeader) {\r\n        const listType = await this.tokenizer.readToken(new Token.StringType(4, 'latin1'));\r\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\r\n        switch (listType) {\r\n            case 'INFO':\r\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\r\n            default:\r\n                this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);\r\n                debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);\r\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\r\n        }\r\n    }\r\n    async parseRiffInfoTags(chunkSize) {\r\n        while (chunkSize >= 8) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            const valueToken = new riff.ListInfoTagValue(header);\r\n            const value = await this.tokenizer.readToken(valueToken);\r\n            this.addTag(header.chunkID, util.stripNulls(value));\r\n            chunkSize -= (8 + valueToken.len);\r\n        }\r\n        if (chunkSize !== 0) {\r\n            throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);\r\n        }\r\n    }\r\n    addTag(id, value) {\r\n        this.metadata.addTag('exif', id, value);\r\n    }\r\n}\r\n"],"names":["Header","len","get","buf","off","chunkID","Token","chunkSize","ListInfoTagValue","constructor","tagHeader","this","WaveContentError","makeUnexpectedFileContentError","WaveFormat","PCM","ADPCM","IEEE_FLOAT","MPEG_ADTS_AAC","MPEG_LOAS","RAW_AAC1","DOLBY_AC3_SPDIF","DVM","RAW_SPORT","ESST_AC3","DRM","DTS2","MPEG","WaveFormatNameMap","Format","header","wFormatTag","nChannels","nSamplesPerSec","nAvgBytesPerSec","nBlockAlign","wBitsPerSample","FactChunk","dwSampleLength","BroadcastAudioExtensionChunk","uint8array","description","stripNulls","trim","originator","originatorReference","originationDate","originationTime","timeReferenceLow","timeReferenceHigh","version","umid","loudnessValue","maxTruePeakLevel","maxMomentaryLoudness","maxShortTermLoudness","debug","initDebug","WaveParser","BasicParser","super","arguments","blockAlign","parse","riffHeader","tokenizer","readToken","riff","position","metadata","setAudioOnly","parseRiffChunk","catch","err","strtok3","type","FourCcToken","setFormat","readWaveChunk","remaining","addWarning","parseListTag","fact","WaveChunk","fmt","subFormat","id3_data","rst","ID3v2Parser","options","format","lossless","fileInfo","size","calcRemaining","numberOfSamples","undefined","sampleRate","codec","ignore","bext","Object","keys","forEach","key","addTag","bextRemaining","listHeader","listType","parseRiffInfoTags","then","valueToken","value","util","id"],"ignoreList":[],"sourceRoot":""}