{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport { Float32_BE, Float64_BE, StringType, UINT8 } from 'token-types';\nimport initDebug from 'debug';\nimport { EndOfStreamError } from 'strtok3';\nimport { DataType } from './types.js';\nimport * as Token from 'token-types';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:ebml');\nexport class EbmlContentError extends makeUnexpectedFileContentError('EBML') {}\nexport const ParseAction = {\n  ReadNext: 0,\n  // Continue reading the next elements\n  IgnoreElement: 2,\n  // Ignore (do not read) this element\n  SkipSiblings: 3,\n  // Skip all remaining elements at the same level\n  TerminateParsing: 4,\n  // Terminate the parsing process\n  SkipElement: 5 // Consider the element has read, assume position is at the next element\n};\n/**\r\n * Extensible Binary Meta Language (EBML) iterator\r\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\r\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\r\n *\r\n * WEBM VP8 AUDIO FILE\r\n */\nexport class EbmlIterator {\n  /**\r\n   * @param {ITokenizer} tokenizer Input\r\n   * @param tokenizer\r\n   */\n  constructor(tokenizer) {\n    this.padding = 0;\n    this.parserMap = new Map();\n    this.ebmlMaxIDLength = 4;\n    this.ebmlMaxSizeLength = 8;\n    this.tokenizer = tokenizer;\n    this.parserMap.set(DataType.uint, e => this.readUint(e));\n    this.parserMap.set(DataType.string, e => this.readString(e));\n    this.parserMap.set(DataType.binary, e => this.readBuffer(e));\n    this.parserMap.set(DataType.uid, async e => this.readBuffer(e));\n    this.parserMap.set(DataType.bool, e => this.readFlag(e));\n    this.parserMap.set(DataType.float, e => this.readFloat(e));\n  }\n  async iterate(dtdElement, posDone, listener) {\n    return this.parseContainer(linkParents(dtdElement), posDone, listener);\n  }\n  async parseContainer(dtdElement, posDone, listener) {\n    const tree = {};\n    while (this.tokenizer.position < posDone) {\n      let element;\n      const elementPosition = this.tokenizer.position;\n      try {\n        element = await this.readElement();\n      } catch (error) {\n        if (error instanceof EndOfStreamError) {\n          break;\n        }\n        throw error;\n      }\n      const child = dtdElement.container[element.id];\n      if (child) {\n        const action = listener.startNext(child);\n        switch (action) {\n          case ParseAction.ReadNext:\n            {\n              if (element.id === 0x1F43B675) {\n                // Hack to ignore remaining segment, when cluster element received\n                // await this.tokenizer.ignore(posDone - this.tokenizer.position);\n                // break;\n              }\n              debug(`Read element: name=${getElementPath(child)}{id=0x${element.id.toString(16)}, container=${!!child.container}} at position=${elementPosition}`);\n              if (child.container) {\n                const res = await this.parseContainer(child, element.len >= 0 ? this.tokenizer.position + element.len : -1, listener);\n                if (child.multiple) {\n                  if (!tree[child.name]) {\n                    tree[child.name] = [];\n                  }\n                  tree[child.name].push(res);\n                } else {\n                  tree[child.name] = res;\n                }\n                await listener.elementValue(child, res, elementPosition);\n              } else {\n                const parser = this.parserMap.get(child.value);\n                if (typeof parser === 'function') {\n                  const value = await parser(element);\n                  tree[child.name] = value;\n                  await listener.elementValue(child, value, elementPosition);\n                }\n              }\n            }\n            break;\n          case ParseAction.SkipElement:\n            debug(`Go to next element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);\n            break;\n          case ParseAction.IgnoreElement:\n            debug(`Ignore element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);\n            await this.tokenizer.ignore(element.len);\n            break;\n          case ParseAction.SkipSiblings:\n            debug(`Ignore remaining container, at: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);\n            await this.tokenizer.ignore(posDone - this.tokenizer.position);\n            break;\n          case ParseAction.TerminateParsing:\n            debug(`Terminate parsing at element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);\n            return tree;\n        }\n      } else {\n        switch (element.id) {\n          case 0xec:\n            // void\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n            break;\n          default:\n            debug(`parseEbml: parent=${getElementPath(dtdElement)}, unknown child: id=${element.id.toString(16)} at position=${elementPosition}`);\n            this.padding += element.len;\n            await this.tokenizer.ignore(element.len);\n        }\n      }\n    }\n    return tree;\n  }\n  async readVintData(maxLength) {\n    const msb = await this.tokenizer.peekNumber(UINT8);\n    let mask = 0x80;\n    let oc = 1;\n    // Calculate VINT_WIDTH\n    while ((msb & mask) === 0) {\n      if (oc > maxLength) {\n        throw new EbmlContentError('VINT value exceeding maximum size');\n      }\n      ++oc;\n      mask >>= 1;\n    }\n    const id = new Uint8Array(oc);\n    await this.tokenizer.readBuffer(id);\n    return id;\n  }\n  async readElement() {\n    const id = await this.readVintData(this.ebmlMaxIDLength);\n    const lenField = await this.readVintData(this.ebmlMaxSizeLength);\n    lenField[0] ^= 0x80 >> lenField.length - 1;\n    return {\n      id: readUIntBE(id, id.length),\n      len: readUIntBE(lenField, lenField.length)\n    };\n  }\n  async readFloat(e) {\n    switch (e.len) {\n      case 0:\n        return 0.0;\n      case 4:\n        return this.tokenizer.readNumber(Float32_BE);\n      case 8:\n        return this.tokenizer.readNumber(Float64_BE);\n      case 10:\n        return this.tokenizer.readNumber(Float64_BE);\n      default:\n        throw new EbmlContentError(`Invalid IEEE-754 float length: ${e.len}`);\n    }\n  }\n  async readFlag(e) {\n    return (await this.readUint(e)) === 1;\n  }\n  async readUint(e) {\n    const buf = await this.readBuffer(e);\n    return readUIntBE(buf, e.len);\n  }\n  async readString(e) {\n    const rawString = await this.tokenizer.readToken(new StringType(e.len, 'utf-8'));\n    return rawString.replace(/\\x00.*$/g, '');\n  }\n  async readBuffer(e) {\n    const buf = new Uint8Array(e.len);\n    await this.tokenizer.readBuffer(buf);\n    return buf;\n  }\n}\nfunction readUIntBE(buf, len) {\n  return Number(readUIntBeAsBigInt(buf, len));\n}\n/**\r\n * Reeds an unsigned integer from a big endian buffer of length `len`\r\n * @param buf Buffer to decode from\r\n * @param len Number of bytes\r\n * @private\r\n */\nfunction readUIntBeAsBigInt(buf, len) {\n  const normalizedNumber = new Uint8Array(8);\n  const cleanNumber = buf.subarray(0, len);\n  try {\n    normalizedNumber.set(cleanNumber, 8 - len);\n    return Token.UINT64_BE.get(normalizedNumber, 0);\n  } catch (_error) {\n    return BigInt(-1);\n  }\n}\nfunction linkParents(element) {\n  if (element.container) {\n    Object.keys(element.container).map(id => {\n      const child = element.container[id];\n      child.id = Number.parseInt(id);\n      return child;\n    }).forEach(child => {\n      child.parent = element;\n      linkParents(child);\n    });\n  }\n  return element;\n}\nexport function getElementPath(element) {\n  let path = '';\n  if (element.parent && element.parent.name !== 'dtd') {\n    path += `${getElementPath(element.parent)}/`;\n  }\n  return path + element.name;\n}","map":{"version":3,"names":["Float32_BE","Float64_BE","StringType","UINT8","initDebug","EndOfStreamError","DataType","Token","makeUnexpectedFileContentError","debug","EbmlContentError","ParseAction","ReadNext","IgnoreElement","SkipSiblings","TerminateParsing","SkipElement","EbmlIterator","constructor","tokenizer","padding","parserMap","Map","ebmlMaxIDLength","ebmlMaxSizeLength","set","uint","e","readUint","string","readString","binary","readBuffer","uid","bool","readFlag","float","readFloat","iterate","dtdElement","posDone","listener","parseContainer","linkParents","tree","position","element","elementPosition","readElement","error","child","container","id","action","startNext","getElementPath","toString","res","len","multiple","name","push","elementValue","parser","get","value","ignore","readVintData","maxLength","msb","peekNumber","mask","oc","Uint8Array","lenField","length","readUIntBE","readNumber","buf","rawString","readToken","replace","Number","readUIntBeAsBigInt","normalizedNumber","cleanNumber","subarray","UINT64_BE","_error","BigInt","Object","keys","map","parseInt","forEach","parent","path"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/ebml/EbmlIterator.js"],"sourcesContent":["import { Float32_BE, Float64_BE, StringType, UINT8 } from 'token-types';\r\nimport initDebug from 'debug';\r\nimport { EndOfStreamError } from 'strtok3';\r\nimport { DataType } from './types.js';\r\nimport * as Token from 'token-types';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:ebml');\r\nexport class EbmlContentError extends makeUnexpectedFileContentError('EBML') {\r\n}\r\nexport const ParseAction = {\r\n    ReadNext: 0, // Continue reading the next elements\r\n    IgnoreElement: 2, // Ignore (do not read) this element\r\n    SkipSiblings: 3, // Skip all remaining elements at the same level\r\n    TerminateParsing: 4, // Terminate the parsing process\r\n    SkipElement: 5 // Consider the element has read, assume position is at the next element\r\n};\r\n/**\r\n * Extensible Binary Meta Language (EBML) iterator\r\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\r\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\r\n *\r\n * WEBM VP8 AUDIO FILE\r\n */\r\nexport class EbmlIterator {\r\n    /**\r\n     * @param {ITokenizer} tokenizer Input\r\n     * @param tokenizer\r\n     */\r\n    constructor(tokenizer) {\r\n        this.padding = 0;\r\n        this.parserMap = new Map();\r\n        this.ebmlMaxIDLength = 4;\r\n        this.ebmlMaxSizeLength = 8;\r\n        this.tokenizer = tokenizer;\r\n        this.parserMap.set(DataType.uint, e => this.readUint(e));\r\n        this.parserMap.set(DataType.string, e => this.readString(e));\r\n        this.parserMap.set(DataType.binary, e => this.readBuffer(e));\r\n        this.parserMap.set(DataType.uid, async (e) => this.readBuffer(e));\r\n        this.parserMap.set(DataType.bool, e => this.readFlag(e));\r\n        this.parserMap.set(DataType.float, e => this.readFloat(e));\r\n    }\r\n    async iterate(dtdElement, posDone, listener) {\r\n        return this.parseContainer(linkParents(dtdElement), posDone, listener);\r\n    }\r\n    async parseContainer(dtdElement, posDone, listener) {\r\n        const tree = {};\r\n        while (this.tokenizer.position < posDone) {\r\n            let element;\r\n            const elementPosition = this.tokenizer.position;\r\n            try {\r\n                element = await this.readElement();\r\n            }\r\n            catch (error) {\r\n                if (error instanceof EndOfStreamError) {\r\n                    break;\r\n                }\r\n                throw error;\r\n            }\r\n            const child = dtdElement.container[element.id];\r\n            if (child) {\r\n                const action = listener.startNext(child);\r\n                switch (action) {\r\n                    case ParseAction.ReadNext:\r\n                        {\r\n                            if (element.id === 0x1F43B675) {\r\n                                // Hack to ignore remaining segment, when cluster element received\r\n                                // await this.tokenizer.ignore(posDone - this.tokenizer.position);\r\n                                // break;\r\n                            }\r\n                            debug(`Read element: name=${getElementPath(child)}{id=0x${element.id.toString(16)}, container=${!!child.container}} at position=${elementPosition}`);\r\n                            if (child.container) {\r\n                                const res = await this.parseContainer(child, element.len >= 0 ? this.tokenizer.position + element.len : -1, listener);\r\n                                if (child.multiple) {\r\n                                    if (!tree[child.name]) {\r\n                                        tree[child.name] = [];\r\n                                    }\r\n                                    tree[child.name].push(res);\r\n                                }\r\n                                else {\r\n                                    tree[child.name] = res;\r\n                                }\r\n                                await listener.elementValue(child, res, elementPosition);\r\n                            }\r\n                            else {\r\n                                const parser = this.parserMap.get(child.value);\r\n                                if (typeof parser === 'function') {\r\n                                    const value = await parser(element);\r\n                                    tree[child.name] = value;\r\n                                    await listener.elementValue(child, value, elementPosition);\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    case ParseAction.SkipElement:\r\n                        debug(`Go to next element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);\r\n                        break;\r\n                    case ParseAction.IgnoreElement:\r\n                        debug(`Ignore element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);\r\n                        await this.tokenizer.ignore(element.len);\r\n                        break;\r\n                    case ParseAction.SkipSiblings:\r\n                        debug(`Ignore remaining container, at: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);\r\n                        await this.tokenizer.ignore(posDone - this.tokenizer.position);\r\n                        break;\r\n                    case ParseAction.TerminateParsing:\r\n                        debug(`Terminate parsing at element: name=${getElementPath(child)}, element.id=0x${element.id}, container=${!!child.container} at position=${elementPosition}`);\r\n                        return tree;\r\n                }\r\n            }\r\n            else {\r\n                switch (element.id) {\r\n                    case 0xec: // void\r\n                        this.padding += element.len;\r\n                        await this.tokenizer.ignore(element.len);\r\n                        break;\r\n                    default:\r\n                        debug(`parseEbml: parent=${getElementPath(dtdElement)}, unknown child: id=${element.id.toString(16)} at position=${elementPosition}`);\r\n                        this.padding += element.len;\r\n                        await this.tokenizer.ignore(element.len);\r\n                }\r\n            }\r\n        }\r\n        return tree;\r\n    }\r\n    async readVintData(maxLength) {\r\n        const msb = await this.tokenizer.peekNumber(UINT8);\r\n        let mask = 0x80;\r\n        let oc = 1;\r\n        // Calculate VINT_WIDTH\r\n        while ((msb & mask) === 0) {\r\n            if (oc > maxLength) {\r\n                throw new EbmlContentError('VINT value exceeding maximum size');\r\n            }\r\n            ++oc;\r\n            mask >>= 1;\r\n        }\r\n        const id = new Uint8Array(oc);\r\n        await this.tokenizer.readBuffer(id);\r\n        return id;\r\n    }\r\n    async readElement() {\r\n        const id = await this.readVintData(this.ebmlMaxIDLength);\r\n        const lenField = await this.readVintData(this.ebmlMaxSizeLength);\r\n        lenField[0] ^= 0x80 >> (lenField.length - 1);\r\n        return {\r\n            id: readUIntBE(id, id.length),\r\n            len: readUIntBE(lenField, lenField.length)\r\n        };\r\n    }\r\n    async readFloat(e) {\r\n        switch (e.len) {\r\n            case 0:\r\n                return 0.0;\r\n            case 4:\r\n                return this.tokenizer.readNumber(Float32_BE);\r\n            case 8:\r\n                return this.tokenizer.readNumber(Float64_BE);\r\n            case 10:\r\n                return this.tokenizer.readNumber(Float64_BE);\r\n            default:\r\n                throw new EbmlContentError(`Invalid IEEE-754 float length: ${e.len}`);\r\n        }\r\n    }\r\n    async readFlag(e) {\r\n        return (await this.readUint(e)) === 1;\r\n    }\r\n    async readUint(e) {\r\n        const buf = await this.readBuffer(e);\r\n        return readUIntBE(buf, e.len);\r\n    }\r\n    async readString(e) {\r\n        const rawString = await this.tokenizer.readToken(new StringType(e.len, 'utf-8'));\r\n        return rawString.replace(/\\x00.*$/g, '');\r\n    }\r\n    async readBuffer(e) {\r\n        const buf = new Uint8Array(e.len);\r\n        await this.tokenizer.readBuffer(buf);\r\n        return buf;\r\n    }\r\n}\r\nfunction readUIntBE(buf, len) {\r\n    return Number(readUIntBeAsBigInt(buf, len));\r\n}\r\n/**\r\n * Reeds an unsigned integer from a big endian buffer of length `len`\r\n * @param buf Buffer to decode from\r\n * @param len Number of bytes\r\n * @private\r\n */\r\nfunction readUIntBeAsBigInt(buf, len) {\r\n    const normalizedNumber = new Uint8Array(8);\r\n    const cleanNumber = buf.subarray(0, len);\r\n    try {\r\n        normalizedNumber.set(cleanNumber, 8 - len);\r\n        return Token.UINT64_BE.get(normalizedNumber, 0);\r\n    }\r\n    catch (_error) {\r\n        return BigInt(-1);\r\n    }\r\n}\r\nfunction linkParents(element) {\r\n    if (element.container) {\r\n        Object.keys(element.container)\r\n            .map(id => {\r\n            const child = element.container[id];\r\n            child.id = Number.parseInt(id);\r\n            return child;\r\n        }).forEach(child => {\r\n            child.parent = element;\r\n            linkParents(child);\r\n        });\r\n    }\r\n    return element;\r\n}\r\nexport function getElementPath(element) {\r\n    let path = '';\r\n    if (element.parent && element.parent.name !== 'dtd') {\r\n        path += `${getElementPath(element.parent)}/`;\r\n    }\r\n    return path + element.name;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}