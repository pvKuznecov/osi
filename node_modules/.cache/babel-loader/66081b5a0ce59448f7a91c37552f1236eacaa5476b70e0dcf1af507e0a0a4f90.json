{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport * as Token from 'token-types';\nimport debugInit from 'debug';\nimport { VorbisDecoder } from './VorbisDecoder.js';\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {}\n/**\r\n * Vorbis 1 Parser.\r\n * Used by OggStream\r\n */\nexport class VorbisStream {\n  constructor(metadata, options) {\n    this.pageSegments = [];\n    this.durationOnLastPage = true;\n    this.metadata = metadata;\n    this.options = options;\n  }\n  /**\r\n   * Vorbis 1 parser\r\n   * @param header Ogg Page Header\r\n   * @param pageData Page data\r\n   */\n  async parsePage(header, pageData) {\n    this.lastPageHeader = header;\n    if (header.headerType.firstPage) {\n      this.parseFirstPage(header, pageData);\n    } else {\n      if (header.headerType.continued) {\n        if (this.pageSegments.length === 0) {\n          throw new VorbisContentError('Cannot continue on previous page');\n        }\n        this.pageSegments.push(pageData);\n      }\n      if (header.headerType.lastPage || !header.headerType.continued) {\n        // Flush page segments\n        if (this.pageSegments.length > 0) {\n          const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\n          await this.parseFullPage(fullPage);\n        }\n        // Reset page segments\n        this.pageSegments = header.headerType.lastPage ? [] : [pageData];\n      }\n    }\n  }\n  static mergeUint8Arrays(arrays) {\n    const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\n    const merged = new Uint8Array(totalSize);\n    arrays.forEach((array, i, _arrays) => {\n      const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\n      merged.set(array, offset);\n    });\n    return merged;\n  }\n  async flush() {\n    await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\n  }\n  async parseUserComment(pageData, offset) {\n    const decoder = new VorbisDecoder(pageData, offset);\n    const tag = decoder.parseUserComment();\n    await this.addTag(tag.key, tag.value);\n    return tag.len;\n  }\n  async addTag(id, value) {\n    if (id === 'METADATA_BLOCK_PICTURE' && typeof value === 'string') {\n      if (this.options.skipCovers) {\n        debug(\"Ignore picture\");\n        return;\n      }\n      value = VorbisPictureToken.fromBase64(value);\n      debug(`Push picture: id=${id}, format=${value.format}`);\n    } else {\n      debug(`Push tag: id=${id}, value=${value}`);\n    }\n    await this.metadata.addTag('vorbis', id, value);\n  }\n  calculateDuration(enfOfStream) {\n    if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\n      // Calculate duration\n      this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\n      this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\n    }\n  }\n  /**\r\n   * Parse first Ogg/Vorbis page\r\n   * @param _header\r\n   * @param pageData\r\n   */\n  parseFirstPage(_header, pageData) {\n    this.metadata.setFormat('codec', 'Vorbis I');\n    this.metadata.setFormat('hasAudio', true);\n    debug('Parse first page');\n    // Parse  Vorbis common header\n    const commonHeader = CommonHeader.get(pageData, 0);\n    if (commonHeader.vorbis !== 'vorbis') throw new VorbisContentError('Metadata does not look like Vorbis');\n    if (commonHeader.packetType === 1) {\n      const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\n      this.metadata.setFormat('sampleRate', idHeader.sampleRate);\n      this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\n      this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\n      debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\n    } else throw new VorbisContentError('First Ogg page should be type 1: the identification header');\n  }\n  async parseFullPage(pageData) {\n    // New page\n    const commonHeader = CommonHeader.get(pageData, 0);\n    debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\n    switch (commonHeader.packetType) {\n      case 3:\n        //  type 3: comment header\n        return this.parseUserCommentList(pageData, CommonHeader.len);\n      case 1: // type 1: the identification header\n      case 5:\n        // type 5: setup header type\n        break;\n      // ignore\n    }\n  }\n  /**\r\n   * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\r\n   */\n  async parseUserCommentList(pageData, offset) {\n    const strLen = Token.UINT32_LE.get(pageData, offset);\n    offset += 4;\n    // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\n    offset += strLen;\n    let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\n    offset += 4;\n    while (userCommentListLength-- > 0) {\n      offset += await this.parseUserComment(pageData, offset);\n    }\n  }\n}","map":{"version":3,"names":["Token","debugInit","VorbisDecoder","CommonHeader","IdentificationHeader","VorbisPictureToken","makeUnexpectedFileContentError","debug","VorbisContentError","VorbisStream","constructor","metadata","options","pageSegments","durationOnLastPage","parsePage","header","pageData","lastPageHeader","headerType","firstPage","parseFirstPage","continued","length","push","lastPage","fullPage","mergeUint8Arrays","parseFullPage","arrays","totalSize","reduce","acc","e","merged","Uint8Array","forEach","array","i","_arrays","offset","slice","set","flush","parseUserComment","decoder","tag","addTag","key","value","len","id","skipCovers","fromBase64","format","calculateDuration","enfOfStream","sampleRate","absoluteGranulePosition","setFormat","_header","commonHeader","get","vorbis","packetType","idHeader","bitrateNominal","channelMode","byteLength","parseUserCommentList","strLen","UINT32_LE","userCommentListLength"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/ogg/vorbis/VorbisStream.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport debugInit from 'debug';\r\nimport { VorbisDecoder } from './VorbisDecoder.js';\r\nimport { CommonHeader, IdentificationHeader, VorbisPictureToken } from './Vorbis.js';\r\nimport { makeUnexpectedFileContentError } from '../../ParseError.js';\r\nconst debug = debugInit('music-metadata:parser:ogg:vorbis1');\r\nexport class VorbisContentError extends makeUnexpectedFileContentError('Vorbis') {\r\n}\r\n/**\r\n * Vorbis 1 Parser.\r\n * Used by OggStream\r\n */\r\nexport class VorbisStream {\r\n    constructor(metadata, options) {\r\n        this.pageSegments = [];\r\n        this.durationOnLastPage = true;\r\n        this.metadata = metadata;\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Vorbis 1 parser\r\n     * @param header Ogg Page Header\r\n     * @param pageData Page data\r\n     */\r\n    async parsePage(header, pageData) {\r\n        this.lastPageHeader = header;\r\n        if (header.headerType.firstPage) {\r\n            this.parseFirstPage(header, pageData);\r\n        }\r\n        else {\r\n            if (header.headerType.continued) {\r\n                if (this.pageSegments.length === 0) {\r\n                    throw new VorbisContentError('Cannot continue on previous page');\r\n                }\r\n                this.pageSegments.push(pageData);\r\n            }\r\n            if (header.headerType.lastPage || !header.headerType.continued) {\r\n                // Flush page segments\r\n                if (this.pageSegments.length > 0) {\r\n                    const fullPage = VorbisStream.mergeUint8Arrays(this.pageSegments);\r\n                    await this.parseFullPage(fullPage);\r\n                }\r\n                // Reset page segments\r\n                this.pageSegments = header.headerType.lastPage ? [] : [pageData];\r\n            }\r\n        }\r\n    }\r\n    static mergeUint8Arrays(arrays) {\r\n        const totalSize = arrays.reduce((acc, e) => acc + e.length, 0);\r\n        const merged = new Uint8Array(totalSize);\r\n        arrays.forEach((array, i, _arrays) => {\r\n            const offset = _arrays.slice(0, i).reduce((acc, e) => acc + e.length, 0);\r\n            merged.set(array, offset);\r\n        });\r\n        return merged;\r\n    }\r\n    async flush() {\r\n        await this.parseFullPage(VorbisStream.mergeUint8Arrays(this.pageSegments));\r\n    }\r\n    async parseUserComment(pageData, offset) {\r\n        const decoder = new VorbisDecoder(pageData, offset);\r\n        const tag = decoder.parseUserComment();\r\n        await this.addTag(tag.key, tag.value);\r\n        return tag.len;\r\n    }\r\n    async addTag(id, value) {\r\n        if (id === 'METADATA_BLOCK_PICTURE' && (typeof value === 'string')) {\r\n            if (this.options.skipCovers) {\r\n                debug(\"Ignore picture\");\r\n                return;\r\n            }\r\n            value = VorbisPictureToken.fromBase64(value);\r\n            debug(`Push picture: id=${id}, format=${value.format}`);\r\n        }\r\n        else {\r\n            debug(`Push tag: id=${id}, value=${value}`);\r\n        }\r\n        await this.metadata.addTag('vorbis', id, value);\r\n    }\r\n    calculateDuration(enfOfStream) {\r\n        if (this.lastPageHeader && this.metadata.format.sampleRate && this.lastPageHeader.absoluteGranulePosition >= 0) {\r\n            // Calculate duration\r\n            this.metadata.setFormat('numberOfSamples', this.lastPageHeader.absoluteGranulePosition);\r\n            this.metadata.setFormat('duration', this.lastPageHeader.absoluteGranulePosition / this.metadata.format.sampleRate);\r\n        }\r\n    }\r\n    /**\r\n     * Parse first Ogg/Vorbis page\r\n     * @param _header\r\n     * @param pageData\r\n     */\r\n    parseFirstPage(_header, pageData) {\r\n        this.metadata.setFormat('codec', 'Vorbis I');\r\n        this.metadata.setFormat('hasAudio', true);\r\n        debug('Parse first page');\r\n        // Parse  Vorbis common header\r\n        const commonHeader = CommonHeader.get(pageData, 0);\r\n        if (commonHeader.vorbis !== 'vorbis')\r\n            throw new VorbisContentError('Metadata does not look like Vorbis');\r\n        if (commonHeader.packetType === 1) {\r\n            const idHeader = IdentificationHeader.get(pageData, CommonHeader.len);\r\n            this.metadata.setFormat('sampleRate', idHeader.sampleRate);\r\n            this.metadata.setFormat('bitrate', idHeader.bitrateNominal);\r\n            this.metadata.setFormat('numberOfChannels', idHeader.channelMode);\r\n            debug('sample-rate=%s[hz], bitrate=%s[b/s], channel-mode=%s', idHeader.sampleRate, idHeader.bitrateNominal, idHeader.channelMode);\r\n        }\r\n        else\r\n            throw new VorbisContentError('First Ogg page should be type 1: the identification header');\r\n    }\r\n    async parseFullPage(pageData) {\r\n        // New page\r\n        const commonHeader = CommonHeader.get(pageData, 0);\r\n        debug('Parse full page: type=%s, byteLength=%s', commonHeader.packetType, pageData.byteLength);\r\n        switch (commonHeader.packetType) {\r\n            case 3: //  type 3: comment header\r\n                return this.parseUserCommentList(pageData, CommonHeader.len);\r\n            case 1: // type 1: the identification header\r\n            case 5: // type 5: setup header type\r\n                break; // ignore\r\n        }\r\n    }\r\n    /**\r\n     * Ref: https://xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-840005.2\r\n     */\r\n    async parseUserCommentList(pageData, offset) {\r\n        const strLen = Token.UINT32_LE.get(pageData, offset);\r\n        offset += 4;\r\n        // const vendorString = new Token.StringType(strLen, 'utf-8').get(pageData, offset);\r\n        offset += strLen;\r\n        let userCommentListLength = Token.UINT32_LE.get(pageData, offset);\r\n        offset += 4;\r\n        while (userCommentListLength-- > 0) {\r\n            offset += (await this.parseUserComment(pageData, offset));\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}