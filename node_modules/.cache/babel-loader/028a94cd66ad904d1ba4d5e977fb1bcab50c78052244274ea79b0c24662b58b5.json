{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport * as Token from 'token-types';\nimport { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { VorbisStream } from './vorbis/VorbisStream.js';\nimport { OpusStream } from './opus/OpusStream.js';\nimport { SpeexStream } from './speex/SpeexStream.js';\nimport { TheoraStream } from './theora/TheoraStream.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport { PageHeader, SegmentTable } from './OggToken.js';\nimport { FlacStream } from './flac/FlacStream.js';\nexport class OggContentError extends makeUnexpectedFileContentError('Ogg') {}\nconst debug = initDebug('music-metadata:parser:ogg');\nclass OggStream {\n  constructor(metadata, streamSerial, options) {\n    this.pageNumber = 0;\n    this.closed = false;\n    this.metadata = metadata;\n    this.streamSerial = streamSerial;\n    this.options = options;\n  }\n  async parsePage(tokenizer, header) {\n    this.pageNumber = header.pageSequenceNo;\n    debug('serial=%s page#=%s, Ogg.id=%s', header.streamSerialNumber, header.pageSequenceNo, header.capturePattern);\n    const segmentTable = await tokenizer.readToken(new SegmentTable(header));\n    debug('totalPageSize=%s', segmentTable.totalPageSize);\n    const pageData = await tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\n    debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\n    if (header.headerType.firstPage) {\n      this.metadata.setFormat('container', 'Ogg');\n      const idData = pageData.subarray(0, 7); // Copy this portion\n      const asciiId = Array.from(idData).filter(b => b >= 32 && b <= 126) // Keep only printable ASCII\n      .map(b => String.fromCharCode(b)).join('');\n      switch (asciiId) {\n        case 'vorbis':\n          // Ogg/Vorbis\n          debug(`Set Ogg stream serial ${header.streamSerialNumber}, codec=Vorbis`);\n          this.pageConsumer = new VorbisStream(this.metadata, this.options);\n          break;\n        case 'OpusHea':\n          // Ogg/Opus\n          debug('Set page consumer to Ogg/Opus');\n          this.pageConsumer = new OpusStream(this.metadata, this.options, tokenizer);\n          break;\n        case 'Speex  ':\n          // Ogg/Speex\n          debug('Set page consumer to Ogg/Speex');\n          this.pageConsumer = new SpeexStream(this.metadata, this.options, tokenizer);\n          break;\n        case 'fishead':\n        case 'theora':\n          // Ogg/Theora\n          debug('Set page consumer to Ogg/Theora');\n          this.pageConsumer = new TheoraStream(this.metadata, this.options, tokenizer);\n          break;\n        case 'FLAC':\n          // Ogg/Theora\n          debug('Set page consumer to Vorbis');\n          this.pageConsumer = new FlacStream(this.metadata, this.options, tokenizer);\n          break;\n        default:\n          throw new OggContentError(`Ogg codec not recognized (id=${asciiId}`);\n      }\n    }\n    if (header.headerType.lastPage) {\n      this.closed = true;\n    }\n    if (this.pageConsumer) {\n      await this.pageConsumer.parsePage(header, pageData);\n    } else throw new Error('pageConsumer should be initialized');\n  }\n}\n/**\n * Parser for Ogg logical bitstream framing\n */\nexport class OggParser extends BasicParser {\n  constructor() {\n    super(...arguments);\n    this.streams = new Map();\n  }\n  /**\n   * Parse page\n   * @returns {Promise<void>}\n   */\n  async parse() {\n    this.streams = new Map();\n    let enfOfStream = false;\n    let header;\n    try {\n      do {\n        header = await this.tokenizer.readToken(PageHeader);\n        if (header.capturePattern !== 'OggS') throw new OggContentError('Invalid Ogg capture pattern');\n        let stream = this.streams.get(header.streamSerialNumber);\n        if (!stream) {\n          stream = new OggStream(this.metadata, header.streamSerialNumber, this.options);\n          this.streams.set(header.streamSerialNumber, stream);\n        }\n        await stream.parsePage(this.tokenizer, header);\n        if (stream.pageNumber > 12 && !(this.options.duration && [...this.streams.values()].find(stream => stream.pageConsumer?.durationOnLastPage))) {\n          debug(\"Stop processing Ogg stream\");\n          break;\n        }\n      } while (![...this.streams.values()].every(item => item.closed));\n    } catch (err) {\n      if (err instanceof EndOfStreamError) {\n        debug(\"Reached end-of-stream\");\n        enfOfStream = true;\n      } else if (err instanceof OggContentError) {\n        this.metadata.addWarning(`Corrupt Ogg content at ${this.tokenizer.position}`);\n      } else throw err;\n    }\n    for (const stream of this.streams.values()) {\n      if (!stream.closed) {\n        this.metadata.addWarning(`End-of-stream reached before reaching last page in Ogg stream serial=${stream.streamSerial}`);\n        await stream.pageConsumer?.flush();\n      }\n      stream.pageConsumer?.calculateDuration(enfOfStream);\n    }\n  }\n}","map":{"version":3,"names":["Token","EndOfStreamError","initDebug","BasicParser","VorbisStream","OpusStream","SpeexStream","TheoraStream","makeUnexpectedFileContentError","PageHeader","SegmentTable","FlacStream","OggContentError","debug","OggStream","constructor","metadata","streamSerial","options","pageNumber","closed","parsePage","tokenizer","header","pageSequenceNo","streamSerialNumber","capturePattern","segmentTable","readToken","totalPageSize","pageData","Uint8ArrayType","headerType","firstPage","lastPage","continued","setFormat","idData","subarray","asciiId","Array","from","filter","b","map","String","fromCharCode","join","pageConsumer","Error","OggParser","arguments","streams","Map","parse","enfOfStream","stream","get","set","duration","values","find","durationOnLastPage","every","item","err","addWarning","position","flush","calculateDuration"],"sources":["/home/kup/my_projects/vue/osi/node_modules/music-metadata/lib/ogg/OggParser.js"],"sourcesContent":["import * as Token from 'token-types';\nimport { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { VorbisStream } from './vorbis/VorbisStream.js';\nimport { OpusStream } from './opus/OpusStream.js';\nimport { SpeexStream } from './speex/SpeexStream.js';\nimport { TheoraStream } from './theora/TheoraStream.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport { PageHeader, SegmentTable } from './OggToken.js';\nimport { FlacStream } from './flac/FlacStream.js';\nexport class OggContentError extends makeUnexpectedFileContentError('Ogg') {\n}\nconst debug = initDebug('music-metadata:parser:ogg');\nclass OggStream {\n    constructor(metadata, streamSerial, options) {\n        this.pageNumber = 0;\n        this.closed = false;\n        this.metadata = metadata;\n        this.streamSerial = streamSerial;\n        this.options = options;\n    }\n    async parsePage(tokenizer, header) {\n        this.pageNumber = header.pageSequenceNo;\n        debug('serial=%s page#=%s, Ogg.id=%s', header.streamSerialNumber, header.pageSequenceNo, header.capturePattern);\n        const segmentTable = await tokenizer.readToken(new SegmentTable(header));\n        debug('totalPageSize=%s', segmentTable.totalPageSize);\n        const pageData = await tokenizer.readToken(new Token.Uint8ArrayType(segmentTable.totalPageSize));\n        debug('firstPage=%s, lastPage=%s, continued=%s', header.headerType.firstPage, header.headerType.lastPage, header.headerType.continued);\n        if (header.headerType.firstPage) {\n            this.metadata.setFormat('container', 'Ogg');\n            const idData = pageData.subarray(0, 7); // Copy this portion\n            const asciiId = Array.from(idData)\n                .filter(b => b >= 32 && b <= 126) // Keep only printable ASCII\n                .map(b => String.fromCharCode(b))\n                .join('');\n            switch (asciiId) {\n                case 'vorbis': // Ogg/Vorbis\n                    debug(`Set Ogg stream serial ${header.streamSerialNumber}, codec=Vorbis`);\n                    this.pageConsumer = new VorbisStream(this.metadata, this.options);\n                    break;\n                case 'OpusHea': // Ogg/Opus\n                    debug('Set page consumer to Ogg/Opus');\n                    this.pageConsumer = new OpusStream(this.metadata, this.options, tokenizer);\n                    break;\n                case 'Speex  ': // Ogg/Speex\n                    debug('Set page consumer to Ogg/Speex');\n                    this.pageConsumer = new SpeexStream(this.metadata, this.options, tokenizer);\n                    break;\n                case 'fishead':\n                case 'theora': // Ogg/Theora\n                    debug('Set page consumer to Ogg/Theora');\n                    this.pageConsumer = new TheoraStream(this.metadata, this.options, tokenizer);\n                    break;\n                case 'FLAC': // Ogg/Theora\n                    debug('Set page consumer to Vorbis');\n                    this.pageConsumer = new FlacStream(this.metadata, this.options, tokenizer);\n                    break;\n                default:\n                    throw new OggContentError(`Ogg codec not recognized (id=${asciiId}`);\n            }\n        }\n        if (header.headerType.lastPage) {\n            this.closed = true;\n        }\n        if (this.pageConsumer) {\n            await this.pageConsumer.parsePage(header, pageData);\n        }\n        else\n            throw new Error('pageConsumer should be initialized');\n    }\n}\n/**\n * Parser for Ogg logical bitstream framing\n */\nexport class OggParser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.streams = new Map();\n    }\n    /**\n     * Parse page\n     * @returns {Promise<void>}\n     */\n    async parse() {\n        this.streams = new Map();\n        let enfOfStream = false;\n        let header;\n        try {\n            do {\n                header = await this.tokenizer.readToken(PageHeader);\n                if (header.capturePattern !== 'OggS')\n                    throw new OggContentError('Invalid Ogg capture pattern');\n                let stream = this.streams.get(header.streamSerialNumber);\n                if (!stream) {\n                    stream = new OggStream(this.metadata, header.streamSerialNumber, this.options);\n                    this.streams.set(header.streamSerialNumber, stream);\n                }\n                await stream.parsePage(this.tokenizer, header);\n                if (stream.pageNumber > 12 && !(this.options.duration && [...this.streams.values()].find(stream => stream.pageConsumer?.durationOnLastPage))) {\n                    debug(\"Stop processing Ogg stream\");\n                    break;\n                }\n            } while (![...this.streams.values()].every(item => item.closed));\n        }\n        catch (err) {\n            if (err instanceof EndOfStreamError) {\n                debug(\"Reached end-of-stream\");\n                enfOfStream = true;\n            }\n            else if (err instanceof OggContentError) {\n                this.metadata.addWarning(`Corrupt Ogg content at ${this.tokenizer.position}`);\n            }\n            else\n                throw err;\n        }\n        for (const stream of this.streams.values()) {\n            if (!stream.closed) {\n                this.metadata.addWarning(`End-of-stream reached before reaching last page in Ogg stream serial=${stream.streamSerial}`);\n                await stream.pageConsumer?.flush();\n            }\n            stream.pageConsumer?.calculateDuration(enfOfStream);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}