{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport { StringType, UINT32_LE } from 'token-types';\nimport initDebug from 'debug';\nimport { DataDescriptor, EndOfCentralDirectoryRecordToken, FileHeader, LocalFileHeaderToken, Signature } from \"./ZipToken.js\";\nfunction signatureToArray(signature) {\n  const signatureBytes = new Uint8Array(UINT32_LE.len);\n  UINT32_LE.put(signatureBytes, 0, signature);\n  return signatureBytes;\n}\nconst debug = initDebug('tokenizer:inflate');\nconst syncBufferSize = 256 * 1024;\nconst ddSignatureArray = signatureToArray(Signature.DataDescriptor);\nconst eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);\nexport class ZipHandler {\n  constructor(tokenizer) {\n    this.tokenizer = tokenizer;\n    this.syncBuffer = new Uint8Array(syncBufferSize);\n  }\n  async isZip() {\n    return (await this.peekSignature()) === Signature.LocalFileHeader;\n  }\n  peekSignature() {\n    return this.tokenizer.peekToken(UINT32_LE);\n  }\n  async findEndOfCentralDirectoryLocator() {\n    const randomReadTokenizer = this.tokenizer;\n    const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);\n    const buffer = this.syncBuffer.subarray(0, chunkLength);\n    await this.tokenizer.readBuffer(buffer, {\n      position: randomReadTokenizer.fileInfo.size - chunkLength\n    });\n    // Search the buffer from end to beginning for EOCD signature\n    // const signature = 0x06054b50;\n    for (let i = buffer.length - 4; i >= 0; i--) {\n      // Compare 4 bytes directly without calling readUInt32LE\n      if (buffer[i] === eocdSignatureBytes[0] && buffer[i + 1] === eocdSignatureBytes[1] && buffer[i + 2] === eocdSignatureBytes[2] && buffer[i + 3] === eocdSignatureBytes[3]) {\n        return randomReadTokenizer.fileInfo.size - chunkLength + i;\n      }\n    }\n    return -1;\n  }\n  async readCentralDirectory() {\n    if (!this.tokenizer.supportsRandomAccess()) {\n      debug('Cannot reading central-directory without random-read support');\n      return;\n    }\n    debug('Reading central-directory...');\n    const pos = this.tokenizer.position;\n    const offset = await this.findEndOfCentralDirectoryLocator();\n    if (offset > 0) {\n      debug('Central-directory 32-bit signature found');\n      const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);\n      const files = [];\n      this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);\n      for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {\n        const entry = await this.tokenizer.readToken(FileHeader);\n        if (entry.signature !== Signature.CentralFileHeader) {\n          throw new Error('Expected Central-File-Header signature');\n        }\n        entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, 'utf-8'));\n        await this.tokenizer.ignore(entry.extraFieldLength);\n        await this.tokenizer.ignore(entry.fileCommentLength);\n        files.push(entry);\n        debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);\n      }\n      this.tokenizer.setPosition(pos);\n      return files;\n    }\n    this.tokenizer.setPosition(pos);\n  }\n  async unzip(fileCb) {\n    const entries = await this.readCentralDirectory();\n    if (entries) {\n      // Use Central Directory to iterate over files\n      return this.iterateOverCentralDirectory(entries, fileCb);\n    }\n    // Scan Zip files for local-file-header\n    let stop = false;\n    do {\n      const zipHeader = await this.readLocalFileHeader();\n      if (!zipHeader) break;\n      const next = fileCb(zipHeader);\n      stop = !!next.stop;\n      let fileData;\n      await this.tokenizer.ignore(zipHeader.extraFieldLength);\n      if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {\n        const chunks = [];\n        let len = syncBufferSize;\n        debug('Compressed-file-size unknown, scanning for next data-descriptor-signature....');\n        let nextHeaderIndex = -1;\n        while (nextHeaderIndex < 0 && len === syncBufferSize) {\n          len = await this.tokenizer.peekBuffer(this.syncBuffer, {\n            mayBeLess: true\n          });\n          nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);\n          const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;\n          if (next.handler) {\n            const data = new Uint8Array(size);\n            await this.tokenizer.readBuffer(data);\n            chunks.push(data);\n          } else {\n            // Move position to the next header if found, skip the whole buffer otherwise\n            await this.tokenizer.ignore(size);\n          }\n        }\n        debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);\n        if (next.handler) {\n          await this.inflate(zipHeader, mergeArrays(chunks), next.handler);\n        }\n      } else {\n        if (next.handler) {\n          debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);\n          fileData = new Uint8Array(zipHeader.compressedSize);\n          await this.tokenizer.readBuffer(fileData);\n          await this.inflate(zipHeader, fileData, next.handler);\n        } else {\n          debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);\n          await this.tokenizer.ignore(zipHeader.compressedSize);\n        }\n      }\n      debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);\n      if (zipHeader.dataDescriptor) {\n        // await this.tokenizer.ignore(DataDescriptor.len);\n        const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);\n        if (dataDescriptor.signature !== 0x08074b50) {\n          throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);\n        }\n      }\n    } while (!stop);\n  }\n  async iterateOverCentralDirectory(entries, fileCb) {\n    for (const fileHeader of entries) {\n      const next = fileCb(fileHeader);\n      if (next.handler) {\n        this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);\n        const zipHeader = await this.readLocalFileHeader();\n        if (zipHeader) {\n          await this.tokenizer.ignore(zipHeader.extraFieldLength);\n          const fileData = new Uint8Array(fileHeader.compressedSize);\n          await this.tokenizer.readBuffer(fileData);\n          await this.inflate(zipHeader, fileData, next.handler);\n        }\n      }\n      if (next.stop) break;\n    }\n  }\n  async inflate(zipHeader, fileData, cb) {\n    if (zipHeader.compressedMethod === 0) {\n      // Stored (uncompressed)\n      return cb(fileData);\n    }\n    if (zipHeader.compressedMethod !== 8) {\n      throw new Error(`Unsupported ZIP compression method: ${zipHeader.compressedMethod}`);\n    }\n    debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);\n    const uncompressedData = await ZipHandler.decompressDeflateRaw(fileData);\n    return cb(uncompressedData);\n  }\n  static async decompressDeflateRaw(data) {\n    // Wrap Uint8Array in a ReadableStream without copying\n    const input = new ReadableStream({\n      start(controller) {\n        controller.enqueue(data);\n        controller.close();\n      }\n    });\n    const ds = new DecompressionStream(\"deflate-raw\");\n    const output = input.pipeThrough(ds);\n    try {\n      // Collect decompressed bytes from the output stream\n      const response = new Response(output);\n      const buffer = await response.arrayBuffer();\n      return new Uint8Array(buffer);\n    } catch (err) {\n      // Provide ZIP-specific error context\n      const message = err instanceof Error ? `Failed to deflate ZIP entry: ${err.message}` : \"Unknown decompression error in ZIP entry\";\n      throw new TypeError(message);\n    }\n  }\n  async readLocalFileHeader() {\n    const signature = await this.tokenizer.peekToken(UINT32_LE);\n    if (signature === Signature.LocalFileHeader) {\n      const header = await this.tokenizer.readToken(LocalFileHeaderToken);\n      header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, 'utf-8'));\n      return header;\n    }\n    if (signature === Signature.CentralFileHeader) {\n      return false;\n    }\n    if (signature === 0xE011CFD0) {\n      throw new Error('Encrypted ZIP');\n    }\n    throw new Error('Unexpected signature');\n  }\n}\nfunction indexOf(buffer, portion) {\n  const bufferLength = buffer.length;\n  const portionLength = portion.length;\n  // Return -1 if the portion is longer than the buffer\n  if (portionLength > bufferLength) return -1;\n  // Search for the portion in the buffer\n  for (let i = 0; i <= bufferLength - portionLength; i++) {\n    let found = true;\n    for (let j = 0; j < portionLength; j++) {\n      if (buffer[i + j] !== portion[j]) {\n        found = false;\n        break;\n      }\n    }\n    if (found) {\n      return i; // Return the starting offset\n    }\n  }\n  return -1; // Not found\n}\nfunction mergeArrays(chunks) {\n  // Concatenate chunks into a single Uint8Array\n  const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);\n  const mergedArray = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    mergedArray.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return mergedArray;\n}","map":{"version":3,"names":["StringType","UINT32_LE","initDebug","DataDescriptor","EndOfCentralDirectoryRecordToken","FileHeader","LocalFileHeaderToken","Signature","signatureToArray","signature","signatureBytes","Uint8Array","len","put","debug","syncBufferSize","ddSignatureArray","eocdSignatureBytes","EndOfCentralDirectory","ZipHandler","constructor","tokenizer","syncBuffer","isZip","peekSignature","LocalFileHeader","peekToken","findEndOfCentralDirectoryLocator","randomReadTokenizer","chunkLength","Math","min","fileInfo","size","buffer","subarray","readBuffer","position","i","length","readCentralDirectory","supportsRandomAccess","pos","offset","eocdHeader","readToken","files","setPosition","offsetOfStartOfCd","n","nrOfEntriesOfSize","entry","CentralFileHeader","Error","filename","filenameLength","ignore","extraFieldLength","fileCommentLength","push","unzip","fileCb","entries","iterateOverCentralDirectory","stop","zipHeader","readLocalFileHeader","next","fileData","dataDescriptor","compressedSize","chunks","nextHeaderIndex","peekBuffer","mayBeLess","indexOf","handler","data","inflate","mergeArrays","fileHeader","relativeOffsetOfLocalHeader","cb","compressedMethod","uncompressedData","decompressDeflateRaw","input","ReadableStream","start","controller","enqueue","close","ds","DecompressionStream","output","pipeThrough","response","Response","arrayBuffer","err","message","TypeError","header","portion","bufferLength","portionLength","found","j","totalLength","reduce","acc","curr","mergedArray","chunk","set"],"sources":["C:/projects/My projects/Vue/osi/node_modules/@tokenizer/inflate/lib/ZipHandler.js"],"sourcesContent":["import { StringType, UINT32_LE } from 'token-types';\r\nimport initDebug from 'debug';\r\nimport { DataDescriptor, EndOfCentralDirectoryRecordToken, FileHeader, LocalFileHeaderToken, Signature } from \"./ZipToken.js\";\r\nfunction signatureToArray(signature) {\r\n    const signatureBytes = new Uint8Array(UINT32_LE.len);\r\n    UINT32_LE.put(signatureBytes, 0, signature);\r\n    return signatureBytes;\r\n}\r\nconst debug = initDebug('tokenizer:inflate');\r\nconst syncBufferSize = 256 * 1024;\r\nconst ddSignatureArray = signatureToArray(Signature.DataDescriptor);\r\nconst eocdSignatureBytes = signatureToArray(Signature.EndOfCentralDirectory);\r\nexport class ZipHandler {\r\n    constructor(tokenizer) {\r\n        this.tokenizer = tokenizer;\r\n        this.syncBuffer = new Uint8Array(syncBufferSize);\r\n    }\r\n    async isZip() {\r\n        return await this.peekSignature() === Signature.LocalFileHeader;\r\n    }\r\n    peekSignature() {\r\n        return this.tokenizer.peekToken(UINT32_LE);\r\n    }\r\n    async findEndOfCentralDirectoryLocator() {\r\n        const randomReadTokenizer = this.tokenizer;\r\n        const chunkLength = Math.min(16 * 1024, randomReadTokenizer.fileInfo.size);\r\n        const buffer = this.syncBuffer.subarray(0, chunkLength);\r\n        await this.tokenizer.readBuffer(buffer, { position: randomReadTokenizer.fileInfo.size - chunkLength });\r\n        // Search the buffer from end to beginning for EOCD signature\r\n        // const signature = 0x06054b50;\r\n        for (let i = buffer.length - 4; i >= 0; i--) {\r\n            // Compare 4 bytes directly without calling readUInt32LE\r\n            if (buffer[i] === eocdSignatureBytes[0] &&\r\n                buffer[i + 1] === eocdSignatureBytes[1] &&\r\n                buffer[i + 2] === eocdSignatureBytes[2] &&\r\n                buffer[i + 3] === eocdSignatureBytes[3]) {\r\n                return randomReadTokenizer.fileInfo.size - chunkLength + i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    async readCentralDirectory() {\r\n        if (!this.tokenizer.supportsRandomAccess()) {\r\n            debug('Cannot reading central-directory without random-read support');\r\n            return;\r\n        }\r\n        debug('Reading central-directory...');\r\n        const pos = this.tokenizer.position;\r\n        const offset = await this.findEndOfCentralDirectoryLocator();\r\n        if (offset > 0) {\r\n            debug('Central-directory 32-bit signature found');\r\n            const eocdHeader = await this.tokenizer.readToken(EndOfCentralDirectoryRecordToken, offset);\r\n            const files = [];\r\n            this.tokenizer.setPosition(eocdHeader.offsetOfStartOfCd);\r\n            for (let n = 0; n < eocdHeader.nrOfEntriesOfSize; ++n) {\r\n                const entry = await this.tokenizer.readToken(FileHeader);\r\n                if (entry.signature !== Signature.CentralFileHeader) {\r\n                    throw new Error('Expected Central-File-Header signature');\r\n                }\r\n                entry.filename = await this.tokenizer.readToken(new StringType(entry.filenameLength, 'utf-8'));\r\n                await this.tokenizer.ignore(entry.extraFieldLength);\r\n                await this.tokenizer.ignore(entry.fileCommentLength);\r\n                files.push(entry);\r\n                debug(`Add central-directory file-entry: n=${n + 1}/${files.length}: filename=${files[n].filename}`);\r\n            }\r\n            this.tokenizer.setPosition(pos);\r\n            return files;\r\n        }\r\n        this.tokenizer.setPosition(pos);\r\n    }\r\n    async unzip(fileCb) {\r\n        const entries = await this.readCentralDirectory();\r\n        if (entries) {\r\n            // Use Central Directory to iterate over files\r\n            return this.iterateOverCentralDirectory(entries, fileCb);\r\n        }\r\n        // Scan Zip files for local-file-header\r\n        let stop = false;\r\n        do {\r\n            const zipHeader = await this.readLocalFileHeader();\r\n            if (!zipHeader)\r\n                break;\r\n            const next = fileCb(zipHeader);\r\n            stop = !!next.stop;\r\n            let fileData;\r\n            await this.tokenizer.ignore(zipHeader.extraFieldLength);\r\n            if (zipHeader.dataDescriptor && zipHeader.compressedSize === 0) {\r\n                const chunks = [];\r\n                let len = syncBufferSize;\r\n                debug('Compressed-file-size unknown, scanning for next data-descriptor-signature....');\r\n                let nextHeaderIndex = -1;\r\n                while (nextHeaderIndex < 0 && len === syncBufferSize) {\r\n                    len = await this.tokenizer.peekBuffer(this.syncBuffer, { mayBeLess: true });\r\n                    nextHeaderIndex = indexOf(this.syncBuffer.subarray(0, len), ddSignatureArray);\r\n                    const size = nextHeaderIndex >= 0 ? nextHeaderIndex : len;\r\n                    if (next.handler) {\r\n                        const data = new Uint8Array(size);\r\n                        await this.tokenizer.readBuffer(data);\r\n                        chunks.push(data);\r\n                    }\r\n                    else {\r\n                        // Move position to the next header if found, skip the whole buffer otherwise\r\n                        await this.tokenizer.ignore(size);\r\n                    }\r\n                }\r\n                debug(`Found data-descriptor-signature at pos=${this.tokenizer.position}`);\r\n                if (next.handler) {\r\n                    await this.inflate(zipHeader, mergeArrays(chunks), next.handler);\r\n                }\r\n            }\r\n            else {\r\n                if (next.handler) {\r\n                    debug(`Reading compressed-file-data: ${zipHeader.compressedSize} bytes`);\r\n                    fileData = new Uint8Array(zipHeader.compressedSize);\r\n                    await this.tokenizer.readBuffer(fileData);\r\n                    await this.inflate(zipHeader, fileData, next.handler);\r\n                }\r\n                else {\r\n                    debug(`Ignoring compressed-file-data: ${zipHeader.compressedSize} bytes`);\r\n                    await this.tokenizer.ignore(zipHeader.compressedSize);\r\n                }\r\n            }\r\n            debug(`Reading data-descriptor at pos=${this.tokenizer.position}`);\r\n            if (zipHeader.dataDescriptor) {\r\n                // await this.tokenizer.ignore(DataDescriptor.len);\r\n                const dataDescriptor = await this.tokenizer.readToken(DataDescriptor);\r\n                if (dataDescriptor.signature !== 0x08074b50) {\r\n                    throw new Error(`Expected data-descriptor-signature at position ${this.tokenizer.position - DataDescriptor.len}`);\r\n                }\r\n            }\r\n        } while (!stop);\r\n    }\r\n    async iterateOverCentralDirectory(entries, fileCb) {\r\n        for (const fileHeader of entries) {\r\n            const next = fileCb(fileHeader);\r\n            if (next.handler) {\r\n                this.tokenizer.setPosition(fileHeader.relativeOffsetOfLocalHeader);\r\n                const zipHeader = await this.readLocalFileHeader();\r\n                if (zipHeader) {\r\n                    await this.tokenizer.ignore(zipHeader.extraFieldLength);\r\n                    const fileData = new Uint8Array(fileHeader.compressedSize);\r\n                    await this.tokenizer.readBuffer(fileData);\r\n                    await this.inflate(zipHeader, fileData, next.handler);\r\n                }\r\n            }\r\n            if (next.stop)\r\n                break;\r\n        }\r\n    }\r\n    async inflate(zipHeader, fileData, cb) {\r\n        if (zipHeader.compressedMethod === 0) {\r\n            // Stored (uncompressed)\r\n            return cb(fileData);\r\n        }\r\n        if (zipHeader.compressedMethod !== 8) {\r\n            throw new Error(`Unsupported ZIP compression method: ${zipHeader.compressedMethod}`);\r\n        }\r\n        debug(`Decompress filename=${zipHeader.filename}, compressed-size=${fileData.length}`);\r\n        const uncompressedData = await ZipHandler.decompressDeflateRaw(fileData);\r\n        return cb(uncompressedData);\r\n    }\r\n    static async decompressDeflateRaw(data) {\r\n        // Wrap Uint8Array in a ReadableStream without copying\r\n        const input = new ReadableStream({\r\n            start(controller) {\r\n                controller.enqueue(data);\r\n                controller.close();\r\n            }\r\n        });\r\n        const ds = new DecompressionStream(\"deflate-raw\");\r\n        const output = input.pipeThrough(ds);\r\n        try {\r\n            // Collect decompressed bytes from the output stream\r\n            const response = new Response(output);\r\n            const buffer = await response.arrayBuffer();\r\n            return new Uint8Array(buffer);\r\n        }\r\n        catch (err) {\r\n            // Provide ZIP-specific error context\r\n            const message = err instanceof Error\r\n                ? `Failed to deflate ZIP entry: ${err.message}`\r\n                : \"Unknown decompression error in ZIP entry\";\r\n            throw new TypeError(message);\r\n        }\r\n    }\r\n    async readLocalFileHeader() {\r\n        const signature = await this.tokenizer.peekToken(UINT32_LE);\r\n        if (signature === Signature.LocalFileHeader) {\r\n            const header = await this.tokenizer.readToken(LocalFileHeaderToken);\r\n            header.filename = await this.tokenizer.readToken(new StringType(header.filenameLength, 'utf-8'));\r\n            return header;\r\n        }\r\n        if (signature === Signature.CentralFileHeader) {\r\n            return false;\r\n        }\r\n        if (signature === 0xE011CFD0) {\r\n            throw new Error('Encrypted ZIP');\r\n        }\r\n        throw new Error('Unexpected signature');\r\n    }\r\n}\r\nfunction indexOf(buffer, portion) {\r\n    const bufferLength = buffer.length;\r\n    const portionLength = portion.length;\r\n    // Return -1 if the portion is longer than the buffer\r\n    if (portionLength > bufferLength)\r\n        return -1;\r\n    // Search for the portion in the buffer\r\n    for (let i = 0; i <= bufferLength - portionLength; i++) {\r\n        let found = true;\r\n        for (let j = 0; j < portionLength; j++) {\r\n            if (buffer[i + j] !== portion[j]) {\r\n                found = false;\r\n                break;\r\n            }\r\n        }\r\n        if (found) {\r\n            return i; // Return the starting offset\r\n        }\r\n    }\r\n    return -1; // Not found\r\n}\r\nfunction mergeArrays(chunks) {\r\n    // Concatenate chunks into a single Uint8Array\r\n    const totalLength = chunks.reduce((acc, curr) => acc + curr.length, 0);\r\n    const mergedArray = new Uint8Array(totalLength);\r\n    let offset = 0;\r\n    for (const chunk of chunks) {\r\n        mergedArray.set(chunk, offset);\r\n        offset += chunk.length;\r\n    }\r\n    return mergedArray;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}