{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport { AbstractTokenizer } from './AbstractTokenizer.js';\nimport { EndOfStreamError } from './stream/index.js';\nconst maxBufferSize = 256000;\nexport class ReadStreamTokenizer extends AbstractTokenizer {\n  /**\n   * Constructor\n   * @param streamReader stream-reader to read from\n   * @param options Tokenizer options\n   */\n  constructor(streamReader, options) {\n    super(options);\n    this.streamReader = streamReader;\n    this.fileInfo = options?.fileInfo ?? {};\n  }\n  /**\n   * Read buffer from tokenizer\n   * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream\n   * @param options - Read behaviour options\n   * @returns Promise with number of bytes read\n   */\n  async readBuffer(uint8Array, options) {\n    const normOptions = this.normalizeOptions(uint8Array, options);\n    const skipBytes = normOptions.position - this.position;\n    if (skipBytes > 0) {\n      await this.ignore(skipBytes);\n      return this.readBuffer(uint8Array, options);\n    }\n    if (skipBytes < 0) {\n      throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\n    }\n    if (normOptions.length === 0) {\n      return 0;\n    }\n    const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);\n    this.position += bytesRead;\n    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {\n      throw new EndOfStreamError();\n    }\n    return bytesRead;\n  }\n  /**\n   * Peek (read ahead) buffer from tokenizer\n   * @param uint8Array - Uint8Array (or Buffer) to write data to\n   * @param options - Read behaviour options\n   * @returns Promise with number of bytes peeked\n   */\n  async peekBuffer(uint8Array, options) {\n    const normOptions = this.normalizeOptions(uint8Array, options);\n    let bytesRead = 0;\n    if (normOptions.position) {\n      const skipBytes = normOptions.position - this.position;\n      if (skipBytes > 0) {\n        const skipBuffer = new Uint8Array(normOptions.length + skipBytes);\n        bytesRead = await this.peekBuffer(skipBuffer, {\n          mayBeLess: normOptions.mayBeLess\n        });\n        uint8Array.set(skipBuffer.subarray(skipBytes));\n        return bytesRead - skipBytes;\n      }\n      if (skipBytes < 0) {\n        throw new Error('Cannot peek from a negative offset in a stream');\n      }\n    }\n    if (normOptions.length > 0) {\n      try {\n        bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);\n      } catch (err) {\n        if (options?.mayBeLess && err instanceof EndOfStreamError) {\n          return 0;\n        }\n        throw err;\n      }\n      if (!normOptions.mayBeLess && bytesRead < normOptions.length) {\n        throw new EndOfStreamError();\n      }\n    }\n    return bytesRead;\n  }\n  async ignore(length) {\n    // debug(`ignore ${this.position}...${this.position + length - 1}`);\n    const bufSize = Math.min(maxBufferSize, length);\n    const buf = new Uint8Array(bufSize);\n    let totBytesRead = 0;\n    while (totBytesRead < length) {\n      const remaining = length - totBytesRead;\n      const bytesRead = await this.readBuffer(buf, {\n        length: Math.min(bufSize, remaining)\n      });\n      if (bytesRead < 0) {\n        return bytesRead;\n      }\n      totBytesRead += bytesRead;\n    }\n    return totBytesRead;\n  }\n  abort() {\n    return this.streamReader.abort();\n  }\n  async close() {\n    return this.streamReader.close();\n  }\n  supportsRandomAccess() {\n    return false;\n  }\n}","map":{"version":3,"names":["AbstractTokenizer","EndOfStreamError","maxBufferSize","ReadStreamTokenizer","constructor","streamReader","options","fileInfo","readBuffer","uint8Array","normOptions","normalizeOptions","skipBytes","position","ignore","Error","length","bytesRead","read","subarray","mayBeLess","peekBuffer","skipBuffer","Uint8Array","set","peek","err","bufSize","Math","min","buf","totBytesRead","remaining","abort","close","supportsRandomAccess"],"sources":["/home/kup/my_projects/vue/osi/node_modules/strtok3/lib/ReadStreamTokenizer.js"],"sourcesContent":["import { AbstractTokenizer } from './AbstractTokenizer.js';\nimport { EndOfStreamError } from './stream/index.js';\nconst maxBufferSize = 256000;\nexport class ReadStreamTokenizer extends AbstractTokenizer {\n    /**\n     * Constructor\n     * @param streamReader stream-reader to read from\n     * @param options Tokenizer options\n     */\n    constructor(streamReader, options) {\n        super(options);\n        this.streamReader = streamReader;\n        this.fileInfo = options?.fileInfo ?? {};\n    }\n    /**\n     * Read buffer from tokenizer\n     * @param uint8Array - Target Uint8Array to fill with data read from the tokenizer-stream\n     * @param options - Read behaviour options\n     * @returns Promise with number of bytes read\n     */\n    async readBuffer(uint8Array, options) {\n        const normOptions = this.normalizeOptions(uint8Array, options);\n        const skipBytes = normOptions.position - this.position;\n        if (skipBytes > 0) {\n            await this.ignore(skipBytes);\n            return this.readBuffer(uint8Array, options);\n        }\n        if (skipBytes < 0) {\n            throw new Error('`options.position` must be equal or greater than `tokenizer.position`');\n        }\n        if (normOptions.length === 0) {\n            return 0;\n        }\n        const bytesRead = await this.streamReader.read(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);\n        this.position += bytesRead;\n        if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {\n            throw new EndOfStreamError();\n        }\n        return bytesRead;\n    }\n    /**\n     * Peek (read ahead) buffer from tokenizer\n     * @param uint8Array - Uint8Array (or Buffer) to write data to\n     * @param options - Read behaviour options\n     * @returns Promise with number of bytes peeked\n     */\n    async peekBuffer(uint8Array, options) {\n        const normOptions = this.normalizeOptions(uint8Array, options);\n        let bytesRead = 0;\n        if (normOptions.position) {\n            const skipBytes = normOptions.position - this.position;\n            if (skipBytes > 0) {\n                const skipBuffer = new Uint8Array(normOptions.length + skipBytes);\n                bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess });\n                uint8Array.set(skipBuffer.subarray(skipBytes));\n                return bytesRead - skipBytes;\n            }\n            if (skipBytes < 0) {\n                throw new Error('Cannot peek from a negative offset in a stream');\n            }\n        }\n        if (normOptions.length > 0) {\n            try {\n                bytesRead = await this.streamReader.peek(uint8Array.subarray(0, normOptions.length), normOptions.mayBeLess);\n            }\n            catch (err) {\n                if (options?.mayBeLess && err instanceof EndOfStreamError) {\n                    return 0;\n                }\n                throw err;\n            }\n            if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {\n                throw new EndOfStreamError();\n            }\n        }\n        return bytesRead;\n    }\n    async ignore(length) {\n        // debug(`ignore ${this.position}...${this.position + length - 1}`);\n        const bufSize = Math.min(maxBufferSize, length);\n        const buf = new Uint8Array(bufSize);\n        let totBytesRead = 0;\n        while (totBytesRead < length) {\n            const remaining = length - totBytesRead;\n            const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) });\n            if (bytesRead < 0) {\n                return bytesRead;\n            }\n            totBytesRead += bytesRead;\n        }\n        return totBytesRead;\n    }\n    abort() {\n        return this.streamReader.abort();\n    }\n    async close() {\n        return this.streamReader.close();\n    }\n    supportsRandomAccess() {\n        return false;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}