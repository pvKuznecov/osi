{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.every.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport * as Token from 'token-types';\nimport { EndOfStreamError } from 'strtok3';\nimport initDebug from 'debug';\nimport * as common from '../common/Util.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { InfoTagHeaderTag, LameEncoderVersion, readXingHeader } from './XingTag.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:mpeg');\nexport class MpegContentError extends makeUnexpectedFileContentError('MPEG') {}\n/**\r\n * Cache buffer size used for searching synchronization preabmle\r\n */\nconst maxPeekLen = 1024;\n/**\r\n * MPEG-4 Audio definitions\r\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\r\n */\nconst MPEG4 = {\n  /**\r\n   * Audio Object Types\r\n   */\n  AudioObjectTypes: ['AAC Main', 'AAC LC',\n  // Low Complexity\n  'AAC SSR',\n  // Scalable Sample Rate\n  'AAC LTP' // Long Term Prediction\n  ],\n  /**\r\n   * Sampling Frequencies\r\n   * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\r\n   */\n  SamplingFrequencies: [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, null, null, -1]\n  /**\r\n   * Channel Configurations\r\n   */\n};\nconst MPEG4_ChannelConfigurations = [undefined, ['front-center'], ['front-left', 'front-right'], ['front-center', 'front-left', 'front-right'], ['front-center', 'front-left', 'front-right', 'back-center'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'], ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'], ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']];\n/**\r\n * MPEG Audio Layer I/II/III frame header\r\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\r\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\r\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\r\n */\nclass MpegFrameHeader {\n  constructor(buf, off) {\n    // E(15,12): Bitrate index\n    this.bitrateIndex = null;\n    // F(11,10): Sampling rate frequency index\n    this.sampRateFreqIndex = null;\n    // G(9): Padding bit\n    this.padding = null;\n    // H(8): Private bit\n    this.privateBit = null;\n    // I(7,6): Channel Mode\n    this.channelModeIndex = null;\n    // J(5,4): Mode extension (Only used in Joint stereo)\n    this.modeExtension = null;\n    // L(2): Original\n    this.isOriginalMedia = null;\n    this.version = null;\n    this.bitrate = null;\n    this.samplingRate = null;\n    this.frameLength = 0;\n    // B(20,19): MPEG Audio versionIndex ID\n    this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\n    // C(18,17): Layer description\n    this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\n    if (this.versionIndex > 1 && this.layer === 0) {\n      this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\n    } else {\n      this.parseMpegHeader(buf, off); // Conventional MPEG header\n    }\n    // D(16): Protection bit (if true 16-bit CRC follows header)\n    this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\n  }\n  calcDuration(numFrames) {\n    return this.samplingRate == null ? null : numFrames * this.calcSamplesPerFrame() / this.samplingRate;\n  }\n  calcSamplesPerFrame() {\n    return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\n  }\n  calculateSideInfoLength() {\n    if (this.layer !== 3) return 2;\n    if (this.channelModeIndex === 3) {\n      // mono\n      if (this.version === 1) {\n        return 17;\n      }\n      if (this.version === 2 || this.version === 2.5) {\n        return 9;\n      }\n    } else {\n      if (this.version === 1) {\n        return 32;\n      }\n      if (this.version === 2 || this.version === 2.5) {\n        return 17;\n      }\n    }\n    return null;\n  }\n  calcSlotSize() {\n    return [null, 4, 1, 1][this.layer];\n  }\n  parseMpegHeader(buf, off) {\n    this.container = 'MPEG';\n    // E(15,12): Bitrate index\n    this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\n    // F(11,10): Sampling rate frequency index\n    this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\n    // G(9): Padding bit\n    this.padding = common.isBitSet(buf, off + 2, 6);\n    // H(8): Private bit\n    this.privateBit = common.isBitSet(buf, off + 2, 7);\n    // I(7,6): Channel Mode\n    this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\n    // J(5,4): Mode extension (Only used in Joint stereo)\n    this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\n    // K(3): Copyright\n    this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\n    // L(2): Original\n    this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\n    // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\n    this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\n    this.version = MpegFrameHeader.VersionID[this.versionIndex];\n    this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\n    this.codec = `MPEG ${this.version} Layer ${this.layer}`;\n    // Calculate bitrate\n    const bitrateInKbps = this.calcBitrate();\n    if (!bitrateInKbps) {\n      throw new MpegContentError('Cannot determine bit-rate');\n    }\n    this.bitrate = bitrateInKbps * 1000;\n    // Calculate sampling rate\n    this.samplingRate = this.calcSamplingRate();\n    if (this.samplingRate == null) {\n      throw new MpegContentError('Cannot determine sampling-rate');\n    }\n  }\n  parseAdtsHeader(buf, off) {\n    debug(\"layer=0 => ADTS\");\n    this.version = this.versionIndex === 2 ? 4 : 2;\n    this.container = `ADTS/MPEG-${this.version}`;\n    const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\n    this.codec = 'AAC';\n    this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\n    debug(`MPEG-4 audio-codec=${this.codec}`);\n    const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\n    this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\n    debug(`sampling-rate=${this.samplingRate}`);\n    const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\n    this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\n    debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join('+') : '?'}`);\n    this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\n  }\n  calcBitrate() {\n    if (this.bitrateIndex === 0x00 ||\n    // free\n    this.bitrateIndex === 0x0F) {\n      // reserved\n      return null;\n    }\n    if (this.version && this.bitrateIndex) {\n      const codecIndex = 10 * Math.floor(this.version) + this.layer;\n      return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\n    }\n    return null;\n  }\n  calcSamplingRate() {\n    if (this.sampRateFreqIndex === 0x03 || this.version === null || this.sampRateFreqIndex == null) return null; // 'reserved'\n    return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\n  }\n}\nMpegFrameHeader.SyncByte1 = 0xFF;\nMpegFrameHeader.SyncByte2 = 0xE0;\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\nMpegFrameHeader.bitrate_index = {\n  1: {\n    11: 32,\n    12: 32,\n    13: 32,\n    21: 32,\n    22: 8,\n    23: 8\n  },\n  2: {\n    11: 64,\n    12: 48,\n    13: 40,\n    21: 48,\n    22: 16,\n    23: 16\n  },\n  3: {\n    11: 96,\n    12: 56,\n    13: 48,\n    21: 56,\n    22: 24,\n    23: 24\n  },\n  4: {\n    11: 128,\n    12: 64,\n    13: 56,\n    21: 64,\n    22: 32,\n    23: 32\n  },\n  5: {\n    11: 160,\n    12: 80,\n    13: 64,\n    21: 80,\n    22: 40,\n    23: 40\n  },\n  6: {\n    11: 192,\n    12: 96,\n    13: 80,\n    21: 96,\n    22: 48,\n    23: 48\n  },\n  7: {\n    11: 224,\n    12: 112,\n    13: 96,\n    21: 112,\n    22: 56,\n    23: 56\n  },\n  8: {\n    11: 256,\n    12: 128,\n    13: 112,\n    21: 128,\n    22: 64,\n    23: 64\n  },\n  9: {\n    11: 288,\n    12: 160,\n    13: 128,\n    21: 144,\n    22: 80,\n    23: 80\n  },\n  10: {\n    11: 320,\n    12: 192,\n    13: 160,\n    21: 160,\n    22: 96,\n    23: 96\n  },\n  11: {\n    11: 352,\n    12: 224,\n    13: 192,\n    21: 176,\n    22: 112,\n    23: 112\n  },\n  12: {\n    11: 384,\n    12: 256,\n    13: 224,\n    21: 192,\n    22: 128,\n    23: 128\n  },\n  13: {\n    11: 416,\n    12: 320,\n    13: 256,\n    21: 224,\n    22: 144,\n    23: 144\n  },\n  14: {\n    11: 448,\n    12: 384,\n    13: 320,\n    21: 256,\n    22: 160,\n    23: 160\n  }\n};\nMpegFrameHeader.sampling_rate_freq_index = {\n  1: {\n    0: 44100,\n    1: 48000,\n    2: 32000\n  },\n  2: {\n    0: 22050,\n    1: 24000,\n    2: 16000\n  },\n  2.5: {\n    0: 11025,\n    1: 12000,\n    2: 8000\n  }\n};\nMpegFrameHeader.samplesInFrameTable = [/* Layer   I    II   III */\n[0, 384, 1152, 1152],\n// MPEG-1\n[0, 384, 1152, 576] // MPEG-2(.5\n];\n/**\r\n * MPEG Audio Layer I/II/III\r\n */\nconst FrameHeader = {\n  len: 4,\n  get: (buf, off) => {\n    return new MpegFrameHeader(buf, off);\n  }\n};\nfunction getVbrCodecProfile(vbrScale) {\n  return `V${Math.floor((100 - vbrScale) / 10)}`;\n}\nexport class MpegParser extends AbstractID3Parser {\n  constructor() {\n    super(...arguments);\n    this.frameCount = 0;\n    this.syncFrameCount = -1;\n    this.countSkipFrameData = 0;\n    this.totalDataLength = 0;\n    this.bitrates = [];\n    this.offset = 0;\n    this.frame_size = 0;\n    this.crc = null;\n    this.calculateEofDuration = false;\n    this.samplesPerFrame = null;\n    this.buf_frame_header = new Uint8Array(4);\n    /**\r\n     * Number of bytes already parsed since beginning of stream / file\r\n     */\n    this.mpegOffset = null;\n    this.syncPeek = {\n      buf: new Uint8Array(maxPeekLen),\n      len: 0\n    };\n  }\n  /**\r\n   * Called after ID3 headers have been parsed\r\n   */\n  async postId3v2Parse() {\n    this.metadata.setFormat('lossless', false);\n    this.metadata.setAudioOnly();\n    try {\n      let quit = false;\n      while (!quit) {\n        await this.sync();\n        quit = await this.parseCommonMpegHeader();\n      }\n    } catch (err) {\n      if (err instanceof EndOfStreamError) {\n        debug(\"End-of-stream\");\n        if (this.calculateEofDuration) {\n          if (this.samplesPerFrame !== null) {\n            const numberOfSamples = this.frameCount * this.samplesPerFrame;\n            this.metadata.setFormat('numberOfSamples', numberOfSamples);\n            if (this.metadata.format.sampleRate) {\n              const duration = numberOfSamples / this.metadata.format.sampleRate;\n              debug(`Calculate duration at EOF: ${duration} sec.`, duration);\n              this.metadata.setFormat('duration', duration);\n            }\n          }\n        }\n      } else {\n        throw err;\n      }\n    }\n  }\n  /**\r\n   * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\r\n   */\n  finalize() {\n    const format = this.metadata.format;\n    const hasID3v1 = !!this.metadata.native.ID3v1;\n    if (this.mpegOffset !== null) {\n      if (format.duration && this.tokenizer.fileInfo.size) {\n        const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n        if (format.codecProfile && format.codecProfile[0] === 'V') {\n          this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\n        }\n      }\n      if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\n        const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\n        if (this.frame_size !== null && this.samplesPerFrame !== null) {\n          const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\n          this.metadata.setFormat('numberOfSamples', numberOfSamples);\n          if (format.sampleRate && !format.duration) {\n            const duration = numberOfSamples / format.sampleRate;\n            debug(\"Calculate CBR duration based on file size: %s\", duration);\n            this.metadata.setFormat('duration', duration);\n          }\n        }\n      }\n    }\n  }\n  async sync() {\n    let gotFirstSync = false;\n    while (true) {\n      let bo = 0;\n      this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, {\n        length: maxPeekLen,\n        mayBeLess: true\n      });\n      if (this.syncPeek.len <= 163) {\n        throw new EndOfStreamError();\n      }\n      while (true) {\n        if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\n          this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\n          this.buf_frame_header[1] = this.syncPeek.buf[bo];\n          await this.tokenizer.ignore(bo);\n          debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\n          if (this.syncFrameCount === this.frameCount) {\n            debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\n            this.frameCount = 0;\n            this.frame_size = 0;\n          }\n          this.syncFrameCount = this.frameCount;\n          return; // sync\n        }\n        gotFirstSync = false;\n        bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\n        if (bo === -1) {\n          if (this.syncPeek.len < this.syncPeek.buf.length) {\n            throw new EndOfStreamError();\n          }\n          await this.tokenizer.ignore(this.syncPeek.len);\n          break; // continue with next buffer\n        }\n        ++bo;\n        gotFirstSync = true;\n      }\n    }\n  }\n  /**\r\n   * Combined ADTS & MPEG (MP2 & MP3) header handling\r\n   * @return {Promise<boolean>} true if parser should quit\r\n   */\n  async parseCommonMpegHeader() {\n    if (this.frameCount === 0) {\n      this.mpegOffset = this.tokenizer.position - 1;\n    }\n    await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), {\n      length: 3\n    });\n    let header;\n    try {\n      header = FrameHeader.get(this.buf_frame_header, 0);\n    } catch (err) {\n      await this.tokenizer.ignore(1);\n      if (err instanceof Error) {\n        this.metadata.addWarning(`Parse error: ${err.message}`);\n        return false; // sync\n      }\n      throw err;\n    }\n    await this.tokenizer.ignore(3);\n    this.metadata.setFormat('container', header.container);\n    this.metadata.setFormat('codec', header.codec);\n    this.metadata.setFormat('lossless', false);\n    this.metadata.setFormat('sampleRate', header.samplingRate);\n    this.frameCount++;\n    return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\n  }\n  /**\r\n   * @return {Promise<boolean>} true if parser should quit\r\n   */\n  async parseAudioFrameHeader(header) {\n    this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\n    this.metadata.setFormat('bitrate', header.bitrate);\n    if (this.frameCount < 20 * 10000) {\n      debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\n    }\n    const slot_size = header.calcSlotSize();\n    if (slot_size === null) {\n      throw new MpegContentError('invalid slot_size');\n    }\n    const samples_per_frame = header.calcSamplesPerFrame();\n    debug(`samples_per_frame=${samples_per_frame}`);\n    const bps = samples_per_frame / 8.0;\n    if (header.bitrate !== null && header.samplingRate != null) {\n      const fsize = bps * header.bitrate / header.samplingRate + (header.padding ? slot_size : 0);\n      this.frame_size = Math.floor(fsize);\n    }\n    this.audioFrameHeader = header;\n    if (header.bitrate !== null) {\n      this.bitrates.push(header.bitrate);\n    }\n    // xtra header only exists in first frame\n    if (this.frameCount === 1) {\n      this.offset = FrameHeader.len;\n      await this.skipSideInformation();\n      return false;\n    }\n    if (this.frameCount === 4) {\n      // the stream is CBR if the first 3 frame bitrates are the same\n      if (this.areAllSame(this.bitrates)) {\n        // Actual calculation will be done in finalize\n        this.samplesPerFrame = samples_per_frame;\n        this.metadata.setFormat('codecProfile', 'CBR');\n        if (this.tokenizer.fileInfo.size) return true; // Will calculate duration based on the file size\n      } else if (this.metadata.format.duration) {\n        return true; // We already got the duration, stop processing MPEG stream any further\n      }\n      if (!this.options.duration) {\n        return true; // Enforce duration not enabled, stop processing entire stream\n      }\n    }\n    // once we know the file is VBR attach listener to end of\n    // stream so we can do the duration calculation when we\n    // have counted all the frames\n    if (this.options.duration && this.frameCount === 4) {\n      this.samplesPerFrame = samples_per_frame;\n      this.calculateEofDuration = true;\n    }\n    this.offset = 4;\n    if (header.isProtectedByCRC) {\n      await this.parseCrc();\n      return false;\n    }\n    await this.skipSideInformation();\n    return false;\n  }\n  async parseAdts(header) {\n    const buf = new Uint8Array(3);\n    await this.tokenizer.readBuffer(buf);\n    header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\n    this.totalDataLength += header.frameLength;\n    this.samplesPerFrame = 1024;\n    if (header.samplingRate !== null) {\n      const framesPerSec = header.samplingRate / this.samplesPerFrame;\n      const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\n      const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\n      this.metadata.setFormat('bitrate', bitrate);\n      debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\n    }\n    await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\n    // Consume remaining header and frame data\n    if (this.frameCount === 3) {\n      this.metadata.setFormat('codecProfile', header.codecProfile);\n      if (header.mp4ChannelConfig) {\n        this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\n      }\n      if (this.options.duration) {\n        this.calculateEofDuration = true;\n      } else {\n        return true; // Stop parsing after the third frame\n      }\n    }\n    return false;\n  }\n  async parseCrc() {\n    this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\n    this.offset += 2;\n    return this.skipSideInformation();\n  }\n  async skipSideInformation() {\n    if (this.audioFrameHeader) {\n      const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\n      if (sideinfo_length !== null) {\n        await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\n        // side information\n        this.offset += sideinfo_length;\n        await this.readXtraInfoHeader();\n        return;\n      }\n    }\n  }\n  async readXtraInfoHeader() {\n    const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);\n    this.offset += InfoTagHeaderTag.len; // 12\n    switch (headerTag) {\n      case 'Info':\n        this.metadata.setFormat('codecProfile', 'CBR');\n        return this.readXingInfoHeader();\n      case 'Xing':\n        {\n          const infoTag = await this.readXingInfoHeader();\n          if (infoTag.vbrScale !== null) {\n            const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\n            this.metadata.setFormat('codecProfile', codecProfile);\n          }\n          return null;\n        }\n      case 'Xtra':\n        // ToDo: ???\n        break;\n      case 'LAME':\n        {\n          const version = await this.tokenizer.readToken(LameEncoderVersion);\n          if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {\n            this.offset += LameEncoderVersion.len;\n            this.metadata.setFormat('tool', `LAME ${version}`);\n            await this.skipFrameData(this.frame_size - this.offset);\n            return null;\n          }\n          this.metadata.addWarning('Corrupt LAME header');\n          break;\n        }\n      // ToDo: ???\n    }\n    // ToDo: promise duration???\n    const frameDataLeft = this.frame_size - this.offset;\n    if (frameDataLeft < 0) {\n      this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);\n    } else {\n      await this.skipFrameData(frameDataLeft);\n    }\n    return null;\n  }\n  /**\r\n   * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n   * @returns {Promise<string>}\r\n   */\n  async readXingInfoHeader() {\n    const offset = this.tokenizer.position;\n    const infoTag = await readXingHeader(this.tokenizer);\n    this.offset += this.tokenizer.position - offset;\n    if (infoTag.lame) {\n      this.metadata.setFormat('tool', `LAME ${common.stripNulls(infoTag.lame.version)}`);\n      if (infoTag.lame.extended) {\n        // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\n        this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\n        if (infoTag.lame.extended.track_gain) {\n          this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\n        }\n        if (infoTag.lame.extended.album_gain) {\n          this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\n        }\n        this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\n      }\n    }\n    if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {\n      const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\n      this.metadata.setFormat('duration', duration);\n      debug('Get duration from Xing header: %s', this.metadata.format.duration);\n      return infoTag;\n    }\n    // frames field is not present\n    const frameDataLeft = this.frame_size - this.offset;\n    await this.skipFrameData(frameDataLeft);\n    return infoTag;\n  }\n  async skipFrameData(frameDataLeft) {\n    if (frameDataLeft < 0) throw new MpegContentError('frame-data-left cannot be negative');\n    await this.tokenizer.ignore(frameDataLeft);\n    this.countSkipFrameData += frameDataLeft;\n  }\n  areAllSame(array) {\n    const first = array[0];\n    return array.every(element => {\n      return element === first;\n    });\n  }\n}","map":{"version":3,"names":["Token","EndOfStreamError","initDebug","common","AbstractID3Parser","InfoTagHeaderTag","LameEncoderVersion","readXingHeader","makeUnexpectedFileContentError","debug","MpegContentError","maxPeekLen","MPEG4","AudioObjectTypes","SamplingFrequencies","MPEG4_ChannelConfigurations","undefined","MpegFrameHeader","constructor","buf","off","bitrateIndex","sampRateFreqIndex","padding","privateBit","channelModeIndex","modeExtension","isOriginalMedia","version","bitrate","samplingRate","frameLength","versionIndex","getBitAllignedNumber","layer","LayerDescription","parseAdtsHeader","parseMpegHeader","isProtectedByCRC","isBitSet","calcDuration","numFrames","calcSamplesPerFrame","samplesInFrameTable","calculateSideInfoLength","calcSlotSize","container","isCopyrighted","emphasis","VersionID","channelMode","ChannelMode","codec","bitrateInKbps","calcBitrate","calcSamplingRate","profileIndex","codecProfile","samplingFrequencyIndex","channelIndex","mp4ChannelConfig","join","codecIndex","Math","floor","bitrate_index","sampling_rate_freq_index","SyncByte1","SyncByte2","FrameHeader","len","get","getVbrCodecProfile","vbrScale","MpegParser","arguments","frameCount","syncFrameCount","countSkipFrameData","totalDataLength","bitrates","offset","frame_size","crc","calculateEofDuration","samplesPerFrame","buf_frame_header","Uint8Array","mpegOffset","syncPeek","postId3v2Parse","metadata","setFormat","setAudioOnly","quit","sync","parseCommonMpegHeader","err","numberOfSamples","format","sampleRate","duration","finalize","hasID3v1","native","ID3v1","tokenizer","fileInfo","size","mpegSize","round","gotFirstSync","bo","peekBuffer","length","mayBeLess","ignore","position","indexOf","subarray","header","Error","addWarning","message","parseAdts","parseAudioFrameHeader","slot_size","samples_per_frame","bps","fsize","audioFrameHeader","push","skipSideInformation","areAllSame","options","parseCrc","readBuffer","framesPerSec","bytesPerFrame","readNumber","INT16_BE","sideinfo_length","readToken","Uint8ArrayType","readXtraInfoHeader","headerTag","readXingInfoHeader","infoTag","skipFrameData","frameDataLeft","lame","stripNulls","extended","track_peak","track_gain","adjustment","album_gain","music_length","streamSize","array","first","every","element"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/mpeg/MpegParser.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport { EndOfStreamError } from 'strtok3';\r\nimport initDebug from 'debug';\r\nimport * as common from '../common/Util.js';\r\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\r\nimport { InfoTagHeaderTag, LameEncoderVersion, readXingHeader } from './XingTag.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:mpeg');\r\nexport class MpegContentError extends makeUnexpectedFileContentError('MPEG') {\r\n}\r\n/**\r\n * Cache buffer size used for searching synchronization preabmle\r\n */\r\nconst maxPeekLen = 1024;\r\n/**\r\n * MPEG-4 Audio definitions\r\n * Ref:  https://wiki.multimedia.cx/index.php/MPEG-4_Audio\r\n */\r\nconst MPEG4 = {\r\n    /**\r\n     * Audio Object Types\r\n     */\r\n    AudioObjectTypes: [\r\n        'AAC Main',\r\n        'AAC LC', // Low Complexity\r\n        'AAC SSR', // Scalable Sample Rate\r\n        'AAC LTP' // Long Term Prediction\r\n    ],\r\n    /**\r\n     * Sampling Frequencies\r\n     * https://wiki.multimedia.cx/index.php/MPEG-4_Audio#Sampling_Frequencies\r\n     */\r\n    SamplingFrequencies: [\r\n        96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350, null, null, -1\r\n    ]\r\n    /**\r\n     * Channel Configurations\r\n     */\r\n};\r\nconst MPEG4_ChannelConfigurations = [\r\n    undefined,\r\n    ['front-center'],\r\n    ['front-left', 'front-right'],\r\n    ['front-center', 'front-left', 'front-right'],\r\n    ['front-center', 'front-left', 'front-right', 'back-center'],\r\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right'],\r\n    ['front-center', 'front-left', 'front-right', 'back-left', 'back-right', 'LFE-channel'],\r\n    ['front-center', 'front-left', 'front-right', 'side-left', 'side-right', 'back-left', 'back-right', 'LFE-channel']\r\n];\r\n/**\r\n * MPEG Audio Layer I/II/III frame header\r\n * Ref: https://www.mp3-tech.org/programmer/frame_header.html\r\n * Bit layout: AAAAAAAA AAABBCCD EEEEFFGH IIJJKLMM\r\n * Ref: https://wiki.multimedia.cx/index.php/ADTS\r\n */\r\nclass MpegFrameHeader {\r\n    constructor(buf, off) {\r\n        // E(15,12): Bitrate index\r\n        this.bitrateIndex = null;\r\n        // F(11,10): Sampling rate frequency index\r\n        this.sampRateFreqIndex = null;\r\n        // G(9): Padding bit\r\n        this.padding = null;\r\n        // H(8): Private bit\r\n        this.privateBit = null;\r\n        // I(7,6): Channel Mode\r\n        this.channelModeIndex = null;\r\n        // J(5,4): Mode extension (Only used in Joint stereo)\r\n        this.modeExtension = null;\r\n        // L(2): Original\r\n        this.isOriginalMedia = null;\r\n        this.version = null;\r\n        this.bitrate = null;\r\n        this.samplingRate = null;\r\n        this.frameLength = 0;\r\n        // B(20,19): MPEG Audio versionIndex ID\r\n        this.versionIndex = common.getBitAllignedNumber(buf, off + 1, 3, 2);\r\n        // C(18,17): Layer description\r\n        this.layer = MpegFrameHeader.LayerDescription[common.getBitAllignedNumber(buf, off + 1, 5, 2)];\r\n        if (this.versionIndex > 1 && this.layer === 0) {\r\n            this.parseAdtsHeader(buf, off); // Audio Data Transport Stream (ADTS)\r\n        }\r\n        else {\r\n            this.parseMpegHeader(buf, off); // Conventional MPEG header\r\n        }\r\n        // D(16): Protection bit (if true 16-bit CRC follows header)\r\n        this.isProtectedByCRC = !common.isBitSet(buf, off + 1, 7);\r\n    }\r\n    calcDuration(numFrames) {\r\n        return this.samplingRate == null ? null : (numFrames * this.calcSamplesPerFrame() / this.samplingRate);\r\n    }\r\n    calcSamplesPerFrame() {\r\n        return MpegFrameHeader.samplesInFrameTable[this.version === 1 ? 0 : 1][this.layer];\r\n    }\r\n    calculateSideInfoLength() {\r\n        if (this.layer !== 3)\r\n            return 2;\r\n        if (this.channelModeIndex === 3) {\r\n            // mono\r\n            if (this.version === 1) {\r\n                return 17;\r\n            }\r\n            if (this.version === 2 || this.version === 2.5) {\r\n                return 9;\r\n            }\r\n        }\r\n        else {\r\n            if (this.version === 1) {\r\n                return 32;\r\n            }\r\n            if (this.version === 2 || this.version === 2.5) {\r\n                return 17;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    calcSlotSize() {\r\n        return [null, 4, 1, 1][this.layer];\r\n    }\r\n    parseMpegHeader(buf, off) {\r\n        this.container = 'MPEG';\r\n        // E(15,12): Bitrate index\r\n        this.bitrateIndex = common.getBitAllignedNumber(buf, off + 2, 0, 4);\r\n        // F(11,10): Sampling rate frequency index\r\n        this.sampRateFreqIndex = common.getBitAllignedNumber(buf, off + 2, 4, 2);\r\n        // G(9): Padding bit\r\n        this.padding = common.isBitSet(buf, off + 2, 6);\r\n        // H(8): Private bit\r\n        this.privateBit = common.isBitSet(buf, off + 2, 7);\r\n        // I(7,6): Channel Mode\r\n        this.channelModeIndex = common.getBitAllignedNumber(buf, off + 3, 0, 2);\r\n        // J(5,4): Mode extension (Only used in Joint stereo)\r\n        this.modeExtension = common.getBitAllignedNumber(buf, off + 3, 2, 2);\r\n        // K(3): Copyright\r\n        this.isCopyrighted = common.isBitSet(buf, off + 3, 4);\r\n        // L(2): Original\r\n        this.isOriginalMedia = common.isBitSet(buf, off + 3, 5);\r\n        // M(3): The original bit indicates, if it is set, that the frame is located on its original media.\r\n        this.emphasis = common.getBitAllignedNumber(buf, off + 3, 7, 2);\r\n        this.version = MpegFrameHeader.VersionID[this.versionIndex];\r\n        this.channelMode = MpegFrameHeader.ChannelMode[this.channelModeIndex];\r\n        this.codec = `MPEG ${this.version} Layer ${this.layer}`;\r\n        // Calculate bitrate\r\n        const bitrateInKbps = this.calcBitrate();\r\n        if (!bitrateInKbps) {\r\n            throw new MpegContentError('Cannot determine bit-rate');\r\n        }\r\n        this.bitrate = bitrateInKbps * 1000;\r\n        // Calculate sampling rate\r\n        this.samplingRate = this.calcSamplingRate();\r\n        if (this.samplingRate == null) {\r\n            throw new MpegContentError('Cannot determine sampling-rate');\r\n        }\r\n    }\r\n    parseAdtsHeader(buf, off) {\r\n        debug(\"layer=0 => ADTS\");\r\n        this.version = this.versionIndex === 2 ? 4 : 2;\r\n        this.container = `ADTS/MPEG-${this.version}`;\r\n        const profileIndex = common.getBitAllignedNumber(buf, off + 2, 0, 2);\r\n        this.codec = 'AAC';\r\n        this.codecProfile = MPEG4.AudioObjectTypes[profileIndex];\r\n        debug(`MPEG-4 audio-codec=${this.codec}`);\r\n        const samplingFrequencyIndex = common.getBitAllignedNumber(buf, off + 2, 2, 4);\r\n        this.samplingRate = MPEG4.SamplingFrequencies[samplingFrequencyIndex];\r\n        debug(`sampling-rate=${this.samplingRate}`);\r\n        const channelIndex = common.getBitAllignedNumber(buf, off + 2, 7, 3);\r\n        this.mp4ChannelConfig = MPEG4_ChannelConfigurations[channelIndex];\r\n        debug(`channel-config=${this.mp4ChannelConfig ? this.mp4ChannelConfig.join('+') : '?'}`);\r\n        this.frameLength = common.getBitAllignedNumber(buf, off + 3, 6, 2) << 11;\r\n    }\r\n    calcBitrate() {\r\n        if (this.bitrateIndex === 0x00 || // free\r\n            this.bitrateIndex === 0x0F) { // reserved\r\n            return null;\r\n        }\r\n        if (this.version && this.bitrateIndex) {\r\n            const codecIndex = 10 * Math.floor(this.version) + this.layer;\r\n            return MpegFrameHeader.bitrate_index[this.bitrateIndex][codecIndex];\r\n        }\r\n        return null;\r\n    }\r\n    calcSamplingRate() {\r\n        if (this.sampRateFreqIndex === 0x03 || this.version === null || this.sampRateFreqIndex == null)\r\n            return null; // 'reserved'\r\n        return MpegFrameHeader.sampling_rate_freq_index[this.version][this.sampRateFreqIndex];\r\n    }\r\n}\r\nMpegFrameHeader.SyncByte1 = 0xFF;\r\nMpegFrameHeader.SyncByte2 = 0xE0;\r\nMpegFrameHeader.VersionID = [2.5, null, 2, 1];\r\nMpegFrameHeader.LayerDescription = [0, 3, 2, 1];\r\nMpegFrameHeader.ChannelMode = ['stereo', 'joint_stereo', 'dual_channel', 'mono'];\r\nMpegFrameHeader.bitrate_index = {\r\n    1: { 11: 32, 12: 32, 13: 32, 21: 32, 22: 8, 23: 8 },\r\n    2: { 11: 64, 12: 48, 13: 40, 21: 48, 22: 16, 23: 16 },\r\n    3: { 11: 96, 12: 56, 13: 48, 21: 56, 22: 24, 23: 24 },\r\n    4: { 11: 128, 12: 64, 13: 56, 21: 64, 22: 32, 23: 32 },\r\n    5: { 11: 160, 12: 80, 13: 64, 21: 80, 22: 40, 23: 40 },\r\n    6: { 11: 192, 12: 96, 13: 80, 21: 96, 22: 48, 23: 48 },\r\n    7: { 11: 224, 12: 112, 13: 96, 21: 112, 22: 56, 23: 56 },\r\n    8: { 11: 256, 12: 128, 13: 112, 21: 128, 22: 64, 23: 64 },\r\n    9: { 11: 288, 12: 160, 13: 128, 21: 144, 22: 80, 23: 80 },\r\n    10: { 11: 320, 12: 192, 13: 160, 21: 160, 22: 96, 23: 96 },\r\n    11: { 11: 352, 12: 224, 13: 192, 21: 176, 22: 112, 23: 112 },\r\n    12: { 11: 384, 12: 256, 13: 224, 21: 192, 22: 128, 23: 128 },\r\n    13: { 11: 416, 12: 320, 13: 256, 21: 224, 22: 144, 23: 144 },\r\n    14: { 11: 448, 12: 384, 13: 320, 21: 256, 22: 160, 23: 160 }\r\n};\r\nMpegFrameHeader.sampling_rate_freq_index = {\r\n    1: { 0: 44100, 1: 48000, 2: 32000 },\r\n    2: { 0: 22050, 1: 24000, 2: 16000 },\r\n    2.5: { 0: 11025, 1: 12000, 2: 8000 }\r\n};\r\nMpegFrameHeader.samplesInFrameTable = [\r\n    /* Layer   I    II   III */\r\n    [0, 384, 1152, 1152], // MPEG-1\r\n    [0, 384, 1152, 576] // MPEG-2(.5\r\n];\r\n/**\r\n * MPEG Audio Layer I/II/III\r\n */\r\nconst FrameHeader = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return new MpegFrameHeader(buf, off);\r\n    }\r\n};\r\nfunction getVbrCodecProfile(vbrScale) {\r\n    return `V${Math.floor((100 - vbrScale) / 10)}`;\r\n}\r\nexport class MpegParser extends AbstractID3Parser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.frameCount = 0;\r\n        this.syncFrameCount = -1;\r\n        this.countSkipFrameData = 0;\r\n        this.totalDataLength = 0;\r\n        this.bitrates = [];\r\n        this.offset = 0;\r\n        this.frame_size = 0;\r\n        this.crc = null;\r\n        this.calculateEofDuration = false;\r\n        this.samplesPerFrame = null;\r\n        this.buf_frame_header = new Uint8Array(4);\r\n        /**\r\n         * Number of bytes already parsed since beginning of stream / file\r\n         */\r\n        this.mpegOffset = null;\r\n        this.syncPeek = {\r\n            buf: new Uint8Array(maxPeekLen),\r\n            len: 0\r\n        };\r\n    }\r\n    /**\r\n     * Called after ID3 headers have been parsed\r\n     */\r\n    async postId3v2Parse() {\r\n        this.metadata.setFormat('lossless', false);\r\n        this.metadata.setAudioOnly();\r\n        try {\r\n            let quit = false;\r\n            while (!quit) {\r\n                await this.sync();\r\n                quit = await this.parseCommonMpegHeader();\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n                if (this.calculateEofDuration) {\r\n                    if (this.samplesPerFrame !== null) {\r\n                        const numberOfSamples = this.frameCount * this.samplesPerFrame;\r\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                        if (this.metadata.format.sampleRate) {\r\n                            const duration = numberOfSamples / this.metadata.format.sampleRate;\r\n                            debug(`Calculate duration at EOF: ${duration} sec.`, duration);\r\n                            this.metadata.setFormat('duration', duration);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Called after file has been fully parsed, this allows, if present, to exclude the ID3v1.1 header length\r\n     */\r\n    finalize() {\r\n        const format = this.metadata.format;\r\n        const hasID3v1 = !!this.metadata.native.ID3v1;\r\n        if (this.mpegOffset !== null) {\r\n            if (format.duration && this.tokenizer.fileInfo.size) {\r\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\r\n                if (format.codecProfile && format.codecProfile[0] === 'V') {\r\n                    this.metadata.setFormat('bitrate', mpegSize * 8 / format.duration);\r\n                }\r\n            }\r\n            if (this.tokenizer.fileInfo.size && format.codecProfile === 'CBR') {\r\n                const mpegSize = this.tokenizer.fileInfo.size - this.mpegOffset - (hasID3v1 ? 128 : 0);\r\n                if (this.frame_size !== null && this.samplesPerFrame !== null) {\r\n                    const numberOfSamples = Math.round(mpegSize / this.frame_size) * this.samplesPerFrame;\r\n                    this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                    if (format.sampleRate && !format.duration) {\r\n                        const duration = numberOfSamples / format.sampleRate;\r\n                        debug(\"Calculate CBR duration based on file size: %s\", duration);\r\n                        this.metadata.setFormat('duration', duration);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    async sync() {\r\n        let gotFirstSync = false;\r\n        while (true) {\r\n            let bo = 0;\r\n            this.syncPeek.len = await this.tokenizer.peekBuffer(this.syncPeek.buf, { length: maxPeekLen, mayBeLess: true });\r\n            if (this.syncPeek.len <= 163) {\r\n                throw new EndOfStreamError();\r\n            }\r\n            while (true) {\r\n                if (gotFirstSync && (this.syncPeek.buf[bo] & 0xE0) === 0xE0) {\r\n                    this.buf_frame_header[0] = MpegFrameHeader.SyncByte1;\r\n                    this.buf_frame_header[1] = this.syncPeek.buf[bo];\r\n                    await this.tokenizer.ignore(bo);\r\n                    debug(`Sync at offset=${this.tokenizer.position - 1}, frameCount=${this.frameCount}`);\r\n                    if (this.syncFrameCount === this.frameCount) {\r\n                        debug(`Re-synced MPEG stream, frameCount=${this.frameCount}`);\r\n                        this.frameCount = 0;\r\n                        this.frame_size = 0;\r\n                    }\r\n                    this.syncFrameCount = this.frameCount;\r\n                    return; // sync\r\n                }\r\n                gotFirstSync = false;\r\n                bo = this.syncPeek.buf.indexOf(MpegFrameHeader.SyncByte1, bo);\r\n                if (bo === -1) {\r\n                    if (this.syncPeek.len < this.syncPeek.buf.length) {\r\n                        throw new EndOfStreamError();\r\n                    }\r\n                    await this.tokenizer.ignore(this.syncPeek.len);\r\n                    break; // continue with next buffer\r\n                }\r\n                ++bo;\r\n                gotFirstSync = true;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Combined ADTS & MPEG (MP2 & MP3) header handling\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\r\n    async parseCommonMpegHeader() {\r\n        if (this.frameCount === 0) {\r\n            this.mpegOffset = this.tokenizer.position - 1;\r\n        }\r\n        await this.tokenizer.peekBuffer(this.buf_frame_header.subarray(1), { length: 3 });\r\n        let header;\r\n        try {\r\n            header = FrameHeader.get(this.buf_frame_header, 0);\r\n        }\r\n        catch (err) {\r\n            await this.tokenizer.ignore(1);\r\n            if (err instanceof Error) {\r\n                this.metadata.addWarning(`Parse error: ${err.message}`);\r\n                return false; // sync\r\n            }\r\n            throw err;\r\n        }\r\n        await this.tokenizer.ignore(3);\r\n        this.metadata.setFormat('container', header.container);\r\n        this.metadata.setFormat('codec', header.codec);\r\n        this.metadata.setFormat('lossless', false);\r\n        this.metadata.setFormat('sampleRate', header.samplingRate);\r\n        this.frameCount++;\r\n        return header.version !== null && header.version >= 2 && header.layer === 0 ? this.parseAdts(header) : this.parseAudioFrameHeader(header);\r\n    }\r\n    /**\r\n     * @return {Promise<boolean>} true if parser should quit\r\n     */\r\n    async parseAudioFrameHeader(header) {\r\n        this.metadata.setFormat('numberOfChannels', header.channelMode === 'mono' ? 1 : 2);\r\n        this.metadata.setFormat('bitrate', header.bitrate);\r\n        if (this.frameCount < 20 * 10000) {\r\n            debug('offset=%s MP%s bitrate=%s sample-rate=%s', this.tokenizer.position - 4, header.layer, header.bitrate, header.samplingRate);\r\n        }\r\n        const slot_size = header.calcSlotSize();\r\n        if (slot_size === null) {\r\n            throw new MpegContentError('invalid slot_size');\r\n        }\r\n        const samples_per_frame = header.calcSamplesPerFrame();\r\n        debug(`samples_per_frame=${samples_per_frame}`);\r\n        const bps = samples_per_frame / 8.0;\r\n        if (header.bitrate !== null && header.samplingRate != null) {\r\n            const fsize = (bps * header.bitrate / header.samplingRate) + ((header.padding) ? slot_size : 0);\r\n            this.frame_size = Math.floor(fsize);\r\n        }\r\n        this.audioFrameHeader = header;\r\n        if (header.bitrate !== null) {\r\n            this.bitrates.push(header.bitrate);\r\n        }\r\n        // xtra header only exists in first frame\r\n        if (this.frameCount === 1) {\r\n            this.offset = FrameHeader.len;\r\n            await this.skipSideInformation();\r\n            return false;\r\n        }\r\n        if (this.frameCount === 4) {\r\n            // the stream is CBR if the first 3 frame bitrates are the same\r\n            if (this.areAllSame(this.bitrates)) {\r\n                // Actual calculation will be done in finalize\r\n                this.samplesPerFrame = samples_per_frame;\r\n                this.metadata.setFormat('codecProfile', 'CBR');\r\n                if (this.tokenizer.fileInfo.size)\r\n                    return true; // Will calculate duration based on the file size\r\n            }\r\n            else if (this.metadata.format.duration) {\r\n                return true; // We already got the duration, stop processing MPEG stream any further\r\n            }\r\n            if (!this.options.duration) {\r\n                return true; // Enforce duration not enabled, stop processing entire stream\r\n            }\r\n        }\r\n        // once we know the file is VBR attach listener to end of\r\n        // stream so we can do the duration calculation when we\r\n        // have counted all the frames\r\n        if (this.options.duration && this.frameCount === 4) {\r\n            this.samplesPerFrame = samples_per_frame;\r\n            this.calculateEofDuration = true;\r\n        }\r\n        this.offset = 4;\r\n        if (header.isProtectedByCRC) {\r\n            await this.parseCrc();\r\n            return false;\r\n        }\r\n        await this.skipSideInformation();\r\n        return false;\r\n    }\r\n    async parseAdts(header) {\r\n        const buf = new Uint8Array(3);\r\n        await this.tokenizer.readBuffer(buf);\r\n        header.frameLength += common.getBitAllignedNumber(buf, 0, 0, 11);\r\n        this.totalDataLength += header.frameLength;\r\n        this.samplesPerFrame = 1024;\r\n        if (header.samplingRate !== null) {\r\n            const framesPerSec = header.samplingRate / this.samplesPerFrame;\r\n            const bytesPerFrame = this.frameCount === 0 ? 0 : this.totalDataLength / this.frameCount;\r\n            const bitrate = 8 * bytesPerFrame * framesPerSec + 0.5;\r\n            this.metadata.setFormat('bitrate', bitrate);\r\n            debug(`frame-count=${this.frameCount}, size=${header.frameLength} bytes, bit-rate=${bitrate}`);\r\n        }\r\n        await this.tokenizer.ignore(header.frameLength > 7 ? header.frameLength - 7 : 1);\r\n        // Consume remaining header and frame data\r\n        if (this.frameCount === 3) {\r\n            this.metadata.setFormat('codecProfile', header.codecProfile);\r\n            if (header.mp4ChannelConfig) {\r\n                this.metadata.setFormat('numberOfChannels', header.mp4ChannelConfig.length);\r\n            }\r\n            if (this.options.duration) {\r\n                this.calculateEofDuration = true;\r\n            }\r\n            else {\r\n                return true; // Stop parsing after the third frame\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    async parseCrc() {\r\n        this.crc = await this.tokenizer.readNumber(Token.INT16_BE);\r\n        this.offset += 2;\r\n        return this.skipSideInformation();\r\n    }\r\n    async skipSideInformation() {\r\n        if (this.audioFrameHeader) {\r\n            const sideinfo_length = this.audioFrameHeader.calculateSideInfoLength();\r\n            if (sideinfo_length !== null) {\r\n                await this.tokenizer.readToken(new Token.Uint8ArrayType(sideinfo_length));\r\n                // side information\r\n                this.offset += sideinfo_length;\r\n                await this.readXtraInfoHeader();\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    async readXtraInfoHeader() {\r\n        const headerTag = await this.tokenizer.readToken(InfoTagHeaderTag);\r\n        this.offset += InfoTagHeaderTag.len; // 12\r\n        switch (headerTag) {\r\n            case 'Info':\r\n                this.metadata.setFormat('codecProfile', 'CBR');\r\n                return this.readXingInfoHeader();\r\n            case 'Xing': {\r\n                const infoTag = await this.readXingInfoHeader();\r\n                if (infoTag.vbrScale !== null) {\r\n                    const codecProfile = getVbrCodecProfile(infoTag.vbrScale);\r\n                    this.metadata.setFormat('codecProfile', codecProfile);\r\n                }\r\n                return null;\r\n            }\r\n            case 'Xtra':\r\n                // ToDo: ???\r\n                break;\r\n            case 'LAME': {\r\n                const version = await this.tokenizer.readToken(LameEncoderVersion);\r\n                if (this.frame_size !== null && this.frame_size >= this.offset + LameEncoderVersion.len) {\r\n                    this.offset += LameEncoderVersion.len;\r\n                    this.metadata.setFormat('tool', `LAME ${version}`);\r\n                    await this.skipFrameData(this.frame_size - this.offset);\r\n                    return null;\r\n                }\r\n                this.metadata.addWarning('Corrupt LAME header');\r\n                break;\r\n            }\r\n            // ToDo: ???\r\n        }\r\n        // ToDo: promise duration???\r\n        const frameDataLeft = this.frame_size - this.offset;\r\n        if (frameDataLeft < 0) {\r\n            this.metadata.addWarning(`Frame ${this.frameCount}corrupt: negative frameDataLeft`);\r\n        }\r\n        else {\r\n            await this.skipFrameData(frameDataLeft);\r\n        }\r\n        return null;\r\n    }\r\n    /**\r\n     * Ref: http://gabriel.mp3-tech.org/mp3infotag.html\r\n     * @returns {Promise<string>}\r\n     */\r\n    async readXingInfoHeader() {\r\n        const offset = this.tokenizer.position;\r\n        const infoTag = await readXingHeader(this.tokenizer);\r\n        this.offset += this.tokenizer.position - offset;\r\n        if (infoTag.lame) {\r\n            this.metadata.setFormat('tool', `LAME ${common.stripNulls(infoTag.lame.version)}`);\r\n            if (infoTag.lame.extended) {\r\n                // this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain);\r\n                this.metadata.setFormat('trackPeakLevel', infoTag.lame.extended.track_peak);\r\n                if (infoTag.lame.extended.track_gain) {\r\n                    this.metadata.setFormat('trackGain', infoTag.lame.extended.track_gain.adjustment);\r\n                }\r\n                if (infoTag.lame.extended.album_gain) {\r\n                    this.metadata.setFormat('albumGain', infoTag.lame.extended.album_gain.adjustment);\r\n                }\r\n                this.metadata.setFormat('duration', infoTag.lame.extended.music_length / 1000);\r\n            }\r\n        }\r\n        if (infoTag.streamSize && this.audioFrameHeader && infoTag.numFrames !== null) {\r\n            const duration = this.audioFrameHeader.calcDuration(infoTag.numFrames);\r\n            this.metadata.setFormat('duration', duration);\r\n            debug('Get duration from Xing header: %s', this.metadata.format.duration);\r\n            return infoTag;\r\n        }\r\n        // frames field is not present\r\n        const frameDataLeft = this.frame_size - this.offset;\r\n        await this.skipFrameData(frameDataLeft);\r\n        return infoTag;\r\n    }\r\n    async skipFrameData(frameDataLeft) {\r\n        if (frameDataLeft < 0)\r\n            throw new MpegContentError('frame-data-left cannot be negative');\r\n        await this.tokenizer.ignore(frameDataLeft);\r\n        this.countSkipFrameData += frameDataLeft;\r\n    }\r\n    areAllSame(array) {\r\n        const first = array[0];\r\n        return array.every(element => {\r\n            return element === first;\r\n        });\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}