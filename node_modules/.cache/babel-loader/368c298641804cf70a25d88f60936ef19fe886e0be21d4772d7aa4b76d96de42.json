{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { StringType } from 'token-types';\nexport function stringToBytes(string, encoding) {\n  if (encoding === 'utf-16le') {\n    const bytes = [];\n    for (let index = 0; index < string.length; index++) {\n      const code = string.charCodeAt(index); // eslint-disable-line unicorn/prefer-code-point\n      bytes.push(code & 0xFF, code >> 8 & 0xFF); // High byte\n    }\n    return bytes;\n  }\n  if (encoding === 'utf-16be') {\n    const bytes = [];\n    for (let index = 0; index < string.length; index++) {\n      const code = string.charCodeAt(index); // eslint-disable-line unicorn/prefer-code-point\n      bytes.push(code >> 8 & 0xFF, code & 0xFF); // Low byte\n    }\n    return bytes;\n  }\n  return [...string].map(character => character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point\n}\n\n/**\nChecks whether the TAR checksum is valid.\n\n@param {Uint8Array} arrayBuffer - The TAR header `[offset ... offset + 512]`.\n@param {number} offset - TAR header offset.\n@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n*/\nexport function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {\n  const readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n  if (Number.isNaN(readSum)) {\n    return false;\n  }\n  let sum = 8 * 0x20; // Initialize signed bit sum\n\n  for (let index = offset; index < offset + 148; index++) {\n    sum += arrayBuffer[index];\n  }\n  for (let index = offset + 156; index < offset + 512; index++) {\n    sum += arrayBuffer[index];\n  }\n  return readSum === sum;\n}\n\n/**\nID3 UINT32 sync-safe tokenizer token.\n28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n*/\nexport const uint32SyncSafeToken = {\n  get: (buffer, offset) => buffer[offset + 3] & 0x7F | buffer[offset + 2] << 7 | buffer[offset + 1] << 14 | buffer[offset] << 21,\n  len: 4\n};","map":{"version":3,"names":["StringType","stringToBytes","string","encoding","bytes","index","length","code","charCodeAt","push","map","character","tarHeaderChecksumMatches","arrayBuffer","offset","readSum","Number","parseInt","get","replace","trim","isNaN","sum","uint32SyncSafeToken","buffer","len"],"sources":["/home/kup/my_projects/vue/osi/node_modules/file-type/util.js"],"sourcesContent":["import {StringType} from 'token-types';\n\nexport function stringToBytes(string, encoding) {\n\tif (encoding === 'utf-16le') {\n\t\tconst bytes = [];\n\t\tfor (let index = 0; index < string.length; index++) {\n\t\t\tconst code = string.charCodeAt(index); // eslint-disable-line unicorn/prefer-code-point\n\t\t\tbytes.push(code & 0xFF, (code >> 8) & 0xFF); // High byte\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\tif (encoding === 'utf-16be') {\n\t\tconst bytes = [];\n\t\tfor (let index = 0; index < string.length; index++) {\n\t\t\tconst code = string.charCodeAt(index); // eslint-disable-line unicorn/prefer-code-point\n\t\t\tbytes.push((code >> 8) & 0xFF, code & 0xFF); // Low byte\n\t\t}\n\n\t\treturn bytes;\n\t}\n\n\treturn [...string].map(character => character.charCodeAt(0)); // eslint-disable-line unicorn/prefer-code-point\n}\n\n/**\nChecks whether the TAR checksum is valid.\n\n@param {Uint8Array} arrayBuffer - The TAR header `[offset ... offset + 512]`.\n@param {number} offset - TAR header offset.\n@returns {boolean} `true` if the TAR checksum is valid, otherwise `false`.\n*/\nexport function tarHeaderChecksumMatches(arrayBuffer, offset = 0) {\n\tconst readSum = Number.parseInt(new StringType(6).get(arrayBuffer, 148).replace(/\\0.*$/, '').trim(), 8); // Read sum in header\n\tif (Number.isNaN(readSum)) {\n\t\treturn false;\n\t}\n\n\tlet sum = 8 * 0x20; // Initialize signed bit sum\n\n\tfor (let index = offset; index < offset + 148; index++) {\n\t\tsum += arrayBuffer[index];\n\t}\n\n\tfor (let index = offset + 156; index < offset + 512; index++) {\n\t\tsum += arrayBuffer[index];\n\t}\n\n\treturn readSum === sum;\n}\n\n/**\nID3 UINT32 sync-safe tokenizer token.\n28 bits (representing up to 256MB) integer, the msb is 0 to avoid \"false syncsignals\".\n*/\nexport const uint32SyncSafeToken = {\n\tget: (buffer, offset) => (buffer[offset + 3] & 0x7F) | ((buffer[offset + 2]) << 7) | ((buffer[offset + 1]) << 14) | ((buffer[offset]) << 21),\n\tlen: 4,\n};\n"],"mappings":";AAAA,SAAQA,UAAU,QAAO,aAAa;AAEtC,OAAO,SAASC,aAAaA,CAACC,MAAM,EAAEC,QAAQ,EAAE;EAC/C,IAAIA,QAAQ,KAAK,UAAU,EAAE;IAC5B,MAAMC,KAAK,GAAG,EAAE;IAChB,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGH,MAAM,CAACI,MAAM,EAAED,KAAK,EAAE,EAAE;MACnD,MAAME,IAAI,GAAGL,MAAM,CAACM,UAAU,CAACH,KAAK,CAAC,CAAC,CAAC;MACvCD,KAAK,CAACK,IAAI,CAACF,IAAI,GAAG,IAAI,EAAGA,IAAI,IAAI,CAAC,GAAI,IAAI,CAAC,CAAC,CAAC;IAC9C;IAEA,OAAOH,KAAK;EACb;EAEA,IAAID,QAAQ,KAAK,UAAU,EAAE;IAC5B,MAAMC,KAAK,GAAG,EAAE;IAChB,KAAK,IAAIC,KAAK,GAAG,CAAC,EAAEA,KAAK,GAAGH,MAAM,CAACI,MAAM,EAAED,KAAK,EAAE,EAAE;MACnD,MAAME,IAAI,GAAGL,MAAM,CAACM,UAAU,CAACH,KAAK,CAAC,CAAC,CAAC;MACvCD,KAAK,CAACK,IAAI,CAAEF,IAAI,IAAI,CAAC,GAAI,IAAI,EAAEA,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC;IAC9C;IAEA,OAAOH,KAAK;EACb;EAEA,OAAO,CAAC,GAAGF,MAAM,CAAC,CAACQ,GAAG,CAACC,SAAS,IAAIA,SAAS,CAACH,UAAU,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,wBAAwBA,CAACC,WAAW,EAAEC,MAAM,GAAG,CAAC,EAAE;EACjE,MAAMC,OAAO,GAAGC,MAAM,CAACC,QAAQ,CAAC,IAAIjB,UAAU,CAAC,CAAC,CAAC,CAACkB,GAAG,CAACL,WAAW,EAAE,GAAG,CAAC,CAACM,OAAO,CAAC,OAAO,EAAE,EAAE,CAAC,CAACC,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;EACzG,IAAIJ,MAAM,CAACK,KAAK,CAACN,OAAO,CAAC,EAAE;IAC1B,OAAO,KAAK;EACb;EAEA,IAAIO,GAAG,GAAG,CAAC,GAAG,IAAI,CAAC,CAAC;;EAEpB,KAAK,IAAIjB,KAAK,GAAGS,MAAM,EAAET,KAAK,GAAGS,MAAM,GAAG,GAAG,EAAET,KAAK,EAAE,EAAE;IACvDiB,GAAG,IAAIT,WAAW,CAACR,KAAK,CAAC;EAC1B;EAEA,KAAK,IAAIA,KAAK,GAAGS,MAAM,GAAG,GAAG,EAAET,KAAK,GAAGS,MAAM,GAAG,GAAG,EAAET,KAAK,EAAE,EAAE;IAC7DiB,GAAG,IAAIT,WAAW,CAACR,KAAK,CAAC;EAC1B;EAEA,OAAOU,OAAO,KAAKO,GAAG;AACvB;;AAEA;AACA;AACA;AACA;AACA,OAAO,MAAMC,mBAAmB,GAAG;EAClCL,GAAG,EAAEA,CAACM,MAAM,EAAEV,MAAM,KAAMU,MAAM,CAACV,MAAM,GAAG,CAAC,CAAC,GAAG,IAAI,GAAMU,MAAM,CAACV,MAAM,GAAG,CAAC,CAAC,IAAK,CAAE,GAAKU,MAAM,CAACV,MAAM,GAAG,CAAC,CAAC,IAAK,EAAG,GAAKU,MAAM,CAACV,MAAM,CAAC,IAAK,EAAG;EAC5IW,GAAG,EAAE;AACN,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}