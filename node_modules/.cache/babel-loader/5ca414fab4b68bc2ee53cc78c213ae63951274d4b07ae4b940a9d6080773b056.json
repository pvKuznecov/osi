{"ast":null,"code":"export default {\n  name: \"SimpleWindow\",\n  props: {\n    windowId: String,\n    title: {\n      type: String,\n      default: 'Окно'\n    },\n    appName: {\n      type: String,\n      default: 'app'\n    },\n    isMinimized: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: false\n    },\n    isMaximized: {\n      type: Boolean,\n      default: false\n    }\n  },\n  emits: ['close', 'minimize', 'focus', 'toggleMaximize'],\n  data() {\n    return {\n      posX: 100,\n      posY: 100,\n      windowWidth: 400,\n      windowHeight: 300,\n      isDragging: false,\n      isResizing: false,\n      dragOffset: {\n        x: 0,\n        y: 0\n      },\n      resizeDirection: '',\n      originalState: null,\n      // Настройки прилипания\n      snapThreshold: 15,\n      // Расстояние в пикселях для прилипания\n      isSnapped: false // Флаг прилипания\n    };\n  },\n  computed: {\n    isVisible() {\n      return !this.isMinimized;\n    },\n    windowStyles() {\n      const baseStyles = {\n        zIndex: this.isActive ? 1000 : 100\n      };\n      if (this.isMaximized) {\n        return {\n          ...baseStyles,\n          left: '0',\n          top: '0',\n          width: '100vw',\n          height: '100vh',\n          borderRadius: '0',\n          opacity: this.isActive ? 1 : 0.9 // Добавляем прозрачность для неактивных\n        };\n      } else {\n        return {\n          ...baseStyles,\n          left: `${this.posX}px`,\n          top: `${this.posY}px`,\n          width: `${this.windowWidth}px`,\n          height: `${this.windowHeight}px`,\n          opacity: this.isActive ? 1 : 0.85 // Добавляем прозрачность для неактивных\n        };\n      }\n    }\n  },\n  watch: {\n    isMaximized(newVal) {\n      if (newVal && !this.originalState) {\n        this.saveOriginalState();\n      } else if (!newVal && this.originalState) {\n        this.restoreOriginalState();\n      }\n    }\n  },\n  mounted() {\n    document.addEventListener('mousemove', this.handleMouseMove);\n    document.addEventListener('mouseup', this.handleMouseUp);\n    this.keepWindowInBounds();\n  },\n  beforeUnmount() {\n    document.removeEventListener('mousemove', this.handleMouseMove);\n    document.removeEventListener('mouseup', this.handleMouseUp);\n  },\n  methods: {\n    onHeaderMouseDown(e) {\n      // console.log('Клик по заголовку окна:', this.windowId, 'Активно:', this.isActive)\n      this.$emit('focus', this.windowId);\n      if (this.isMaximized) {\n        return;\n      }\n      this.startDrag(e);\n    },\n    onContentMouseDown(e) {\n      // console.log('Клик по содержимому окна:', this.windowId, 'Активно:', this.isActive)\n      this.$emit('focus', this.windowId);\n    },\n    saveOriginalState() {\n      this.originalState = {\n        posX: this.posX,\n        posY: this.posY,\n        windowWidth: this.windowWidth,\n        windowHeight: this.windowHeight\n      };\n    },\n    restoreOriginalState() {\n      if (this.originalState) {\n        this.posX = this.originalState.posX;\n        this.posY = this.originalState.posY;\n        this.windowWidth = this.originalState.windowWidth;\n        this.windowHeight = this.originalState.windowHeight;\n        this.keepWindowInBounds();\n      }\n    },\n    focusWindow(e) {\n      // Всегда эмитим событие фокуса при клике на окно\n      this.$emit('focus', this.windowId);\n\n      // Проверяем, нужно ли начинать перетаскивание\n      if (this.isMaximized || !e.target.closest('.window-header')) {\n        // Если кликнули не на заголовок или окно максимизировано,\n        // просто активируем окно без перетаскивания\n        return;\n      }\n\n      // Если кликнули на заголовок и окно не максимизировано - начинаем перетаскивание\n      this.startDrag(e);\n    },\n    startDrag(e) {\n      this.isDragging = true;\n      this.dragOffset = {\n        x: e.clientX - this.posX,\n        y: e.clientY - this.posY\n      };\n    },\n    startResize(direction) {\n      if (this.isMaximized) return;\n      this.isResizing = true;\n      this.resizeDirection = direction;\n      this.resizeStartX = this.posX;\n      this.resizeStartY = this.posY;\n      this.resizeStartWidth = this.windowWidth;\n      this.resizeStartHeight = this.windowHeight;\n      this.resizeStartMouseX = event.clientX;\n      this.resizeStartMouseY = event.clientY;\n    },\n    handleMouseMove(e) {\n      if (this.isDragging && !this.isMaximized) {\n        // Рассчитываем новую позицию\n        let newX = e.clientX - this.dragOffset.x;\n        let newY = e.clientY - this.dragOffset.y;\n\n        // ПРИЛИПАНИЕ К ГРАНИЦАМ ВО ВРЕМЯ ПЕРЕТАСКИВАНИЯ\n        const snappedPosition = this.checkSnap(newX, newY);\n        newX = snappedPosition.x;\n        newY = snappedPosition.y;\n        this.posX = newX;\n        this.posY = newY;\n\n        // Проверяем, чтобы окно не уходило за экран во время перетаскивания\n        this.preventOffscreenDuringDrag();\n      } else if (this.isResizing && !this.isMaximized) {\n        this.handleResize(e);\n      }\n    },\n    // ПРОВЕРКА ПРИЛИПАНИЯ К ГРАНИЦАМ\n    checkSnap(x, y) {\n      const screenWidth = window.innerWidth;\n      const screenHeight = window.innerHeight;\n      let snappedX = x;\n      let snappedY = y;\n      this.isSnapped = false;\n\n      // Прилипание к левому краю\n      if (Math.abs(x) < this.snapThreshold) {\n        snappedX = 0;\n        this.isSnapped = true;\n      }\n\n      // Прилипание к правому краю\n      if (Math.abs(x + this.windowWidth - screenWidth) < this.snapThreshold) {\n        snappedX = screenWidth - this.windowWidth;\n        this.isSnapped = true;\n      }\n\n      // Прилипание к верхнему краю\n      if (Math.abs(y) < this.snapThreshold) {\n        snappedY = 0;\n        this.isSnapped = true;\n      }\n\n      // Прилипание к нижнему краю\n      if (Math.abs(y + this.windowHeight - screenHeight) < this.snapThreshold) {\n        snappedY = screenHeight - this.windowHeight;\n        this.isSnapped = true;\n      }\n      return {\n        x: snappedX,\n        y: snappedY\n      };\n    },\n    // ПРЕДОТВРАЩЕНИЕ ВЫХОДА ЗА ЭКРАН ВО ВРЕМЯ ПЕРЕТАСКИВАНИЯ\n    preventOffscreenDuringDrag() {\n      const screenWidth = window.innerWidth;\n      const screenHeight = window.innerHeight;\n\n      // Не даем уйти левее экрана\n      if (this.posX < 0) {\n        this.posX = 0;\n      }\n\n      // Не даем уйти правее экрана\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.posX = screenWidth - this.windowWidth;\n      }\n\n      // Не даем уйти выше экрана\n      if (this.posY < 0) {\n        this.posY = 0;\n      }\n\n      // Не даем уйти ниже экрана\n      if (this.posY + this.windowHeight > screenHeight) {\n        this.posY = screenHeight - this.windowHeight;\n      }\n    },\n    handleResize(e) {\n      const deltaX = e.clientX - this.resizeStartMouseX;\n      const deltaY = e.clientY - this.resizeStartMouseY;\n      const minWidth = 200;\n      const minHeight = 150;\n      let newWidth = this.resizeStartWidth;\n      let newHeight = this.resizeStartHeight;\n      let newX = this.resizeStartX;\n      let newY = this.resizeStartY;\n      if (this.resizeDirection.includes('e')) {\n        newWidth = Math.max(minWidth, this.resizeStartWidth + deltaX);\n      }\n      if (this.resizeDirection.includes('w')) {\n        // const widthChange = this.resizeStartWidth - Math.max(minWidth, this.resizeStartWidth - deltaX)\n        newWidth = Math.max(minWidth, this.resizeStartWidth - deltaX);\n        newX = this.resizeStartX + (this.resizeStartWidth - newWidth);\n      }\n      if (this.resizeDirection.includes('s')) {\n        newHeight = Math.max(minHeight, this.resizeStartHeight + deltaY);\n      }\n      if (this.resizeDirection.includes('n')) {\n        // const heightChange = this.resizeStartHeight - Math.max(minHeight, this.resizeStartHeight - deltaY)\n        newHeight = Math.max(minHeight, this.resizeStartHeight - deltaY);\n        newY = this.resizeStartY + (this.resizeStartHeight - newHeight);\n      }\n\n      // Применяем изменения\n      this.posX = newX;\n      this.posY = newY;\n      this.windowWidth = newWidth;\n      this.windowHeight = newHeight;\n\n      // Проверяем границы\n      this.keepResizeInBounds();\n    },\n    keepResizeInBounds() {\n      const minWidth = 200;\n      const minHeight = 150;\n      const screenWidth = window.innerWidth;\n      const screenHeight = window.innerHeight;\n\n      // Проверяем, чтобы окно не выходило за правый и нижний края\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.windowWidth = screenWidth - this.posX;\n      }\n      if (this.posY + this.windowHeight > screenHeight) {\n        this.windowHeight = screenHeight - this.posY;\n      }\n\n      // Проверяем минимальные размеры\n      this.windowWidth = Math.max(minWidth, this.windowWidth);\n      this.windowHeight = Math.max(minHeight, this.windowHeight);\n\n      // Если окно слишком широкое/высокое, корректируем позицию\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.posX = screenWidth - this.windowWidth;\n      }\n      if (this.posY + this.windowHeight > screenHeight) {\n        this.posY = screenHeight - this.windowHeight;\n      }\n\n      // Не даем уйти за левый и верхний края\n      this.posX = Math.max(0, this.posX);\n      this.posY = Math.max(0, this.posY);\n\n      // Проверяем, чтобы размеры не стали меньше минимальных\n      if (this.windowWidth < minWidth) {\n        this.windowWidth = minWidth;\n      }\n      if (this.windowHeight < minHeight) {\n        this.windowHeight = minHeight;\n      }\n    },\n    handleMouseUp() {\n      if (this.isDragging) {\n        // При отпускании мыши финальная проверка границ\n        this.keepWindowInBounds();\n\n        // Если окно было \"прилипшим\", убираем прилипание при следующем перетаскивании\n        this.isSnapped = false;\n      }\n      if (this.isResizing) {\n        this.keepResizeInBounds();\n      }\n      this.isDragging = false;\n      this.isResizing = false;\n    },\n    // ФИНАЛЬНАЯ ПРОВЕРКА ГРАНИЦ ПРИ ОТПУСКАНИИ\n    keepWindowInBounds() {\n      const minWidth = 200;\n      const minHeight = 150;\n      const screenWidth = window.innerWidth;\n      const screenHeight = window.innerHeight;\n\n      // Гарантируем минимальные размеры\n      this.windowWidth = Math.max(minWidth, this.windowWidth);\n      this.windowHeight = Math.max(minHeight, this.windowHeight);\n\n      // Не даем окну выйти за правую границу\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.posX = screenWidth - this.windowWidth;\n      }\n\n      // Не даем окну выйти за нижнюю границу\n      if (this.posY + this.windowHeight > screenHeight) {\n        this.posY = screenHeight - this.windowHeight;\n      }\n\n      // Не даем уйти за левую и верхнюю границы\n      this.posX = Math.max(0, this.posX);\n      this.posY = Math.max(0, this.posY);\n\n      // Если после всех проверок окно всё равно вылезает, уменьшаем его\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.windowWidth = screenWidth - this.posX;\n      }\n      if (this.posY + this.windowHeight > screenHeight) {\n        this.windowHeight = screenHeight - this.posY;\n      }\n\n      // Еще раз проверяем минимальные размеры\n      this.windowWidth = Math.max(minWidth, this.windowWidth);\n      this.windowHeight = Math.max(minHeight, this.windowHeight);\n\n      // Если окно слишком маленькое, центрируем его\n      if (this.windowWidth < minWidth) {\n        this.windowWidth = minWidth;\n        this.posX = Math.max(0, Math.min(this.posX, screenWidth - minWidth));\n      }\n      if (this.windowHeight < minHeight) {\n        this.windowHeight = minHeight;\n        this.posY = Math.max(0, Math.min(this.posY, screenHeight - minHeight));\n      }\n    },\n    minimize() {\n      this.$emit('minimize', this.windowId);\n    },\n    toggleMaximize() {\n      this.$emit('toggleMaximize', this.windowId);\n    },\n    close() {\n      this.$emit('close', this.windowId);\n    },\n    // Дополнительно: двойной клик по заголовку для максимизации\n    handleDoubleClick(e) {\n      if (e.target.closest('.window-header') && !e.target.closest('.window-controls')) {\n        this.toggleMaximize();\n      }\n    }\n  }\n};","map":{"version":3,"names":["name","props","windowId","String","title","type","default","appName","isMinimized","Boolean","isActive","isMaximized","emits","data","posX","posY","windowWidth","windowHeight","isDragging","isResizing","dragOffset","x","y","resizeDirection","originalState","snapThreshold","isSnapped","computed","isVisible","windowStyles","baseStyles","zIndex","left","top","width","height","borderRadius","opacity","watch","newVal","saveOriginalState","restoreOriginalState","mounted","document","addEventListener","handleMouseMove","handleMouseUp","keepWindowInBounds","beforeUnmount","removeEventListener","methods","onHeaderMouseDown","e","$emit","startDrag","onContentMouseDown","focusWindow","target","closest","clientX","clientY","startResize","direction","resizeStartX","resizeStartY","resizeStartWidth","resizeStartHeight","resizeStartMouseX","event","resizeStartMouseY","newX","newY","snappedPosition","checkSnap","preventOffscreenDuringDrag","handleResize","screenWidth","window","innerWidth","screenHeight","innerHeight","snappedX","snappedY","Math","abs","deltaX","deltaY","minWidth","minHeight","newWidth","newHeight","includes","max","keepResizeInBounds","min","minimize","toggleMaximize","close","handleDoubleClick"],"sources":["/home/kup/my_projects/vue/osi/src/components/os/SimpleWindow/SimpleWindow.vue"],"sourcesContent":["<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script>\n    export default {\n  name: \"SimpleWindow\",\n  \n  props: {\n    windowId: String,\n    title: {\n      type: String,\n      default: 'Окно'\n    },\n    appName: {\n      type: String,\n      default: 'app'\n    },\n    isMinimized: {\n      type: Boolean,\n      default: false\n    },\n    isActive: {\n      type: Boolean,\n      default: false\n    },\n    isMaximized: {\n      type: Boolean,\n      default: false\n    }\n  },\n  \n  emits: ['close', 'minimize', 'focus', 'toggleMaximize'],\n  \n  data() {\n    return {\n      posX: 100,\n      posY: 100,\n      windowWidth: 400,\n      windowHeight: 300,\n      isDragging: false,\n      isResizing: false,\n      dragOffset: { x: 0, y: 0 },\n      resizeDirection: '',\n      originalState: null,\n      \n      // Настройки прилипания\n      snapThreshold: 15, // Расстояние в пикселях для прилипания\n      isSnapped: false   // Флаг прилипания\n    }\n  },\n  \n computed: {\n    isVisible() {\n      return !this.isMinimized\n    },\n    \n    windowStyles() {\n      const baseStyles = {\n        zIndex: this.isActive ? 1000 : 100\n      }\n      \n      if (this.isMaximized) {\n        return {\n          ...baseStyles,\n          left: '0',\n          top: '0',\n          width: '100vw',\n          height: '100vh',\n          borderRadius: '0',\n          opacity: this.isActive ? 1 : 0.9 // Добавляем прозрачность для неактивных\n        }\n      } else {\n        return {\n          ...baseStyles,\n          left: `${this.posX}px`,\n          top: `${this.posY}px`,\n          width: `${this.windowWidth}px`,\n          height: `${this.windowHeight}px`,\n          opacity: this.isActive ? 1 : 0.85 // Добавляем прозрачность для неактивных\n        }\n      }\n    }\n  },\n  \n  watch: {\n    isMaximized(newVal) {\n      if (newVal && !this.originalState) {\n        this.saveOriginalState()\n      } else if (!newVal && this.originalState) {\n        this.restoreOriginalState()\n      }\n    }\n  },\n  \n  mounted() {\n    document.addEventListener('mousemove', this.handleMouseMove)\n    document.addEventListener('mouseup', this.handleMouseUp)\n    \n    this.keepWindowInBounds()\n  },\n  \n  beforeUnmount() {\n    document.removeEventListener('mousemove', this.handleMouseMove)\n    document.removeEventListener('mouseup', this.handleMouseUp)\n  },\n  \n  methods: {\n    onHeaderMouseDown(e) {\n  // console.log('Клик по заголовку окна:', this.windowId, 'Активно:', this.isActive)\n  this.$emit('focus', this.windowId)\n  \n  if (this.isMaximized) {\n    return\n  }\n  \n  this.startDrag(e)\n},\n\nonContentMouseDown(e) {\n  // console.log('Клик по содержимому окна:', this.windowId, 'Активно:', this.isActive)\n  this.$emit('focus', this.windowId)\n},\n    saveOriginalState() {\n      this.originalState = {\n        posX: this.posX,\n        posY: this.posY,\n        windowWidth: this.windowWidth,\n        windowHeight: this.windowHeight\n      }\n    },\n    \n    restoreOriginalState() {\n      if (this.originalState) {\n        this.posX = this.originalState.posX\n        this.posY = this.originalState.posY\n        this.windowWidth = this.originalState.windowWidth\n        this.windowHeight = this.originalState.windowHeight\n        \n        this.keepWindowInBounds()\n      }\n    },\n    \n    focusWindow(e) {\n      // Всегда эмитим событие фокуса при клике на окно\n      this.$emit('focus', this.windowId)\n      \n      // Проверяем, нужно ли начинать перетаскивание\n      if (this.isMaximized || !e.target.closest('.window-header')) {\n        // Если кликнули не на заголовок или окно максимизировано,\n        // просто активируем окно без перетаскивания\n        return\n      }\n      \n      // Если кликнули на заголовок и окно не максимизировано - начинаем перетаскивание\n      this.startDrag(e)\n    },\n    \n    startDrag(e) {\n      this.isDragging = true\n      this.dragOffset = {\n        x: e.clientX - this.posX,\n        y: e.clientY - this.posY\n      }\n    },\n    \n    startResize(direction) {\n      if (this.isMaximized) return\n      \n      this.isResizing = true\n      this.resizeDirection = direction\n      this.resizeStartX = this.posX\n      this.resizeStartY = this.posY\n      this.resizeStartWidth = this.windowWidth\n      this.resizeStartHeight = this.windowHeight\n      this.resizeStartMouseX = event.clientX\n      this.resizeStartMouseY = event.clientY\n    },\n    \n    handleMouseMove(e) {\n      if (this.isDragging && !this.isMaximized) {\n        // Рассчитываем новую позицию\n        let newX = e.clientX - this.dragOffset.x\n        let newY = e.clientY - this.dragOffset.y\n        \n        // ПРИЛИПАНИЕ К ГРАНИЦАМ ВО ВРЕМЯ ПЕРЕТАСКИВАНИЯ\n        const snappedPosition = this.checkSnap(newX, newY)\n        newX = snappedPosition.x\n        newY = snappedPosition.y\n        \n        this.posX = newX\n        this.posY = newY\n        \n        // Проверяем, чтобы окно не уходило за экран во время перетаскивания\n        this.preventOffscreenDuringDrag()\n        \n      } else if (this.isResizing && !this.isMaximized) {\n        this.handleResize(e)\n      }\n    },\n    \n    // ПРОВЕРКА ПРИЛИПАНИЯ К ГРАНИЦАМ\n    checkSnap(x, y) {\n      const screenWidth = window.innerWidth\n      const screenHeight = window.innerHeight\n      \n      let snappedX = x\n      let snappedY = y\n      this.isSnapped = false\n      \n      // Прилипание к левому краю\n      if (Math.abs(x) < this.snapThreshold) {\n        snappedX = 0\n        this.isSnapped = true\n      }\n      \n      // Прилипание к правому краю\n      if (Math.abs(x + this.windowWidth - screenWidth) < this.snapThreshold) {\n        snappedX = screenWidth - this.windowWidth\n        this.isSnapped = true\n      }\n      \n      // Прилипание к верхнему краю\n      if (Math.abs(y) < this.snapThreshold) {\n        snappedY = 0\n        this.isSnapped = true\n      }\n      \n      // Прилипание к нижнему краю\n      if (Math.abs(y + this.windowHeight - screenHeight) < this.snapThreshold) {\n        snappedY = screenHeight - this.windowHeight\n        this.isSnapped = true\n      }\n      \n      return { x: snappedX, y: snappedY }\n    },\n    \n    // ПРЕДОТВРАЩЕНИЕ ВЫХОДА ЗА ЭКРАН ВО ВРЕМЯ ПЕРЕТАСКИВАНИЯ\n    preventOffscreenDuringDrag() {\n      const screenWidth = window.innerWidth\n      const screenHeight = window.innerHeight\n      \n      // Не даем уйти левее экрана\n      if (this.posX < 0) {\n        this.posX = 0\n      }\n      \n      // Не даем уйти правее экрана\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.posX = screenWidth - this.windowWidth\n      }\n      \n      // Не даем уйти выше экрана\n      if (this.posY < 0) {\n        this.posY = 0\n      }\n      \n      // Не даем уйти ниже экрана\n      if (this.posY + this.windowHeight > screenHeight) {\n        this.posY = screenHeight - this.windowHeight\n      }\n    },\n    \n    handleResize(e) {\n      const deltaX = e.clientX - this.resizeStartMouseX\n      const deltaY = e.clientY - this.resizeStartMouseY\n      \n      const minWidth = 200\n      const minHeight = 150\n      \n      let newWidth = this.resizeStartWidth\n      let newHeight = this.resizeStartHeight\n      let newX = this.resizeStartX\n      let newY = this.resizeStartY\n      \n      if (this.resizeDirection.includes('e')) {\n        newWidth = Math.max(minWidth, this.resizeStartWidth + deltaX)\n      }\n      \n      if (this.resizeDirection.includes('w')) {\n        // const widthChange = this.resizeStartWidth - Math.max(minWidth, this.resizeStartWidth - deltaX)\n        newWidth = Math.max(minWidth, this.resizeStartWidth - deltaX)\n        newX = this.resizeStartX + (this.resizeStartWidth - newWidth)\n      }\n      \n      if (this.resizeDirection.includes('s')) {\n        newHeight = Math.max(minHeight, this.resizeStartHeight + deltaY)\n      }\n      \n      if (this.resizeDirection.includes('n')) {\n        // const heightChange = this.resizeStartHeight - Math.max(minHeight, this.resizeStartHeight - deltaY)\n        newHeight = Math.max(minHeight, this.resizeStartHeight - deltaY)\n        newY = this.resizeStartY + (this.resizeStartHeight - newHeight)\n      }\n      \n      // Применяем изменения\n      this.posX = newX\n      this.posY = newY\n      this.windowWidth = newWidth\n      this.windowHeight = newHeight\n      \n      // Проверяем границы\n      this.keepResizeInBounds()\n    },\n    \n    keepResizeInBounds() {\n      const minWidth = 200\n      const minHeight = 150\n      const screenWidth = window.innerWidth\n      const screenHeight = window.innerHeight\n      \n      // Проверяем, чтобы окно не выходило за правый и нижний края\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.windowWidth = screenWidth - this.posX\n      }\n      \n      if (this.posY + this.windowHeight > screenHeight) {\n        this.windowHeight = screenHeight - this.posY\n      }\n      \n      // Проверяем минимальные размеры\n      this.windowWidth = Math.max(minWidth, this.windowWidth)\n      this.windowHeight = Math.max(minHeight, this.windowHeight)\n      \n      // Если окно слишком широкое/высокое, корректируем позицию\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.posX = screenWidth - this.windowWidth\n      }\n      \n      if (this.posY + this.windowHeight > screenHeight) {\n        this.posY = screenHeight - this.windowHeight\n      }\n      \n      // Не даем уйти за левый и верхний края\n      this.posX = Math.max(0, this.posX)\n      this.posY = Math.max(0, this.posY)\n      \n      // Проверяем, чтобы размеры не стали меньше минимальных\n      if (this.windowWidth < minWidth) {\n        this.windowWidth = minWidth\n      }\n      \n      if (this.windowHeight < minHeight) {\n        this.windowHeight = minHeight\n      }\n    },\n    \n    handleMouseUp() {\n      if (this.isDragging) {\n        // При отпускании мыши финальная проверка границ\n        this.keepWindowInBounds()\n        \n        // Если окно было \"прилипшим\", убираем прилипание при следующем перетаскивании\n        this.isSnapped = false\n      }\n      \n      if (this.isResizing) {\n        this.keepResizeInBounds()\n      }\n      \n      this.isDragging = false\n      this.isResizing = false\n    },\n    \n    // ФИНАЛЬНАЯ ПРОВЕРКА ГРАНИЦ ПРИ ОТПУСКАНИИ\n    keepWindowInBounds() {\n      const minWidth = 200\n      const minHeight = 150\n      const screenWidth = window.innerWidth\n      const screenHeight = window.innerHeight\n      \n      // Гарантируем минимальные размеры\n      this.windowWidth = Math.max(minWidth, this.windowWidth)\n      this.windowHeight = Math.max(minHeight, this.windowHeight)\n      \n      // Не даем окну выйти за правую границу\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.posX = screenWidth - this.windowWidth\n      }\n      \n      // Не даем окну выйти за нижнюю границу\n      if (this.posY + this.windowHeight > screenHeight) {\n        this.posY = screenHeight - this.windowHeight\n      }\n      \n      // Не даем уйти за левую и верхнюю границы\n      this.posX = Math.max(0, this.posX)\n      this.posY = Math.max(0, this.posY)\n      \n      // Если после всех проверок окно всё равно вылезает, уменьшаем его\n      if (this.posX + this.windowWidth > screenWidth) {\n        this.windowWidth = screenWidth - this.posX\n      }\n      \n      if (this.posY + this.windowHeight > screenHeight) {\n        this.windowHeight = screenHeight - this.posY\n      }\n      \n      // Еще раз проверяем минимальные размеры\n      this.windowWidth = Math.max(minWidth, this.windowWidth)\n      this.windowHeight = Math.max(minHeight, this.windowHeight)\n      \n      // Если окно слишком маленькое, центрируем его\n      if (this.windowWidth < minWidth) {\n        this.windowWidth = minWidth\n        this.posX = Math.max(0, Math.min(this.posX, screenWidth - minWidth))\n      }\n      \n      if (this.windowHeight < minHeight) {\n        this.windowHeight = minHeight\n        this.posY = Math.max(0, Math.min(this.posY, screenHeight - minHeight))\n      }\n    },\n    \n    minimize() {\n      this.$emit('minimize', this.windowId)\n    },\n    \n    toggleMaximize() {\n      this.$emit('toggleMaximize', this.windowId)\n    },\n    \n    close() {\n      this.$emit('close', this.windowId)\n    },\n    \n    // Дополнительно: двойной клик по заголовку для максимизации\n    handleDoubleClick(e) {\n      if (e.target.closest('.window-header') && !e.target.closest('.window-controls')) {\n        this.toggleMaximize()\n      }\n    }\n  }\n}\n</script>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}