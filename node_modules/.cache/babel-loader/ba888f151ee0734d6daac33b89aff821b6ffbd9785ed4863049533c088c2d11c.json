{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { StringType } from 'token-types';\nimport { FieldDecodingError } from '../ParseError.js';\nimport { getUintBE } from 'uint8array-extras';\nexport function getBit(buf, off, bit) {\n  return (buf[off] & 1 << bit) !== 0;\n}\n/**\n * Found delimiting zero in uint8Array\n * @param uint8Array Uint8Array to find the zero delimiter in\n * @param start Offset in uint8Array\n * @param end Last position to parse in uint8Array\n * @param encoding The string encoding used\n * @return Absolute position on uint8Array where zero found\n */\nexport function findZero(uint8Array, start, end, encoding) {\n  let i = start;\n  if (encoding === 'utf-16le') {\n    while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {\n      if (i >= end) return end;\n      i += 2;\n    }\n    return i;\n  }\n  while (uint8Array[i] !== 0) {\n    if (i >= end) return end;\n    i++;\n  }\n  return i;\n}\nexport function trimRightNull(x) {\n  const pos0 = x.indexOf('\\0');\n  return pos0 === -1 ? x : x.substr(0, pos0);\n}\nfunction swapBytes(uint8Array) {\n  const l = uint8Array.length;\n  if ((l & 1) !== 0) throw new FieldDecodingError('Buffer length must be even');\n  for (let i = 0; i < l; i += 2) {\n    const a = uint8Array[i];\n    uint8Array[i] = uint8Array[i + 1];\n    uint8Array[i + 1] = a;\n  }\n  return uint8Array;\n}\n/**\n * Decode string\n */\nexport function decodeString(uint8Array, encoding) {\n  // annoying workaround for a double BOM issue\n  // https://github.com/leetreveil/musicmetadata/issues/84\n  if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) {\n    // little endian\n    return decodeString(uint8Array.subarray(2), encoding);\n  }\n  if (encoding === 'utf-16le' && uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {\n    // BOM, indicating big endian decoding\n    if ((uint8Array.length & 1) !== 0) throw new FieldDecodingError('Expected even number of octets for 16-bit unicode string');\n    return decodeString(swapBytes(uint8Array), encoding);\n  }\n  return new StringType(uint8Array.length, encoding).get(uint8Array, 0);\n}\nexport function stripNulls(str) {\n  str = str.replace(/^\\x00+/g, '');\n  str = str.replace(/\\x00+$/g, '');\n  return str;\n}\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte buffer\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = lsb\n * @param len Length of number in bits\n * @return Decoded bit aligned number\n */\nexport function getBitAllignedNumber(source, byteOffset, bitOffset, len) {\n  const byteOff = byteOffset + ~~(bitOffset / 8);\n  const bitOff = bitOffset % 8;\n  let value = source[byteOff];\n  value &= 0xff >> bitOff;\n  const bitsRead = 8 - bitOff;\n  const bitsLeft = len - bitsRead;\n  if (bitsLeft < 0) {\n    value >>= 8 - bitOff - len;\n  } else if (bitsLeft > 0) {\n    value <<= bitsLeft;\n    value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);\n  }\n  return value;\n}\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte Uint8Array\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is the least significant bit\n * @return True if bit is set\n */\nexport function isBitSet(source, byteOffset, bitOffset) {\n  return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;\n}\nexport function a2hex(str) {\n  const arr = [];\n  for (let i = 0, l = str.length; i < l; i++) {\n    const hex = Number(str.charCodeAt(i)).toString(16);\n    arr.push(hex.length === 1 ? `0${hex}` : hex);\n  }\n  return arr.join(' ');\n}\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\nexport function ratioToDb(ratio) {\n  return 10 * Math.log10(ratio);\n}\n/**\n * Convert dB to ratio\n * db Decibels\n */\nexport function dbToRatio(dB) {\n  return 10 ** (dB / 10);\n}\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\nexport function toRatio(value) {\n  const ps = value.split(' ').map(p => p.trim().toLowerCase());\n  if (ps.length >= 1) {\n    const v = Number.parseFloat(ps[0]);\n    return ps.length === 2 && ps[1] === 'db' ? {\n      dB: v,\n      ratio: dbToRatio(v)\n    } : {\n      dB: ratioToDb(v),\n      ratio: v\n    };\n  }\n}\n/**\n * Decode a big-endian unsigned integer from a Uint8Array.\n * Supports dynamic length (1–8 bytes).\n */\nexport function decodeUintBE(uint8Array) {\n  if (uint8Array.length === 0) {\n    throw new Error(\"decodeUintBE: empty Uint8Array\");\n  }\n  const view = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n  return getUintBE(view);\n}","map":{"version":3,"names":["StringType","FieldDecodingError","getUintBE","getBit","buf","off","bit","findZero","uint8Array","start","end","encoding","i","trimRightNull","x","pos0","indexOf","substr","swapBytes","l","length","a","decodeString","subarray","get","stripNulls","str","replace","getBitAllignedNumber","source","byteOffset","bitOffset","len","byteOff","bitOff","value","bitsRead","bitsLeft","isBitSet","a2hex","arr","hex","Number","charCodeAt","toString","push","join","ratioToDb","ratio","Math","log10","dbToRatio","dB","toRatio","ps","split","map","p","trim","toLowerCase","v","parseFloat","decodeUintBE","Error","view","DataView","buffer","byteLength"],"sources":["/home/kup/my_projects/vue/osi/node_modules/music-metadata/lib/common/Util.js"],"sourcesContent":["import { StringType } from 'token-types';\nimport { FieldDecodingError } from '../ParseError.js';\nimport { getUintBE } from 'uint8array-extras';\nexport function getBit(buf, off, bit) {\n    return (buf[off] & (1 << bit)) !== 0;\n}\n/**\n * Found delimiting zero in uint8Array\n * @param uint8Array Uint8Array to find the zero delimiter in\n * @param start Offset in uint8Array\n * @param end Last position to parse in uint8Array\n * @param encoding The string encoding used\n * @return Absolute position on uint8Array where zero found\n */\nexport function findZero(uint8Array, start, end, encoding) {\n    let i = start;\n    if (encoding === 'utf-16le') {\n        while (uint8Array[i] !== 0 || uint8Array[i + 1] !== 0) {\n            if (i >= end)\n                return end;\n            i += 2;\n        }\n        return i;\n    }\n    while (uint8Array[i] !== 0) {\n        if (i >= end)\n            return end;\n        i++;\n    }\n    return i;\n}\nexport function trimRightNull(x) {\n    const pos0 = x.indexOf('\\0');\n    return pos0 === -1 ? x : x.substr(0, pos0);\n}\nfunction swapBytes(uint8Array) {\n    const l = uint8Array.length;\n    if ((l & 1) !== 0)\n        throw new FieldDecodingError('Buffer length must be even');\n    for (let i = 0; i < l; i += 2) {\n        const a = uint8Array[i];\n        uint8Array[i] = uint8Array[i + 1];\n        uint8Array[i + 1] = a;\n    }\n    return uint8Array;\n}\n/**\n * Decode string\n */\nexport function decodeString(uint8Array, encoding) {\n    // annoying workaround for a double BOM issue\n    // https://github.com/leetreveil/musicmetadata/issues/84\n    if (uint8Array[0] === 0xFF && uint8Array[1] === 0xFE) { // little endian\n        return decodeString(uint8Array.subarray(2), encoding);\n    }\n    if (encoding === 'utf-16le' && uint8Array[0] === 0xFE && uint8Array[1] === 0xFF) {\n        // BOM, indicating big endian decoding\n        if ((uint8Array.length & 1) !== 0)\n            throw new FieldDecodingError('Expected even number of octets for 16-bit unicode string');\n        return decodeString(swapBytes(uint8Array), encoding);\n    }\n    return new StringType(uint8Array.length, encoding).get(uint8Array, 0);\n}\nexport function stripNulls(str) {\n    str = str.replace(/^\\x00+/g, '');\n    str = str.replace(/\\x00+$/g, '');\n    return str;\n}\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte buffer\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = lsb\n * @param len Length of number in bits\n * @return Decoded bit aligned number\n */\nexport function getBitAllignedNumber(source, byteOffset, bitOffset, len) {\n    const byteOff = byteOffset + ~~(bitOffset / 8);\n    const bitOff = bitOffset % 8;\n    let value = source[byteOff];\n    value &= 0xff >> bitOff;\n    const bitsRead = 8 - bitOff;\n    const bitsLeft = len - bitsRead;\n    if (bitsLeft < 0) {\n        value >>= (8 - bitOff - len);\n    }\n    else if (bitsLeft > 0) {\n        value <<= bitsLeft;\n        value |= getBitAllignedNumber(source, byteOffset, bitOffset + bitsRead, bitsLeft);\n    }\n    return value;\n}\n/**\n * Read bit-aligned number start from buffer\n * Total offset in bits = byteOffset * 8 + bitOffset\n * @param source Byte Uint8Array\n * @param byteOffset Starting offset in bytes\n * @param bitOffset Starting offset in bits: 0 = most significant bit, 7 is the least significant bit\n * @return True if bit is set\n */\nexport function isBitSet(source, byteOffset, bitOffset) {\n    return getBitAllignedNumber(source, byteOffset, bitOffset, 1) === 1;\n}\nexport function a2hex(str) {\n    const arr = [];\n    for (let i = 0, l = str.length; i < l; i++) {\n        const hex = Number(str.charCodeAt(i)).toString(16);\n        arr.push(hex.length === 1 ? `0${hex}` : hex);\n    }\n    return arr.join(' ');\n}\n/**\n * Convert power ratio to DB\n * ratio: [0..1]\n */\nexport function ratioToDb(ratio) {\n    return 10 * Math.log10(ratio);\n}\n/**\n * Convert dB to ratio\n * db Decibels\n */\nexport function dbToRatio(dB) {\n    return 10 ** (dB / 10);\n}\n/**\n * Convert replay gain to ratio and Decibel\n * @param value string holding a ratio like '0.034' or '-7.54 dB'\n */\nexport function toRatio(value) {\n    const ps = value.split(' ').map(p => p.trim().toLowerCase());\n    if (ps.length >= 1) {\n        const v = Number.parseFloat(ps[0]);\n        return ps.length === 2 && ps[1] === 'db' ? {\n            dB: v,\n            ratio: dbToRatio(v)\n        } : {\n            dB: ratioToDb(v),\n            ratio: v\n        };\n    }\n}\n/**\n * Decode a big-endian unsigned integer from a Uint8Array.\n * Supports dynamic length (1–8 bytes).\n */\nexport function decodeUintBE(uint8Array) {\n    if (uint8Array.length === 0) {\n        throw new Error(\"decodeUintBE: empty Uint8Array\");\n    }\n    const view = new DataView(uint8Array.buffer, uint8Array.byteOffset, uint8Array.byteLength);\n    return getUintBE(view);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}