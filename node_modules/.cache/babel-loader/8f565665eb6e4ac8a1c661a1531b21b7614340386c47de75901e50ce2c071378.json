{"ast":null,"code":"import initDebug from 'debug';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { ChunkHeader, DsdChunk, FormatChunk } from './DsfChunk.js';\nimport { ID3v2Parser } from \"../id3v2/ID3v2Parser.js\";\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:DSF');\nexport class DsdContentParseError extends makeUnexpectedFileContentError('DSD') {}\n/**\r\n * DSF (dsd stream file) File Parser\r\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\r\n */\nexport class DsfParser extends AbstractID3Parser {\n  async postId3v2Parse() {\n    const p0 = this.tokenizer.position; // mark start position, normally 0\n    const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\n    if (chunkHeader.id !== 'DSD ') throw new DsdContentParseError('Invalid chunk signature');\n    this.metadata.setFormat('container', 'DSF');\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setAudioOnly();\n    const dsdChunk = await this.tokenizer.readToken(DsdChunk);\n    if (dsdChunk.metadataPointer === BigInt(0)) {\n      debug(\"No ID3v2 tag present\");\n    } else {\n      debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\n      await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\n      // Jump to ID3 header\n      await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\n      return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\n    }\n  }\n  async parseChunks(bytesRemaining) {\n    while (bytesRemaining >= ChunkHeader.len) {\n      const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\n      debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\n      switch (chunkHeader.id) {\n        case 'fmt ':\n          {\n            const formatChunk = await this.tokenizer.readToken(FormatChunk);\n            this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\n            this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\n            this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\n            this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\n            this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\n            const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\n            this.metadata.setFormat('bitrate', bitrate);\n            return; // We got what we want, stop further processing of chunks\n          }\n        default:\n          this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);\n          break;\n      }\n      bytesRemaining -= chunkHeader.size;\n    }\n  }\n}","map":{"version":3,"names":["initDebug","AbstractID3Parser","ChunkHeader","DsdChunk","FormatChunk","ID3v2Parser","makeUnexpectedFileContentError","debug","DsdContentParseError","DsfParser","postId3v2Parse","p0","tokenizer","position","chunkHeader","readToken","id","metadata","setFormat","setAudioOnly","dsdChunk","metadataPointer","BigInt","parseChunks","fileSize","size","ignore","Number","parse","options","bytesRemaining","len","formatChunk","channelNum","samplingFrequency","bitsPerSample","sampleCount","bitrate"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/dsf/DsfParser.js"],"sourcesContent":["import initDebug from 'debug';\r\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\r\nimport { ChunkHeader, DsdChunk, FormatChunk } from './DsfChunk.js';\r\nimport { ID3v2Parser } from \"../id3v2/ID3v2Parser.js\";\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:DSF');\r\nexport class DsdContentParseError extends makeUnexpectedFileContentError('DSD') {\r\n}\r\n/**\r\n * DSF (dsd stream file) File Parser\r\n * Ref: https://dsd-guide.com/sites/default/files/white-papers/DSFFileFormatSpec_E.pdf\r\n */\r\nexport class DsfParser extends AbstractID3Parser {\r\n    async postId3v2Parse() {\r\n        const p0 = this.tokenizer.position; // mark start position, normally 0\r\n        const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\r\n        if (chunkHeader.id !== 'DSD ')\r\n            throw new DsdContentParseError('Invalid chunk signature');\r\n        this.metadata.setFormat('container', 'DSF');\r\n        this.metadata.setFormat('lossless', true);\r\n        this.metadata.setAudioOnly();\r\n        const dsdChunk = await this.tokenizer.readToken(DsdChunk);\r\n        if (dsdChunk.metadataPointer === BigInt(0)) {\r\n            debug(\"No ID3v2 tag present\");\r\n        }\r\n        else {\r\n            debug(`expect ID3v2 at offset=${dsdChunk.metadataPointer}`);\r\n            await this.parseChunks(dsdChunk.fileSize - chunkHeader.size);\r\n            // Jump to ID3 header\r\n            await this.tokenizer.ignore(Number(dsdChunk.metadataPointer) - this.tokenizer.position - p0);\r\n            return new ID3v2Parser().parse(this.metadata, this.tokenizer, this.options);\r\n        }\r\n    }\r\n    async parseChunks(bytesRemaining) {\r\n        while (bytesRemaining >= ChunkHeader.len) {\r\n            const chunkHeader = await this.tokenizer.readToken(ChunkHeader);\r\n            debug(`Parsing chunk name=${chunkHeader.id} size=${chunkHeader.size}`);\r\n            switch (chunkHeader.id) {\r\n                case 'fmt ': {\r\n                    const formatChunk = await this.tokenizer.readToken(FormatChunk);\r\n                    this.metadata.setFormat('numberOfChannels', formatChunk.channelNum);\r\n                    this.metadata.setFormat('sampleRate', formatChunk.samplingFrequency);\r\n                    this.metadata.setFormat('bitsPerSample', formatChunk.bitsPerSample);\r\n                    this.metadata.setFormat('numberOfSamples', formatChunk.sampleCount);\r\n                    this.metadata.setFormat('duration', Number(formatChunk.sampleCount) / formatChunk.samplingFrequency);\r\n                    const bitrate = formatChunk.bitsPerSample * formatChunk.samplingFrequency * formatChunk.channelNum;\r\n                    this.metadata.setFormat('bitrate', bitrate);\r\n                    return; // We got what we want, stop further processing of chunks\r\n                }\r\n                default:\r\n                    this.tokenizer.ignore(Number(chunkHeader.size) - ChunkHeader.len);\r\n                    break;\r\n            }\r\n            bytesRemaining -= chunkHeader.size;\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}