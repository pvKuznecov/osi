{"ast":null,"code":"import * as util from '../common/Util.js';\nimport { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\n/**\r\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\r\n * ref: https://xiph.org/flac/format.html#metadata_block\r\n */\nexport const BlockType = {\n  STREAMINFO: 0,\n  // STREAMINFO\n  PADDING: 1,\n  // PADDING\n  APPLICATION: 2,\n  // APPLICATION\n  SEEKTABLE: 3,\n  // SEEKTABLE\n  VORBIS_COMMENT: 4,\n  // VORBIS_COMMENT\n  CUESHEET: 5,\n  // CUESHEET\n  PICTURE: 6 // PICTURE\n};\nexport const BlockHeader = {\n  len: 4,\n  get: (buf, off) => {\n    return {\n      lastBlock: util.getBit(buf, off, 7),\n      type: util.getBitAllignedNumber(buf, off, 1, 7),\n      length: UINT24_BE.get(buf, off + 1)\n    };\n  }\n};\n/**\r\n * METADATA_BLOCK_DATA\r\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\r\n */\nexport const BlockStreamInfo = {\n  len: 34,\n  get: (buf, off) => {\n    return {\n      // The minimum block size (in samples) used in the stream.\n      minimumBlockSize: UINT16_BE.get(buf, off),\n      // The maximum block size (in samples) used in the stream.\n      // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\n      maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\n      // The minimum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      minimumFrameSize: UINT24_BE.get(buf, off + 4),\n      // The maximum frame size (in bytes) used in the stream.\n      // May be 0 to imply the value is not known.\n      maximumFrameSize: UINT24_BE.get(buf, off + 7),\n      // Sample rate in Hz. Though 20 bits are available,\n      // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\n      // Also, a value of 0 is invalid.\n      sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\n      // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\n      // (number of channels)-1. FLAC supports from 1 to 8 channels\n      channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\n      // bits per sample)-1.\n      // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\n      bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\n      // Total samples in stream.\n      // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\n      // A value of zero here means the number of total samples is unknown.\n      totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\n      // the MD5 hash of the file (see notes for usage... it's a littly tricky)\n      fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\n    };\n  }\n};","map":{"version":3,"names":["util","UINT16_BE","UINT24_BE","Uint8ArrayType","BlockType","STREAMINFO","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","CUESHEET","PICTURE","BlockHeader","len","get","buf","off","lastBlock","getBit","type","getBitAllignedNumber","length","BlockStreamInfo","minimumBlockSize","maximumBlockSize","minimumFrameSize","maximumFrameSize","sampleRate","channels","bitsPerSample","totalSamples","fileMD5"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/flac/FlacToken.js"],"sourcesContent":["import * as util from '../common/Util.js';\r\nimport { UINT16_BE, UINT24_BE, Uint8ArrayType } from 'token-types';\r\n/**\r\n * FLAC supports up to 128 kinds of metadata blocks; currently the following are defined:\r\n * ref: https://xiph.org/flac/format.html#metadata_block\r\n */\r\nexport const BlockType = {\r\n    STREAMINFO: 0, // STREAMINFO\r\n    PADDING: 1, // PADDING\r\n    APPLICATION: 2, // APPLICATION\r\n    SEEKTABLE: 3, // SEEKTABLE\r\n    VORBIS_COMMENT: 4, // VORBIS_COMMENT\r\n    CUESHEET: 5, // CUESHEET\r\n    PICTURE: 6 // PICTURE\r\n};\r\nexport const BlockHeader = {\r\n    len: 4,\r\n    get: (buf, off) => {\r\n        return {\r\n            lastBlock: util.getBit(buf, off, 7),\r\n            type: util.getBitAllignedNumber(buf, off, 1, 7),\r\n            length: UINT24_BE.get(buf, off + 1)\r\n        };\r\n    }\r\n};\r\n/**\r\n * METADATA_BLOCK_DATA\r\n * Ref: https://xiph.org/flac/format.html#metadata_block_streaminfo\r\n */\r\nexport const BlockStreamInfo = {\r\n    len: 34,\r\n    get: (buf, off) => {\r\n        return {\r\n            // The minimum block size (in samples) used in the stream.\r\n            minimumBlockSize: UINT16_BE.get(buf, off),\r\n            // The maximum block size (in samples) used in the stream.\r\n            // (Minimum blocksize == maximum blocksize) implies a fixed-blocksize stream.\r\n            maximumBlockSize: UINT16_BE.get(buf, off + 2) / 1000,\r\n            // The minimum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            minimumFrameSize: UINT24_BE.get(buf, off + 4),\r\n            // The maximum frame size (in bytes) used in the stream.\r\n            // May be 0 to imply the value is not known.\r\n            maximumFrameSize: UINT24_BE.get(buf, off + 7),\r\n            // Sample rate in Hz. Though 20 bits are available,\r\n            // the maximum sample rate is limited by the structure of frame headers to 655350Hz.\r\n            // Also, a value of 0 is invalid.\r\n            sampleRate: UINT24_BE.get(buf, off + 10) >> 4,\r\n            // probably slower: sampleRate: common.getBitAllignedNumber(buf, off + 10, 0, 20),\r\n            // (number of channels)-1. FLAC supports from 1 to 8 channels\r\n            channels: util.getBitAllignedNumber(buf, off + 12, 4, 3) + 1,\r\n            // bits per sample)-1.\r\n            // FLAC supports from 4 to 32 bits per sample. Currently the reference encoder and decoders only support up to 24 bits per sample.\r\n            bitsPerSample: util.getBitAllignedNumber(buf, off + 12, 7, 5) + 1,\r\n            // Total samples in stream.\r\n            // 'Samples' means inter-channel sample, i.e. one second of 44.1Khz audio will have 44100 samples regardless of the number of channels.\r\n            // A value of zero here means the number of total samples is unknown.\r\n            totalSamples: util.getBitAllignedNumber(buf, off + 13, 4, 36),\r\n            // the MD5 hash of the file (see notes for usage... it's a littly tricky)\r\n            fileMD5: new Uint8ArrayType(16).get(buf, off + 18)\r\n        };\r\n    }\r\n};\r\n"],"mappings":"AAAA,OAAO,KAAKA,IAAI,MAAM,mBAAmB;AACzC,SAASC,SAAS,EAAEC,SAAS,EAAEC,cAAc,QAAQ,aAAa;AAClE;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS,GAAG;EACrBC,UAAU,EAAE,CAAC;EAAE;EACfC,OAAO,EAAE,CAAC;EAAE;EACZC,WAAW,EAAE,CAAC;EAAE;EAChBC,SAAS,EAAE,CAAC;EAAE;EACdC,cAAc,EAAE,CAAC;EAAE;EACnBC,QAAQ,EAAE,CAAC;EAAE;EACbC,OAAO,EAAE,CAAC,CAAC;AACf,CAAC;AACD,OAAO,MAAMC,WAAW,GAAG;EACvBC,GAAG,EAAE,CAAC;EACNC,GAAG,EAAEA,CAACC,GAAG,EAAEC,GAAG,KAAK;IACf,OAAO;MACHC,SAAS,EAAEjB,IAAI,CAACkB,MAAM,CAACH,GAAG,EAAEC,GAAG,EAAE,CAAC,CAAC;MACnCG,IAAI,EAAEnB,IAAI,CAACoB,oBAAoB,CAACL,GAAG,EAAEC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;MAC/CK,MAAM,EAAEnB,SAAS,CAACY,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,CAAC;IACtC,CAAC;EACL;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,MAAMM,eAAe,GAAG;EAC3BT,GAAG,EAAE,EAAE;EACPC,GAAG,EAAEA,CAACC,GAAG,EAAEC,GAAG,KAAK;IACf,OAAO;MACH;MACAO,gBAAgB,EAAEtB,SAAS,CAACa,GAAG,CAACC,GAAG,EAAEC,GAAG,CAAC;MACzC;MACA;MACAQ,gBAAgB,EAAEvB,SAAS,CAACa,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,CAAC,CAAC,GAAG,IAAI;MACpD;MACA;MACAS,gBAAgB,EAAEvB,SAAS,CAACY,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,CAAC,CAAC;MAC7C;MACA;MACAU,gBAAgB,EAAExB,SAAS,CAACY,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,CAAC,CAAC;MAC7C;MACA;MACA;MACAW,UAAU,EAAEzB,SAAS,CAACY,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,EAAE,CAAC,IAAI,CAAC;MAC7C;MACA;MACAY,QAAQ,EAAE5B,IAAI,CAACoB,oBAAoB,CAACL,GAAG,EAAEC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC;MAC5D;MACA;MACAa,aAAa,EAAE7B,IAAI,CAACoB,oBAAoB,CAACL,GAAG,EAAEC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC;MACjE;MACA;MACA;MACAc,YAAY,EAAE9B,IAAI,CAACoB,oBAAoB,CAACL,GAAG,EAAEC,GAAG,GAAG,EAAE,EAAE,CAAC,EAAE,EAAE,CAAC;MAC7D;MACAe,OAAO,EAAE,IAAI5B,cAAc,CAAC,EAAE,CAAC,CAACW,GAAG,CAACC,GAAG,EAAEC,GAAG,GAAG,EAAE;IACrD,CAAC;EACL;AACJ,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}