{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport initDebug from 'debug';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { matroskaDtd } from './MatroskaDtd.js';\nimport { TargetType, TrackType } from './types.js';\nimport { EbmlIterator, ParseAction } from '../ebml/EbmlIterator.js';\nconst debug = initDebug('music-metadata:parser:matroska');\n/**\r\n * Extensible Binary Meta Language (EBML) parser\r\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\r\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\r\n *\r\n * WEBM VP8 AUDIO FILE\r\n */\nexport class MatroskaParser extends BasicParser {\n  constructor() {\n    super(...arguments);\n    this.seekHeadOffset = 0;\n    /**\r\n     * Use index to skip multiple segment/cluster elements at once.\r\n     * Significant performance impact\r\n     */\n    this.flagUseIndexToSkipClusters = this.options.mkvUseIndex ?? false;\n  }\n  async parse() {\n    const containerSize = this.tokenizer.fileInfo.size ?? Number.MAX_SAFE_INTEGER;\n    const matroskaIterator = new EbmlIterator(this.tokenizer);\n    debug('Initializing DTD end MatroskaIterator');\n    await matroskaIterator.iterate(matroskaDtd, containerSize, {\n      startNext: element => {\n        switch (element.id) {\n          // case 0x1f43b675: // cluster\n          case 0x1c53bb6b:\n            // Cueing Data\n            debug(`Skip element: name=${element.name}, id=0x${element.id.toString(16)}`);\n            return ParseAction.IgnoreElement;\n          case 0x1f43b675:\n            // cluster\n            if (this.flagUseIndexToSkipClusters && this.seekHead) {\n              const index = this.seekHead.seek.find(index => index.position + this.seekHeadOffset > this.tokenizer.position);\n              if (index) {\n                // Go to next index position\n                const ignoreSize = index.position + this.seekHeadOffset - this.tokenizer.position;\n                debug(`Use index to go to next position, ignoring ${ignoreSize} bytes`);\n                this.tokenizer.ignore(ignoreSize);\n                return ParseAction.SkipElement;\n              }\n            }\n            return ParseAction.IgnoreElement;\n          default:\n            return ParseAction.ReadNext;\n        }\n      },\n      elementValue: async (element, value, offset) => {\n        debug(`Received: name=${element.name}, value=${value}`);\n        switch (element.id) {\n          case 0x4282:\n            // docType\n            this.metadata.setFormat('container', `EBML/${value}`);\n            break;\n          case 0x114d9b74:\n            this.seekHead = value;\n            this.seekHeadOffset = offset;\n            break;\n          case 0x1549a966:\n            {\n              // Info (Segment Information)\n              const info = value;\n              const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\n              if (typeof info.duration === 'number') {\n                const duration = info.duration * timecodeScale / 1000000000;\n                await this.addTag('segment:title', info.title);\n                this.metadata.setFormat('duration', Number(duration));\n              }\n            }\n            break;\n          case 0x1654ae6b:\n            {\n              // tracks\n              const audioTracks = value;\n              if (audioTracks?.entries) {\n                audioTracks.entries.forEach(entry => {\n                  const stream = {\n                    codecName: entry.codecID.replace('A_', '').replace('V_', ''),\n                    codecSettings: entry.codecSettings,\n                    flagDefault: entry.flagDefault,\n                    flagLacing: entry.flagLacing,\n                    flagEnabled: entry.flagEnabled,\n                    language: entry.language,\n                    name: entry.name,\n                    type: entry.trackType,\n                    audio: entry.audio,\n                    video: entry.video\n                  };\n                  this.metadata.addStreamInfo(stream);\n                });\n                const audioTrack = audioTracks.entries.filter(entry => entry.trackType === TrackType.audio).reduce((acc, cur) => {\n                  if (!acc) return cur;\n                  if (cur.flagDefault && !acc.flagDefault) return cur;\n                  if (cur.trackNumber < acc.trackNumber) return cur;\n                  return acc;\n                }, null);\n                if (audioTrack) {\n                  this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\n                  this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\n                  this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\n                }\n              }\n            }\n            break;\n          case 0x1254c367:\n            {\n              // tags\n              const tags = value;\n              await Promise.all(tags.tag.map(async tag => {\n                const target = tag.target;\n                const targetType = target?.targetTypeValue ? TargetType[target.targetTypeValue] : target?.targetType ? target.targetType : 'track';\n                await Promise.all(tag.simpleTags.map(async simpleTag => {\n                  const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\n                  await this.addTag(`${targetType}:${simpleTag.name}`, value);\n                }));\n              }));\n            }\n            break;\n          case 0x1941a469:\n            {\n              // attachments\n              const attachments = value;\n              await Promise.all(attachments.attachedFiles.filter(file => file.mimeType.startsWith('image/')).map(file => this.addTag('picture', {\n                data: file.data,\n                format: file.mimeType,\n                description: file.description,\n                name: file.name\n              })));\n            }\n            break;\n        }\n      }\n    });\n  }\n  async addTag(tagId, value) {\n    await this.metadata.addTag('matroska', tagId, value);\n  }\n}","map":{"version":3,"names":["initDebug","BasicParser","matroskaDtd","TargetType","TrackType","EbmlIterator","ParseAction","debug","MatroskaParser","constructor","arguments","seekHeadOffset","flagUseIndexToSkipClusters","options","mkvUseIndex","parse","containerSize","tokenizer","fileInfo","size","Number","MAX_SAFE_INTEGER","matroskaIterator","iterate","startNext","element","id","name","toString","IgnoreElement","seekHead","index","seek","find","position","ignoreSize","ignore","SkipElement","ReadNext","elementValue","value","offset","metadata","setFormat","info","timecodeScale","duration","addTag","title","audioTracks","entries","forEach","entry","stream","codecName","codecID","replace","codecSettings","flagDefault","flagLacing","flagEnabled","language","type","trackType","audio","video","addStreamInfo","audioTrack","filter","reduce","acc","cur","trackNumber","samplingFrequency","channels","tags","Promise","all","tag","map","target","targetType","targetTypeValue","simpleTags","simpleTag","string","binary","attachments","attachedFiles","file","mimeType","startsWith","data","format","description","tagId"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/matroska/MatroskaParser.js"],"sourcesContent":["import initDebug from 'debug';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { matroskaDtd } from './MatroskaDtd.js';\r\nimport { TargetType, TrackType } from './types.js';\r\nimport { EbmlIterator, ParseAction } from '../ebml/EbmlIterator.js';\r\nconst debug = initDebug('music-metadata:parser:matroska');\r\n/**\r\n * Extensible Binary Meta Language (EBML) parser\r\n * https://en.wikipedia.org/wiki/Extensible_Binary_Meta_Language\r\n * http://matroska.sourceforge.net/technical/specs/rfc/index.html\r\n *\r\n * WEBM VP8 AUDIO FILE\r\n */\r\nexport class MatroskaParser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.seekHeadOffset = 0;\r\n        /**\r\n         * Use index to skip multiple segment/cluster elements at once.\r\n         * Significant performance impact\r\n         */\r\n        this.flagUseIndexToSkipClusters = this.options.mkvUseIndex ?? false;\r\n    }\r\n    async parse() {\r\n        const containerSize = this.tokenizer.fileInfo.size ?? Number.MAX_SAFE_INTEGER;\r\n        const matroskaIterator = new EbmlIterator(this.tokenizer);\r\n        debug('Initializing DTD end MatroskaIterator');\r\n        await matroskaIterator.iterate(matroskaDtd, containerSize, {\r\n            startNext: (element) => {\r\n                switch (element.id) {\r\n                    // case 0x1f43b675: // cluster\r\n                    case 0x1c53bb6b: // Cueing Data\r\n                        debug(`Skip element: name=${element.name}, id=0x${element.id.toString(16)}`);\r\n                        return ParseAction.IgnoreElement;\r\n                    case 0x1f43b675: // cluster\r\n                        if (this.flagUseIndexToSkipClusters && this.seekHead) {\r\n                            const index = this.seekHead.seek.find(index => index.position + this.seekHeadOffset > this.tokenizer.position);\r\n                            if (index) {\r\n                                // Go to next index position\r\n                                const ignoreSize = index.position + this.seekHeadOffset - this.tokenizer.position;\r\n                                debug(`Use index to go to next position, ignoring ${ignoreSize} bytes`);\r\n                                this.tokenizer.ignore(ignoreSize);\r\n                                return ParseAction.SkipElement;\r\n                            }\r\n                        }\r\n                        return ParseAction.IgnoreElement;\r\n                    default:\r\n                        return ParseAction.ReadNext;\r\n                }\r\n            },\r\n            elementValue: async (element, value, offset) => {\r\n                debug(`Received: name=${element.name}, value=${value}`);\r\n                switch (element.id) {\r\n                    case 0x4282: // docType\r\n                        this.metadata.setFormat('container', `EBML/${value}`);\r\n                        break;\r\n                    case 0x114d9b74:\r\n                        this.seekHead = value;\r\n                        this.seekHeadOffset = offset;\r\n                        break;\r\n                    case 0x1549a966:\r\n                        { // Info (Segment Information)\r\n                            const info = value;\r\n                            const timecodeScale = info.timecodeScale ? info.timecodeScale : 1000000;\r\n                            if (typeof info.duration === 'number') {\r\n                                const duration = info.duration * timecodeScale / 1000000000;\r\n                                await this.addTag('segment:title', info.title);\r\n                                this.metadata.setFormat('duration', Number(duration));\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 0x1654ae6b:\r\n                        { // tracks\r\n                            const audioTracks = value;\r\n                            if (audioTracks?.entries) {\r\n                                audioTracks.entries.forEach(entry => {\r\n                                    const stream = {\r\n                                        codecName: entry.codecID.replace('A_', '').replace('V_', ''),\r\n                                        codecSettings: entry.codecSettings,\r\n                                        flagDefault: entry.flagDefault,\r\n                                        flagLacing: entry.flagLacing,\r\n                                        flagEnabled: entry.flagEnabled,\r\n                                        language: entry.language,\r\n                                        name: entry.name,\r\n                                        type: entry.trackType,\r\n                                        audio: entry.audio,\r\n                                        video: entry.video\r\n                                    };\r\n                                    this.metadata.addStreamInfo(stream);\r\n                                });\r\n                                const audioTrack = audioTracks.entries\r\n                                    .filter(entry => entry.trackType === TrackType.audio)\r\n                                    .reduce((acc, cur) => {\r\n                                    if (!acc)\r\n                                        return cur;\r\n                                    if (cur.flagDefault && !acc.flagDefault)\r\n                                        return cur;\r\n                                    if (cur.trackNumber < acc.trackNumber)\r\n                                        return cur;\r\n                                    return acc;\r\n                                }, null);\r\n                                if (audioTrack) {\r\n                                    this.metadata.setFormat('codec', audioTrack.codecID.replace('A_', ''));\r\n                                    this.metadata.setFormat('sampleRate', audioTrack.audio.samplingFrequency);\r\n                                    this.metadata.setFormat('numberOfChannels', audioTrack.audio.channels);\r\n                                }\r\n                            }\r\n                        }\r\n                        break;\r\n                    case 0x1254c367:\r\n                        { // tags\r\n                            const tags = value;\r\n                            await Promise.all(tags.tag.map(async (tag) => {\r\n                                const target = tag.target;\r\n                                const targetType = target?.targetTypeValue ? TargetType[target.targetTypeValue] : (target?.targetType ? target.targetType : 'track');\r\n                                await Promise.all(tag.simpleTags.map(async (simpleTag) => {\r\n                                    const value = simpleTag.string ? simpleTag.string : simpleTag.binary;\r\n                                    await this.addTag(`${targetType}:${simpleTag.name}`, value);\r\n                                }));\r\n                            }));\r\n                        }\r\n                        break;\r\n                    case 0x1941a469:\r\n                        { // attachments\r\n                            const attachments = value;\r\n                            await Promise.all(attachments.attachedFiles\r\n                                .filter(file => file.mimeType.startsWith('image/'))\r\n                                .map(file => this.addTag('picture', {\r\n                                data: file.data,\r\n                                format: file.mimeType,\r\n                                description: file.description,\r\n                                name: file.name\r\n                            })));\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    async addTag(tagId, value) {\r\n        await this.metadata.addTag('matroska', tagId, value);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}