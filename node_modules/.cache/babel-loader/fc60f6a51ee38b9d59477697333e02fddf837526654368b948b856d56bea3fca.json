{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport initDebug from 'debug';\nimport { Uint8ArrayType } from 'token-types';\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { VorbisStream } from '../ogg/vorbis/VorbisStream.js';\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport * as Flac from './FlacToken.js';\nconst debug = initDebug('music-metadata:parser:FLAC');\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {}\nexport class FlacParser extends AbstractID3Parser {\n  constructor() {\n    super(...arguments);\n    this.vorbisParser = new VorbisStream(this.metadata, this.options);\n    this.padding = 0;\n  }\n  async postId3v2Parse() {\n    const fourCC = await this.tokenizer.readToken(FourCcToken);\n    if (fourCC.toString() !== 'fLaC') {\n      throw new FlacContentError('Invalid FLAC preamble');\n    }\n    let blockHeader;\n    do {\n      // Read block header\n      blockHeader = await this.tokenizer.readToken(Flac.BlockHeader);\n      // Parse block data\n      await this.parseDataBlock(blockHeader);\n    } while (!blockHeader.lastBlock);\n    if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n      const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n      this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n    }\n  }\n  async parseDataBlock(blockHeader) {\n    debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n    switch (blockHeader.type) {\n      case Flac.BlockType.STREAMINFO:\n        return this.readBlockStreamInfo(blockHeader.length);\n      case Flac.BlockType.PADDING:\n        this.padding += blockHeader.length;\n        break;\n      case Flac.BlockType.APPLICATION:\n        break;\n      case Flac.BlockType.SEEKTABLE:\n        break;\n      case Flac.BlockType.VORBIS_COMMENT:\n        return this.readComment(blockHeader.length);\n      case Flac.BlockType.CUESHEET:\n        break;\n      case Flac.BlockType.PICTURE:\n        await this.parsePicture(blockHeader.length);\n        return;\n      default:\n        this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n    }\n    // Ignore data block\n    return this.tokenizer.ignore(blockHeader.length).then();\n  }\n  /**\n   * Parse STREAMINFO\n   */\n  async readBlockStreamInfo(dataLen) {\n    if (dataLen !== Flac.BlockStreamInfo.len) throw new FlacContentError('Unexpected block-stream-info length');\n    const streamInfo = await this.tokenizer.readToken(Flac.BlockStreamInfo);\n    this.metadata.setFormat('container', 'FLAC');\n    this.processsStreamInfo(streamInfo);\n  }\n  /**\n   * Parse STREAMINFO\n   */\n  processsStreamInfo(streamInfo) {\n    this.metadata.setFormat('codec', 'FLAC');\n    this.metadata.setFormat('hasAudio', true);\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n    this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n    this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n    if (streamInfo.totalSamples > 0) {\n      this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n    }\n  }\n  /**\n   * Read VORBIS_COMMENT from tokenizer\n   * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n   */\n  async readComment(dataLen) {\n    const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\n    return this.parseComment(data);\n  }\n  /**\n   * Parse VORBIS_COMMENT\n   * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n   */\n  async parseComment(data) {\n    const decoder = new VorbisDecoder(data, 0);\n    const vendor = decoder.readStringUtf8();\n    if (vendor.length > 0) {\n      this.metadata.setFormat('tool', vendor);\n    }\n    const commentListLength = decoder.readInt32();\n    const tags = new Array(commentListLength);\n    for (let i = 0; i < commentListLength; i++) {\n      tags[i] = decoder.parseUserComment();\n    }\n    await Promise.all(tags.map(tag => {\n      if (tag.key === 'ENCODER') {\n        this.metadata.setFormat('tool', tag.value);\n      }\n      return this.addTag(tag.key, tag.value);\n    }));\n  }\n  async parsePicture(dataLen) {\n    if (this.options.skipCovers) {\n      return this.tokenizer.ignore(dataLen);\n    }\n    return this.addPictureTag(await this.tokenizer.readToken(new VorbisPictureToken(dataLen)));\n  }\n  addPictureTag(picture) {\n    return this.addTag('METADATA_BLOCK_PICTURE', picture);\n  }\n  addTag(id, value) {\n    return this.vorbisParser.addTag(id, value);\n  }\n}","map":{"version":3,"names":["initDebug","Uint8ArrayType","VorbisPictureToken","AbstractID3Parser","FourCcToken","VorbisStream","VorbisDecoder","makeUnexpectedFileContentError","Flac","debug","FlacContentError","FlacParser","constructor","arguments","vorbisParser","metadata","options","padding","postId3v2Parse","fourCC","tokenizer","readToken","toString","blockHeader","BlockHeader","parseDataBlock","lastBlock","fileInfo","size","format","duration","dataSize","position","setFormat","type","length","BlockType","STREAMINFO","readBlockStreamInfo","PADDING","APPLICATION","SEEKTABLE","VORBIS_COMMENT","readComment","CUESHEET","PICTURE","parsePicture","addWarning","ignore","then","dataLen","BlockStreamInfo","len","streamInfo","processsStreamInfo","channels","bitsPerSample","sampleRate","totalSamples","data","parseComment","decoder","vendor","readStringUtf8","commentListLength","readInt32","tags","Array","i","parseUserComment","Promise","all","map","tag","key","value","addTag","skipCovers","addPictureTag","picture","id"],"sources":["/home/kup/my_projects/vue/osi/node_modules/music-metadata/lib/flac/FlacParser.js"],"sourcesContent":["import initDebug from 'debug';\nimport { Uint8ArrayType } from 'token-types';\nimport { VorbisPictureToken } from '../ogg/vorbis/Vorbis.js';\nimport { AbstractID3Parser } from '../id3v2/AbstractID3Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { VorbisStream } from '../ogg/vorbis/VorbisStream.js';\nimport { VorbisDecoder } from '../ogg/vorbis/VorbisDecoder.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport * as Flac from './FlacToken.js';\nconst debug = initDebug('music-metadata:parser:FLAC');\nclass FlacContentError extends makeUnexpectedFileContentError('FLAC') {\n}\nexport class FlacParser extends AbstractID3Parser {\n    constructor() {\n        super(...arguments);\n        this.vorbisParser = new VorbisStream(this.metadata, this.options);\n        this.padding = 0;\n    }\n    async postId3v2Parse() {\n        const fourCC = await this.tokenizer.readToken(FourCcToken);\n        if (fourCC.toString() !== 'fLaC') {\n            throw new FlacContentError('Invalid FLAC preamble');\n        }\n        let blockHeader;\n        do {\n            // Read block header\n            blockHeader = await this.tokenizer.readToken(Flac.BlockHeader);\n            // Parse block data\n            await this.parseDataBlock(blockHeader);\n        } while (!blockHeader.lastBlock);\n        if (this.tokenizer.fileInfo.size && this.metadata.format.duration) {\n            const dataSize = this.tokenizer.fileInfo.size - this.tokenizer.position;\n            this.metadata.setFormat('bitrate', 8 * dataSize / this.metadata.format.duration);\n        }\n    }\n    async parseDataBlock(blockHeader) {\n        debug(`blockHeader type=${blockHeader.type}, length=${blockHeader.length}`);\n        switch (blockHeader.type) {\n            case Flac.BlockType.STREAMINFO:\n                return this.readBlockStreamInfo(blockHeader.length);\n            case Flac.BlockType.PADDING:\n                this.padding += blockHeader.length;\n                break;\n            case Flac.BlockType.APPLICATION:\n                break;\n            case Flac.BlockType.SEEKTABLE:\n                break;\n            case Flac.BlockType.VORBIS_COMMENT:\n                return this.readComment(blockHeader.length);\n            case Flac.BlockType.CUESHEET:\n                break;\n            case Flac.BlockType.PICTURE:\n                await this.parsePicture(blockHeader.length);\n                return;\n            default:\n                this.metadata.addWarning(`Unknown block type: ${blockHeader.type}`);\n        }\n        // Ignore data block\n        return this.tokenizer.ignore(blockHeader.length).then();\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    async readBlockStreamInfo(dataLen) {\n        if (dataLen !== Flac.BlockStreamInfo.len)\n            throw new FlacContentError('Unexpected block-stream-info length');\n        const streamInfo = await this.tokenizer.readToken(Flac.BlockStreamInfo);\n        this.metadata.setFormat('container', 'FLAC');\n        this.processsStreamInfo(streamInfo);\n    }\n    /**\n     * Parse STREAMINFO\n     */\n    processsStreamInfo(streamInfo) {\n        this.metadata.setFormat('codec', 'FLAC');\n        this.metadata.setFormat('hasAudio', true);\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('numberOfChannels', streamInfo.channels);\n        this.metadata.setFormat('bitsPerSample', streamInfo.bitsPerSample);\n        this.metadata.setFormat('sampleRate', streamInfo.sampleRate);\n        if (streamInfo.totalSamples > 0) {\n            this.metadata.setFormat('duration', streamInfo.totalSamples / streamInfo.sampleRate);\n        }\n    }\n    /**\n     * Read VORBIS_COMMENT from tokenizer\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async readComment(dataLen) {\n        const data = await this.tokenizer.readToken(new Uint8ArrayType(dataLen));\n        return this.parseComment(data);\n    }\n    /**\n     * Parse VORBIS_COMMENT\n     * Ref: https://www.xiph.org/vorbis/doc/Vorbis_I_spec.html#x1-640004.2.3\n     */\n    async parseComment(data) {\n        const decoder = new VorbisDecoder(data, 0);\n        const vendor = decoder.readStringUtf8();\n        if (vendor.length > 0) {\n            this.metadata.setFormat('tool', vendor);\n        }\n        const commentListLength = decoder.readInt32();\n        const tags = new Array(commentListLength);\n        for (let i = 0; i < commentListLength; i++) {\n            tags[i] = decoder.parseUserComment();\n        }\n        await Promise.all(tags.map(tag => {\n            if (tag.key === 'ENCODER') {\n                this.metadata.setFormat('tool', tag.value);\n            }\n            return this.addTag(tag.key, tag.value);\n        }));\n    }\n    async parsePicture(dataLen) {\n        if (this.options.skipCovers) {\n            return this.tokenizer.ignore(dataLen);\n        }\n        return this.addPictureTag(await this.tokenizer.readToken(new VorbisPictureToken(dataLen)));\n    }\n    addPictureTag(picture) {\n        return this.addTag('METADATA_BLOCK_PICTURE', picture);\n    }\n    addTag(id, value) {\n        return this.vorbisParser.addTag(id, value);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}