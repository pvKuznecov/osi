{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.json.stringify.js\";\nimport \"core-js/modules/esnext.json.parse.js\";\nimport \"core-js/modules/web.url-search-params.delete.js\";\nimport \"core-js/modules/web.url-search-params.has.js\";\nimport \"core-js/modules/web.url-search-params.size.js\";\n// import { resolve } from 'core-js/fn/promise';\nimport { LangPack } from './lang';\nimport { parseBlob } from 'music-metadata';\nimport debounce from 'lodash/debounce'; // или реализовать свой\n\nexport default {\n  name: 'OSIMPlayer',\n  props: {\n    windowId: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {\n      LangData: {},\n      PlayList: [],\n      isPlaying: false,\n      durationAll: 0,\n      TargetTrack: null,\n      ShowConfig: {\n        playlist: {\n          artist: true,\n          album: true,\n          genre: true,\n          duration: true\n        }\n      },\n      isLoading: false,\n      totalFiles: 0,\n      MAX_FILE_SIZE: 100 * 1024 * 1024,\n      // 100MB,\n      MAX_PLAYLIST_SIZE: 1000 * 1024 * 1024,\n      // 1000MB,\n      curFilesSize: 0,\n      audioDurations: {},\n      // Объект для \"длительностей\"\n      VolumeLvl: 0.5,\n      VolumeLvl_save: 0.5,\n      currentIndex: 0,\n      urlsData: new Map(),\n      TrackTime: {\n        current: 0,\n        duration: 0\n      },\n      SilentMode: false,\n      ShuffleMode: false,\n      currentCoverUrl: null,\n      prevCoverUrl: null,\n      CoverMode: true,\n      playlistStorageKey: 'mplayer_playlist'\n    };\n  },\n  mounted() {\n    console.log('MPlayer app mounted with windowId:', this.windowId);\n    const userLang = navigator.language || navigator.userLanguage;\n    const userLangS = userLang.split('-')[0];\n    this.UserLang = userLangS;\n    const LangPackData = LangPack;\n    this.LangData = userLangS && LangPackData && LangPackData[userLangS] ? LangPackData[userLangS] : LangPackData.en;\n  },\n  beforeUnmount() {\n    this.PlayerAction_Pause();\n\n    // Освобождаем все ObjectURL\n    if (this.currentCoverUrl) {\n      URL.revokeObjectURL(this.currentCoverUrl);\n    }\n    this.urlsData.forEach(url => URL.revokeObjectURL(url));\n    this.urlsData.clear();\n  },\n  computed: {\n    currentTrack() {\n      const curindex = this.currentIndex + '';\n      const preplist = this.PlayList;\n      if (preplist && preplist.length > 0 && curindex) {\n        let tr = preplist[curindex];\n        console.log(\"tr\", tr);\n        return tr;\n      } else {\n        return null;\n      }\n    },\n    currentTrack_time() {\n      return this.ShowerTime(this.TrackTime.current);\n    }\n  },\n  watch: {\n    currentTrack: {\n      handler() {\n        this.updateCoverUrl();\n      },\n      immediate: true\n    }\n  },\n  methods: {\n    savePlaylistToStorage() {\n      try {\n        // Собираем упрощенные данные о треках\n        const playlistData = this.PlayList.map(track => ({\n          id: track.common.id,\n          name: track.name,\n          size: track.size,\n          type: track.type,\n          lastModified: track.lastModified,\n          webkitRelativePath: track.webkitRelativePath || '',\n          metadata: {\n            title: track.common.title,\n            artist: track.common.artist,\n            album: track.common.album,\n            duration: track.common.duration,\n            year: track.common.year,\n            genre: track.common.genre,\n            // Можно сохранить обложку в base64\n            picture: track.common.picture?.[0] ? {\n              format: track.common.picture[0].format,\n              data: Array.from(track.common.picture[0].data)\n            } : null\n          }\n        }));\n        localStorage.setItem(this.playlistStorageKey, JSON.stringify(playlistData));\n        console.log('Плейлист сохранен в localStorage');\n      } catch (e) {\n        console.warn('Не удалось сохранить плейлист:', e);\n        this.showError('Ошибка сохранения плейлиста');\n      }\n    },\n    async loadPlaylistFromStorage() {\n      try {\n        const savedData = localStorage.getItem(this.playlistStorageKey);\n        if (!savedData) return;\n        const savedPlaylist = JSON.parse(savedData);\n        const restoredTracks = [];\n\n        // Показываем индикатор загрузки\n        this.isLoading = true;\n        for (const savedItem of savedPlaylist) {\n          try {\n            // Пытаемся восстановить файл из сохраненного пути\n            const file = await this.restoreFileFromData(savedItem);\n            if (file) {\n              restoredTracks.push(file);\n            }\n          } catch (error) {\n            console.warn(`Не удалось восстановить файл ${savedItem.name}:`, error);\n          }\n        }\n        this.isLoading = false;\n        if (restoredTracks.length > 0) {\n          this.PlayList = restoredTracks;\n          this.showNotification(`Загружено ${restoredTracks.length} треков из сохраненного плейлиста`);\n        }\n      } catch (e) {\n        console.warn('Ошибка загрузки плейлиста:', e);\n        this.isLoading = false;\n      }\n    },\n    // Сброс input (открывает возможность повторно загружать те-же файлы)\n    resetInput(inputElement) {\n      inputElement.value = '';\n    },\n    showError(message) {\n      alert(message);\n      console.error(message);\n    },\n    getAudioDurationSimple(track) {\n      return new Promise((resolve, reject) => {\n        const audio = new Audio();\n        const objectURL = URL.createObjectURL(track);\n        audio.src = objectURL;\n        const mkClean = () => {\n          audio.removeEventListener('loadedmetadata', onLoaded);\n          audio.removeEventListener('error', onError);\n          URL.revokeObjectURL(objectURL); // Освобождаем ссылку в памяти \"URL\" - сразу\n        };\n        const onLoaded = () => {\n          mkClean();\n          resolve(audio.duration);\n        };\n        // чистим ссылки, возвращаем ошибку\n        const onError = e => {\n          mkClean();\n          reject(e);\n        };\n        audio.addEventListener('loadedmetadata', onLoaded); //подписка на событие \"загрузка мета-данных\"\n        audio.addEventListener('error', onError); //подписка на событие \"ошибка\"\n\n        // Таймаут\n        setTimeout(() => {\n          mkClean();\n          reject(new Error('Timeout loading audio metadata'));\n        }, 3000);\n      });\n    },\n    async handleFileSelect(event) {\n      const files = Array.from(event.target.files);\n      const audioFiles = files.filter(file => this.isAudio(file));\n      if (audioFiles.length === 0) {\n        this.showError('Не было выбрано ни одного файла!');\n        this.resetInput(event.target);\n        return;\n      }\n      let cSize = 0;\n      files.forEach(function (item) {\n        cSize += item.size;\n      });\n      if (cSize > this.MAX_PLAYLIST_SIZE) {\n        this.showError('Превышен лимит доступной памяти! Максимальный размер - ' + this.MAX_PLAYLIST_SIZE / 1024 / 1024 + \"MB.\");\n        this.resetInput(event.target);\n        return;\n      }\n      this.isLoading = true;\n      this.totalFiles = audioFiles.length;\n      let validFiles = [];\n      for (let afile of audioFiles) {\n        try {\n          const afile_size = afile.size;\n          const afile_name = afile.name;\n          const blob = afile.slice(0, afile_size);\n          let parseData = await parseBlob(blob);\n          let trackDKey = `${afile_name}-${afile_size}`;\n\n          // afile.common = parseData.common;\n          // afile.common.id = trackDKey;\n          afile.common = {\n            ...parseData.common,\n            id: trackDKey\n          };\n          afile.common.url = this.getObjectURL(afile);\n          if (!this.audioDurations[trackDKey]) {\n            try {\n              let tduration = await this.getAudioDurationSimple(afile);\n              this.audioDurations[trackDKey] = tduration;\n              afile.common.duration = tduration;\n              this.durationAll += tduration;\n            } catch (error) {\n              console.warn(`Не удалось получить длительность для ${afile.name}:`, error);\n              this.audioDurations[trackDKey] = 0;\n            }\n          }\n          validFiles.push(afile);\n        } catch (error) {\n          console.error('Ошибка при разборе файла: ', error);\n        }\n      }\n      this.isLoading = false;\n      if (validFiles.length > 0) {\n        this.PlayList = validFiles;\n      } else {\n        alert('Не было выбрано ни одного аудиофайла!');\n      }\n    },\n    // проверка \"на аудиофайл\"\n    isAudio(file) {\n      if (file.size > this.MAX_FILE_SIZE) {\n        console.warn(`Файл ${file.name} слишком большой: ${file.size} bytes`);\n        return false;\n      }\n      const audioTypes = ['audio/mpeg', 'audio/wav', 'audio/flac', 'audio/ogg', 'audio/aac', 'audio/x-m4a'];\n      const extension = file.name.toLowerCase().split('.').pop();\n      const audioExtensions = ['mp3', 'wav', 'flac', 'ogg', 'aac', 'm4a'];\n      return audioTypes.includes(file.type) || audioExtensions.includes(extension);\n    },\n    formatDuration(seconds) {\n      if (!seconds || isNaN(seconds)) {\n        return '00:00';\n      } else {\n        return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${Math.floor(seconds % 60).toString().padStart(2, '0')}`;\n      }\n    },\n    VolimePlus() {\n      const AudioElement = document.querySelector('#main_audio');\n      if (AudioElement) {\n        if (this.VolumeLvl < 1) {\n          this.VolumeLvl = parseFloat((this.VolumeLvl + 0.1).toFixed(1));\n        }\n        AudioElement.volume = this.VolumeLvl;\n      }\n    },\n    VolumeMinus() {\n      const AudioElement = document.querySelector('#main_audio');\n      if (this.VolumeLvl > 0) {\n        this.VolumeLvl = parseFloat((this.VolumeLvl - 0.1).toFixed(1));\n      }\n      AudioElement.volume = this.VolumeLvl;\n    },\n    PlayerAction_Play() {\n      const AudioElement = document.querySelector('#main_audio');\n      if (AudioElement) {\n        AudioElement.play().then(() => {\n          this.isPlaying = true;\n        }).catch(error => {\n          console.error('Ошибка воспроизведения:', error);\n          this.isPlaying = false;\n          // Показать пользователю сообщение\n          this.showError('Не удалось воспроизвести трек');\n        });\n      }\n    },\n    PlayerAction_Pause() {\n      const AudioElement = document.querySelector('#main_audio');\n      const preplist = this.PlayList;\n      if (AudioElement && preplist && preplist.length > 0) {\n        AudioElement.pause();\n        this.isPlaying = false;\n      }\n    },\n    PlayerAction_Stop() {\n      const AudioElement = document.querySelector('#main_audio');\n      const preplist = this.PlayList;\n      if (AudioElement && preplist && preplist.length > 0) {\n        this.PlayerAction_Pause();\n        setTimeout(() => {\n          this.TrackTime.current = 0;\n        }, 300);\n      }\n    },\n    PlayerAction_PrevTrack() {\n      const curindex = this.currentIndex;\n      const preplist = this.PlayList;\n      if (preplist && preplist.length > 0) {\n        this.PlayerAction_Pause();\n        if (!this.ShuffleMode) {\n          this.currentIndex = curindex == 0 ? preplist.length - 1 : curindex - 1;\n        } else {\n          this.currentIndex = this.Get_randomInteger(0, preplist.length - 1);\n        }\n        setTimeout(() => {\n          this.PlayerAction_Play();\n        }, 500);\n      }\n    },\n    PlayerAction_NextTrack() {\n      const curindex = this.currentIndex;\n      const preplist = this.PlayList;\n      if (preplist && preplist.length > 0) {\n        this.PlayerAction_Pause();\n        if (!this.ShuffleMode) {\n          this.currentIndex = curindex == preplist.length - 1 ? 0 : curindex + 1;\n        } else {\n          this.currentIndex = this.Get_randomInteger(0, preplist.length - 1);\n        }\n        setTimeout(() => {\n          this.PlayerAction_Play();\n        }, 500);\n      }\n    },\n    getObjectURL(track) {\n      const key = track.common.id;\n      if (!this.urlsData.has(key)) {\n        this.urlsData.set(key, URL.createObjectURL(track));\n      }\n      return this.urlsData.get(key);\n    },\n    Chng_TrackRangeTime() {\n      const AudioElement = document.querySelector('#main_audio');\n      const TrackTimeElement = document.querySelector('#main_tracktime');\n      AudioElement.currentTime = TrackTimeElement.value;\n    },\n    ShowerTime(iSec) {\n      if (iSec && typeof iSec == 'number') {\n        let inpSec = Math.trunc(iSec);\n        let strMin = Math.trunc(inpSec / 60) < 10 ? \"0\" + Math.trunc(inpSec / 60) : Math.trunc(inpSec / 60);\n        let strSec = inpSec % 60 < 10 ? \"0\" + inpSec % 60 : inpSec % 60;\n        return strMin + \":\" + strSec;\n      } else {\n        return \"00:00\";\n      }\n    },\n    onTimeUpdate: debounce(function (event) {\n      const audio = event.target;\n      this.TrackTime.current = audio.currentTime;\n      this.TrackTime.duration = audio.duration || 0;\n\n      // Обновляем слайдер\n      const trackTimeElement = document.querySelector('#main_tracktime');\n      if (trackTimeElement) {\n        trackTimeElement.value = this.TrackTime.current;\n      }\n    }, 100),\n    Chng_SilentMode() {\n      const Silent = this.SilentMode;\n      if (!Silent) {\n        this.VolumeLvl_save = this.VolumeLvl;\n        this.VolumeLvl = 0;\n      } else {\n        this.VolumeLvl = this.VolumeLvl_save;\n      }\n      this.SilentMode = !Silent;\n    },\n    Get_randomInteger(min, max) {\n      let rand = min + Math.random() * (max + 1 - min);\n      return Math.floor(rand);\n    },\n    Chng_ShuffleMode() {\n      this.ShuffleMode = !this.ShuffleMode;\n    },\n    SelectTrack(inpIndex) {\n      if (inpIndex !== this.currentIndex) {\n        this.PlayerAction_Pause();\n        this.currentIndex = inpIndex;\n        setTimeout(() => {\n          this.PlayerAction_Play();\n        }, 500);\n      }\n    },\n    Chng_CoverMode(modeIndex) {\n      this.CoverMode = modeIndex === 0 ? false : true;\n    },\n    updateCoverUrl() {\n      // Освобождаем предыдущий URL\n      if (this.prevCoverUrl) {\n        URL.revokeObjectURL(this.prevCoverUrl);\n      }\n      if (this.currentTrack?.common?.picture?.[0]) {\n        const cover = this.currentTrack.common.picture[0];\n        const blob = new Blob([cover.data], {\n          type: cover.format\n        });\n        this.currentCoverUrl = URL.createObjectURL(blob);\n        this.prevCoverUrl = this.currentCoverUrl;\n      } else {\n        this.currentCoverUrl = null;\n      }\n    }\n  }\n};","map":{"version":3,"names":["LangPack","parseBlob","debounce","name","props","windowId","type","String","required","data","LangData","PlayList","isPlaying","durationAll","TargetTrack","ShowConfig","playlist","artist","album","genre","duration","isLoading","totalFiles","MAX_FILE_SIZE","MAX_PLAYLIST_SIZE","curFilesSize","audioDurations","VolumeLvl","VolumeLvl_save","currentIndex","urlsData","Map","TrackTime","current","SilentMode","ShuffleMode","currentCoverUrl","prevCoverUrl","CoverMode","playlistStorageKey","mounted","console","log","userLang","navigator","language","userLanguage","userLangS","split","UserLang","LangPackData","en","beforeUnmount","PlayerAction_Pause","URL","revokeObjectURL","forEach","url","clear","computed","currentTrack","curindex","preplist","length","tr","currentTrack_time","ShowerTime","watch","handler","updateCoverUrl","immediate","methods","savePlaylistToStorage","playlistData","map","track","id","common","size","lastModified","webkitRelativePath","metadata","title","year","picture","format","Array","from","localStorage","setItem","JSON","stringify","e","warn","showError","loadPlaylistFromStorage","savedData","getItem","savedPlaylist","parse","restoredTracks","savedItem","file","restoreFileFromData","push","error","showNotification","resetInput","inputElement","value","message","alert","getAudioDurationSimple","Promise","resolve","reject","audio","Audio","objectURL","createObjectURL","src","mkClean","removeEventListener","onLoaded","onError","addEventListener","setTimeout","Error","handleFileSelect","event","files","target","audioFiles","filter","isAudio","cSize","item","validFiles","afile","afile_size","afile_name","blob","slice","parseData","trackDKey","getObjectURL","tduration","audioTypes","extension","toLowerCase","pop","audioExtensions","includes","formatDuration","seconds","isNaN","Math","floor","toString","padStart","VolimePlus","AudioElement","document","querySelector","parseFloat","toFixed","volume","VolumeMinus","PlayerAction_Play","play","then","catch","pause","PlayerAction_Stop","PlayerAction_PrevTrack","Get_randomInteger","PlayerAction_NextTrack","key","has","set","get","Chng_TrackRangeTime","TrackTimeElement","currentTime","iSec","inpSec","trunc","strMin","strSec","onTimeUpdate","trackTimeElement","Chng_SilentMode","Silent","min","max","rand","random","Chng_ShuffleMode","SelectTrack","inpIndex","Chng_CoverMode","modeIndex","cover","Blob"],"sources":["/home/kup/my_projects/vue/osi/src/apps/system/OSIMPlayer/OSIMPlayer.vue"],"sourcesContent":["<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script>\n    // import { resolve } from 'core-js/fn/promise';\n    import { LangPack } from './lang';\n    import { parseBlob } from 'music-metadata';\n    import debounce from 'lodash/debounce'; // или реализовать свой\n\n    export default {\n        name: 'OSIMPlayer',\n\n        props: {\n            windowId: {\n                type: String,\n                required: true\n            },\n        },\n\n        data() {\n            return {\n                LangData: {},\n                PlayList: [],\n                isPlaying: false,\n                durationAll: 0,\n                TargetTrack: null,\n                ShowConfig: {\n                    playlist: {\n                        artist: true,\n                        album: true,\n                        genre: true,\n                        duration: true,\n                    }\n                },\n                isLoading: false,\n                totalFiles: 0,\n                MAX_FILE_SIZE: 100 * 1024 * 1024, // 100MB,\n                MAX_PLAYLIST_SIZE: 1000 * 1024 * 1024, // 1000MB,\n                curFilesSize: 0,\n                audioDurations: {}, // Объект для \"длительностей\"\n                VolumeLvl: 0.5,\n                VolumeLvl_save: 0.5,\n                currentIndex: 0,\n                urlsData: new Map(),\n                TrackTime: { current: 0, duration: 0},\n                SilentMode: false,\n                ShuffleMode: false,\n                currentCoverUrl: null,\n                prevCoverUrl: null,\n                CoverMode: true,\n                playlistStorageKey: 'mplayer_playlist',\n            }\n        },\n\n        mounted() {\n            console.log('MPlayer app mounted with windowId:', this.windowId);\n\n            const userLang = navigator.language || navigator.userLanguage;\n            const userLangS = userLang.split('-')[0];\n            this.UserLang = userLangS; \n            \n            const LangPackData = LangPack;\n            this.LangData = (userLangS && LangPackData && LangPackData[userLangS]) ? LangPackData[userLangS] : LangPackData.en;\n        },\n\n        beforeUnmount() {\n            this.PlayerAction_Pause();\n\n            // Освобождаем все ObjectURL\n            if (this.currentCoverUrl) {\n                URL.revokeObjectURL(this.currentCoverUrl);\n            }\n\n            this.urlsData.forEach(url => URL.revokeObjectURL(url));\n            this.urlsData.clear();\n        },\n\n        computed: {\n            currentTrack() {\n                const curindex = this.currentIndex + '';\n                const preplist = this.PlayList;\n\n                if (preplist && preplist.length > 0 && curindex) {\n                    let tr = preplist[curindex];\n                    console.log(\"tr\", tr);\n                    return tr;\n                } else {\n                    return null;\n                }\n            },\n\n            currentTrack_time() {\n                return this.ShowerTime(this.TrackTime.current);\n            },\n        },\n\n        watch: {\n            currentTrack: {\n                handler() {\n                    this.updateCoverUrl();\n                },\n                immediate: true\n            },\n        },\n\n        methods: {\n            savePlaylistToStorage() {\n                try {\n                    // Собираем упрощенные данные о треках\n                    const playlistData = this.PlayList.map(track => ({\n                        id: track.common.id,\n                        name: track.name,\n                        size: track.size,\n                        type: track.type,\n                        lastModified: track.lastModified,\n                        webkitRelativePath: track.webkitRelativePath || '',\n                        metadata: {\n                        title: track.common.title,\n                        artist: track.common.artist,\n                        album: track.common.album,\n                        duration: track.common.duration,\n                        year: track.common.year,\n                        genre: track.common.genre,\n                        // Можно сохранить обложку в base64\n                        picture: track.common.picture?.[0] ? {\n                            format: track.common.picture[0].format,\n                            data: Array.from(track.common.picture[0].data)\n                        } : null\n                        }\n                    }));\n                    \n                    localStorage.setItem(this.playlistStorageKey, JSON.stringify(playlistData));\n                    console.log('Плейлист сохранен в localStorage');\n                } catch (e) {\n                    console.warn('Не удалось сохранить плейлист:', e);\n                    this.showError('Ошибка сохранения плейлиста');\n                }\n            },\n\n            async loadPlaylistFromStorage() {\n                try {\n                    const savedData = localStorage.getItem(this.playlistStorageKey);\n                    \n                    if (!savedData) return;\n                \n                    const savedPlaylist = JSON.parse(savedData);\n                    const restoredTracks = [];\n                \n                    // Показываем индикатор загрузки\n                    this.isLoading = true;\n                \n                    for (const savedItem of savedPlaylist) {\n                        try {\n                            // Пытаемся восстановить файл из сохраненного пути\n                            const file = await this.restoreFileFromData(savedItem);\n                            \n                            if (file) {\n                                restoredTracks.push(file);\n                            }\n                        } catch (error) {\n                            console.warn(`Не удалось восстановить файл ${savedItem.name}:`, error);\n                        }\n                    }\n                \n                    this.isLoading = false;\n                \n                    if (restoredTracks.length > 0) {\n                        this.PlayList = restoredTracks;\n                        this.showNotification(`Загружено ${restoredTracks.length} треков из сохраненного плейлиста`);\n                    }\n                } catch (e) {\n                    console.warn('Ошибка загрузки плейлиста:', e);\n                    this.isLoading = false;\n                }\n            },\n\n            // Сброс input (открывает возможность повторно загружать те-же файлы)\n            resetInput(inputElement) { inputElement.value = ''; },\n\n            showError(message) {\n                alert(message);\n                console.error(message);\n            },\n\n            getAudioDurationSimple(track) {\n                return new Promise((resolve, reject) => {\n                    const audio = new Audio();\n                    const objectURL = URL.createObjectURL(track);\n\n                    audio.src = objectURL;\n\n                    const mkClean = () => {\n                        audio.removeEventListener('loadedmetadata', onLoaded);\n                        audio.removeEventListener('error', onError);\n                        URL.revokeObjectURL(objectURL); // Освобождаем ссылку в памяти \"URL\" - сразу\n                    };\n\n                    const onLoaded = () => {\n                        mkClean();\n                        resolve(audio.duration);\n                    };\n                    // чистим ссылки, возвращаем ошибку\n                    const onError = (e) => {\n                        mkClean();\n                        reject(e);\n                    };\n                    \n                    audio.addEventListener('loadedmetadata', onLoaded); //подписка на событие \"загрузка мета-данных\"\n                    audio.addEventListener('error', onError); //подписка на событие \"ошибка\"\n                    \n                    // Таймаут\n                    setTimeout(() => {\n                        mkClean();\n                        reject(new Error('Timeout loading audio metadata'));\n                    }, 3000);\n                });\n            },\n            \n            async handleFileSelect(event) {\n                const files = Array.from(event.target.files);\n                const audioFiles = files.filter(file => this.isAudio(file));\n\n                if (audioFiles.length === 0) {\n                    this.showError('Не было выбрано ни одного файла!');\n                    this.resetInput(event.target);\n                    \n                    return;\n                }\n\n                let cSize = 0;\n                files.forEach(function(item) { cSize += item.size; });\n\n                if (cSize > this.MAX_PLAYLIST_SIZE) {\n                    this.showError('Превышен лимит доступной памяти! Максимальный размер - ' + (this.MAX_PLAYLIST_SIZE / 1024 / 1024) + \"MB.\");\n                    this.resetInput(event.target);\n\n                    return;\n                }\n\n                this.isLoading = true;\n                this.totalFiles = audioFiles.length;\n\n                let validFiles = [];\n\n                for (let afile of audioFiles) {\n                    try {\n                        const afile_size = afile.size;\n                        const afile_name = afile.name;\n                        const blob = afile.slice(0, afile_size);\n\n                        let parseData = await parseBlob(blob);\n                        let trackDKey = `${afile_name}-${afile_size}`;\n\n                        // afile.common = parseData.common;\n                        // afile.common.id = trackDKey;\n                        afile.common = {\n                            ...parseData.common,\n                            id: trackDKey,                            \n                        };\n\n                        afile.common.url = this.getObjectURL(afile);\n                        \n\n                        if (!this.audioDurations[trackDKey]) {\n                            try {\n                                let tduration = await this.getAudioDurationSimple(afile);\n                                this.audioDurations[trackDKey] = tduration;\n                                afile.common.duration = tduration;\n                                this.durationAll += tduration;\n                            } catch (error) {\n                                console.warn(`Не удалось получить длительность для ${afile.name}:`, error);\n                                this.audioDurations[trackDKey] = 0;\n                            }\n                        }\n\n                        validFiles.push(afile);\n                    } catch (error) {\n                        console.error('Ошибка при разборе файла: ', error);\n                    }\n                }\n\n                this.isLoading = false;\n\n                if (validFiles.length > 0) {\n                    this.PlayList = validFiles;\n                } else {\n                    alert('Не было выбрано ни одного аудиофайла!');\n                }\n            },\n\n            // проверка \"на аудиофайл\"\n            isAudio(file) {\n                if (file.size > this.MAX_FILE_SIZE) {\n                    console.warn(`Файл ${file.name} слишком большой: ${file.size} bytes`);\n                    return false;\n                }\n\n                const audioTypes = [ 'audio/mpeg', 'audio/wav', 'audio/flac', 'audio/ogg', 'audio/aac', 'audio/x-m4a' ];\n                const extension = file.name.toLowerCase().split('.').pop();\n                const audioExtensions = ['mp3', 'wav', 'flac', 'ogg', 'aac', 'm4a'];\n            \n                return audioTypes.includes(file.type) || audioExtensions.includes(extension);\n            },\n\n            formatDuration(seconds) {\n                if (!seconds || isNaN(seconds)) {\n                    return '00:00';\n                } else {\n                    return `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${Math.floor(seconds % 60).toString().padStart(2, '0')}`;\n                }\n            },\n\n            VolimePlus() {\n                const AudioElement = document.querySelector('#main_audio');\n\n                if (AudioElement) {\n                    if (this.VolumeLvl < 1) {\n                        this.VolumeLvl = parseFloat((this.VolumeLvl + 0.1).toFixed(1));\n                    }\n                    AudioElement.volume = this.VolumeLvl;\n                }\n            },\n            VolumeMinus() {\n                const AudioElement = document.querySelector('#main_audio');\n                if (this.VolumeLvl > 0) {\n                    this.VolumeLvl = parseFloat((this.VolumeLvl - 0.1).toFixed(1));\n                }\n                AudioElement.volume = this.VolumeLvl;\n            },\n\n            PlayerAction_Play() {\n                const AudioElement = document.querySelector('#main_audio');\n                \n                if (AudioElement) {\n                AudioElement.play()\n                    .then(() => {\n                    this.isPlaying = true;\n                    })\n                    .catch(error => {\n                    console.error('Ошибка воспроизведения:', error);\n                    this.isPlaying = false;\n                    // Показать пользователю сообщение\n                    this.showError('Не удалось воспроизвести трек');\n                    });\n                }\n            },\n            PlayerAction_Pause() {\n                const AudioElement = document.querySelector('#main_audio');\n                const preplist = this.PlayList;\n\n                if (AudioElement && preplist && preplist.length > 0) {\n                    AudioElement.pause();\n                    this.isPlaying = false;\n                }\n            },\n            PlayerAction_Stop() {\n                const AudioElement = document.querySelector('#main_audio');\n                const preplist = this.PlayList;\n\n                if (AudioElement && preplist && preplist.length > 0) {\n                    this.PlayerAction_Pause();\n                    \n                    setTimeout(() => {\n                        this.TrackTime.current = 0;\n                    }, 300);\n                }                \n            },\n            PlayerAction_PrevTrack() {\n                const curindex = this.currentIndex;\n                const preplist = this.PlayList;\n                \n\n                if (preplist && preplist.length > 0) {\n                    this.PlayerAction_Pause();\n\n                    if (!this.ShuffleMode) {\n                        this.currentIndex = (curindex == 0) ? (preplist.length - 1) : (curindex - 1);\n                    } else {\n                        this.currentIndex = this.Get_randomInteger(0, (preplist.length - 1));\n                    }\n\n                    setTimeout(() => {\n                        this.PlayerAction_Play();\n                    }, 500);\n                }\n            },\n            PlayerAction_NextTrack() {\n                const curindex = this.currentIndex;\n                const preplist = this.PlayList;\n\n                if (preplist && preplist.length > 0) {\n                    this.PlayerAction_Pause();\n\n                    if (!this.ShuffleMode) {\n                        this.currentIndex = (curindex == (preplist.length - 1)) ? 0 : curindex + 1;\n                    } else {\n                        this.currentIndex = this.Get_randomInteger(0, (preplist.length - 1));\n                    }\n\n                    setTimeout(() => {\n                        this.PlayerAction_Play();\n                    }, 500);\n                    \n                }\n            },\n\n            getObjectURL(track) {\n                const key = track.common.id;\n\n                if (!this.urlsData.has(key)) {\n                    this.urlsData.set(key, URL.createObjectURL(track));\n                }\n                return this.urlsData.get(key);\n            },\n\n            Chng_TrackRangeTime() {\n                const AudioElement = document.querySelector('#main_audio');\n                const TrackTimeElement = document.querySelector('#main_tracktime');\n\n                AudioElement.currentTime = TrackTimeElement.value;\n            },\n\n            ShowerTime(iSec) {\n                if (iSec && typeof iSec == 'number') {\n                    let inpSec = Math.trunc(iSec);\n                    let strMin = (Math.trunc(inpSec / 60) < 10) ? (\"0\" + Math.trunc(inpSec / 60)) : Math.trunc(inpSec / 60);\n                    let strSec = (inpSec % 60 < 10) ? (\"0\" + (inpSec % 60)) : (inpSec % 60);\n\n                    return strMin + \":\" + strSec;\n                } else {\n                    return \"00:00\";\n                }\n            },\n\n            onTimeUpdate: debounce(function(event) {\n                const audio = event.target;\n\n                this.TrackTime.current = audio.currentTime;\n                this.TrackTime.duration = audio.duration || 0;\n                \n                // Обновляем слайдер\n                const trackTimeElement = document.querySelector('#main_tracktime');\n\n                if (trackTimeElement) {\n                    trackTimeElement.value = this.TrackTime.current;\n                }\n            }, 100),\n\n            Chng_SilentMode() {\n                const Silent = this.SilentMode;\n\n                if (!Silent) {\n                    this.VolumeLvl_save = this.VolumeLvl;\n                    this.VolumeLvl = 0;\n                } else {\n                    this.VolumeLvl = this.VolumeLvl_save;\n                }\n\n                this.SilentMode = !Silent;\n            },\n\n            Get_randomInteger(min, max) {\n                let rand = min + Math.random() * (max + 1 - min);\n                \n                return Math.floor(rand);\n            },\n\n            Chng_ShuffleMode() { this.ShuffleMode = !this.ShuffleMode; },\n\n            SelectTrack(inpIndex) {\n                if (inpIndex !== this.currentIndex) {\n                    this.PlayerAction_Pause();\n                    this.currentIndex = inpIndex;\n\n                    setTimeout(() => {                    \n                        this.PlayerAction_Play();\n                    }, 500);\n                }\n            },\n\n            Chng_CoverMode(modeIndex) { this.CoverMode = (modeIndex === 0) ? false : true; },\n\n            updateCoverUrl() {\n                // Освобождаем предыдущий URL\n                if (this.prevCoverUrl) {\n                    URL.revokeObjectURL(this.prevCoverUrl);\n                }\n                \n                if (this.currentTrack?.common?.picture?.[0]) {\n                    const cover = this.currentTrack.common.picture[0];\n                    const blob = new Blob([cover.data], { type: cover.format });\n                    \n                    this.currentCoverUrl = URL.createObjectURL(blob);\n                    this.prevCoverUrl = this.currentCoverUrl;\n                } else {\n                    this.currentCoverUrl = null;\n                }\n            },\n        }\n    }\n</script>"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}