{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport initDebug from 'debug';\nimport * as Token from 'token-types';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { Genres } from '../id3v1/ID3v1Parser.js';\nimport { Atom } from './Atom.js';\nimport * as AtomToken from './AtomToken.js';\nimport { ChapterTrackReferenceBox, Mp4ContentError } from './AtomToken.js';\nimport { TrackType } from '../type.js';\nimport { uint8ArrayToHex } from 'uint8array-extras';\nimport { textDecode } from '@borewit/text-codec';\nconst debug = initDebug('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n  raw: {\n    lossy: false,\n    format: 'raw'\n  },\n  MAC3: {\n    lossy: true,\n    format: 'MACE 3:1'\n  },\n  MAC6: {\n    lossy: true,\n    format: 'MACE 6:1'\n  },\n  ima4: {\n    lossy: true,\n    format: 'IMA 4:1'\n  },\n  ulaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  alaw: {\n    lossy: true,\n    format: 'uLaw 2:1'\n  },\n  Qclp: {\n    lossy: true,\n    format: 'QUALCOMM PureVoice'\n  },\n  '.mp3': {\n    lossy: true,\n    format: 'MPEG-1 layer 3'\n  },\n  alac: {\n    lossy: false,\n    format: 'ALAC'\n  },\n  'ac-3': {\n    lossy: true,\n    format: 'AC-3'\n  },\n  mp4a: {\n    lossy: true,\n    format: 'MPEG-4/AAC'\n  },\n  mp4s: {\n    lossy: true,\n    format: 'MP4S'\n  },\n  // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n  c608: {\n    lossy: true,\n    format: 'CEA-608'\n  },\n  c708: {\n    lossy: true,\n    format: 'CEA-708'\n  }\n};\nfunction distinct(value, index, self) {\n  return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nexport class MP4Parser extends BasicParser {\n  constructor() {\n    super(...arguments);\n    this.tracks = new Map();\n    this.hasVideoTrack = false;\n    this.hasAudioTrack = true;\n    this.atomParsers = {\n      /**\n       * Parse movie header (mvhd) atom\n       * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n       */\n      mvhd: async len => {\n        const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n        this.metadata.setFormat('creationTime', mvhd.creationTime);\n        this.metadata.setFormat('modificationTime', mvhd.modificationTime);\n      },\n      chap: async len => {\n        const td = this.getTrackDescription();\n        const trackIds = [];\n        while (len >= Token.UINT32_BE.len) {\n          trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n          len -= Token.UINT32_BE.len;\n        }\n        td.chapterList = trackIds;\n      },\n      /**\n       * Parse mdat atom.\n       * Will scan for chapters\n       */\n      mdat: async len => {\n        if (this.options.includeChapters) {\n          const trackWithChapters = [...this.tracks.values()].filter(track => track.chapterList);\n          if (trackWithChapters.length === 1) {\n            const chapterTrackIds = trackWithChapters[0].chapterList;\n            const chapterTracks = [...this.tracks.values()].filter(track => chapterTrackIds.indexOf(track.header.trackId) !== -1);\n            if (chapterTracks.length === 1) {\n              return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n            }\n          }\n        }\n        await this.tokenizer.ignore(len);\n      },\n      ftyp: async len => {\n        const types = [];\n        while (len > 0) {\n          const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n          len -= AtomToken.ftyp.len;\n          const value = ftype.type.replace(/\\W/g, '');\n          if (value.length > 0) {\n            types.push(value); // unshift for backward compatibility\n          }\n        }\n        debug(`ftyp: ${types.join('/')}`);\n        const x = types.filter(distinct).join('/');\n        this.metadata.setFormat('container', x);\n      },\n      /**\n       * Parse sample description atom\n       */\n      stsd: async len => {\n        const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n        const trackDescription = this.getTrackDescription();\n        trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n      },\n      /**\n       * Parse sample-sizes atom ('stsz')\n       */\n      stsz: async len => {\n        const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n        const td = this.getTrackDescription();\n        td.sampleSize = stsz.sampleSize;\n        td.sampleSizeTable = stsz.entries;\n      },\n      date: async len => {\n        const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n        await this.addTag('date', date);\n      }\n    };\n  }\n  static read_BE_Integer(array, signed) {\n    const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\n    const token = Token[integerType];\n    if (!token) {\n      throw new Mp4ContentError(`Token for integer type not found: \"${integerType}\"`);\n    }\n    return Number(token.get(array, 0));\n  }\n  async parse() {\n    this.hasVideoTrack = false;\n    this.hasAudioTrack = true;\n    this.tracks.clear();\n    let remainingFileSize = this.tokenizer.fileInfo.size || 0;\n    while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n      try {\n        const token = await this.tokenizer.peekToken(AtomToken.Header);\n        if (token.name === '\\0\\0\\0\\0') {\n          const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n          debug(errMsg);\n          this.addWarning(errMsg);\n          break;\n        }\n      } catch (error) {\n        if (error instanceof Error) {\n          const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n          debug(errMsg);\n          this.addWarning(errMsg);\n        } else throw error;\n        break;\n      }\n      const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n      remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\n    }\n    // Post process metadata\n    const formatList = [];\n    this.tracks.forEach(track => {\n      const trackFormats = [];\n      track.soundSampleDescription.forEach(ssd => {\n        const streamInfo = {};\n        const encoderInfo = encoderDict[ssd.dataFormat];\n        if (encoderInfo) {\n          trackFormats.push(encoderInfo.format);\n          streamInfo.codecName = encoderInfo.format;\n        } else {\n          streamInfo.codecName = `<${ssd.dataFormat}>`;\n        }\n        if (ssd.description) {\n          const {\n            description\n          } = ssd;\n          if (description.sampleRate > 0) {\n            streamInfo.type = TrackType.audio;\n            streamInfo.audio = {\n              samplingFrequency: description.sampleRate,\n              bitDepth: description.sampleSize,\n              channels: description.numAudioChannels\n            };\n          }\n        }\n        this.metadata.addStreamInfo(streamInfo);\n      });\n      if (trackFormats.length >= 1) {\n        formatList.push(trackFormats.join('/'));\n      }\n    });\n    if (formatList.length > 0) {\n      this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n    }\n    const audioTracks = [...this.tracks.values()].filter(track => {\n      return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n    });\n    // Calculate duration and bitrate of audio tracks\n    for (const audioTrack of audioTracks) {\n      if (audioTrack.media.header && audioTrack.media.header.timeScale > 0) {\n        audioTrack.sampleRate = audioTrack.media.header.timeScale;\n        if (audioTrack.media.header.duration > 0) {\n          debug('Using duration defined on audio track');\n          audioTrack.samples = audioTrack.media.header.duration;\n          audioTrack.duration = audioTrack.samples / audioTrack.sampleRate;\n        }\n        if (audioTrack.fragments.length > 0) {\n          debug('Calculate duration defined in track fragments');\n          let totalTimeUnits = 0;\n          audioTrack.sizeInBytes = 0;\n          for (const fragment of audioTrack.fragments) {\n            for (const sample of fragment.trackRun.samples) {\n              const dur = sample.sampleDuration ?? fragment.header.defaultSampleDuration ?? 0;\n              const size = sample.sampleSize ?? fragment.header.defaultSampleSize ?? 0;\n              if (dur === 0) {\n                throw new Error(\"Missing sampleDuration and no defaultSampleDuration in track fragment header\");\n              }\n              if (size === 0) {\n                throw new Error(\"Missing sampleSize and no defaultSampleSize in track fragment header\");\n              }\n              totalTimeUnits += dur;\n              audioTrack.sizeInBytes += size;\n            }\n          }\n          if (!audioTrack.samples) {\n            audioTrack.samples = totalTimeUnits;\n          }\n          if (!audioTrack.duration) {\n            audioTrack.duration = totalTimeUnits / audioTrack.sampleRate;\n          }\n        } else if (audioTrack.sampleSizeTable.length > 0) {\n          audioTrack.sizeInBytes = audioTrack.sampleSizeTable.reduce((sum, n) => sum + n, 0);\n        }\n      }\n      const ssd = audioTrack.soundSampleDescription[0];\n      if (ssd.description && audioTrack.media.header) {\n        this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n        this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n        this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n        if (audioTrack.media.header.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\n          const totalSampleSize = audioTrack.timeToSampleTable.map(ttstEntry => ttstEntry.count * ttstEntry.duration).reduce((total, sampleSize) => total + sampleSize);\n          audioTrack.duration = totalSampleSize / ssd.description.sampleRate;\n        }\n      }\n      const encoderInfo = encoderDict[ssd.dataFormat];\n      if (encoderInfo) {\n        this.metadata.setFormat('lossless', !encoderInfo.lossy);\n      }\n    }\n    if (audioTracks.length >= 1) {\n      const firstAudioTrack = audioTracks[0];\n      if (firstAudioTrack.duration) {\n        this.metadata.setFormat('duration', firstAudioTrack.duration);\n        if (firstAudioTrack.sizeInBytes) {\n          this.metadata.setFormat('bitrate', 8 * firstAudioTrack.sizeInBytes / firstAudioTrack.duration);\n        }\n      }\n    }\n    this.metadata.setFormat('hasAudio', this.hasAudioTrack);\n    this.metadata.setFormat('hasVideo', this.hasVideoTrack);\n  }\n  async handleAtom(atom, remaining) {\n    if (atom.parent) {\n      switch (atom.parent.header.name) {\n        case 'ilst':\n        case '<id>':\n          return this.parseMetadataItemData(atom);\n        case 'moov':\n          switch (atom.header.name) {\n            case 'trak':\n              return this.parseTrackBox(atom);\n            case 'udta':\n              return this.parseTrackBox(atom);\n          }\n          break;\n        case 'moof':\n          switch (atom.header.name) {\n            case 'traf':\n              return this.parseTrackFragmentBox(atom);\n          }\n      }\n    }\n    // const payloadLength = atom.getPayloadLength(remaining);\n    if (this.atomParsers[atom.header.name]) {\n      return this.atomParsers[atom.header.name](remaining);\n    }\n    debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\n    await this.tokenizer.ignore(remaining);\n  }\n  getTrackDescription() {\n    // ToDo: pick the right track, not the last track!!!!\n    const tracks = [...this.tracks.values()];\n    return tracks[tracks.length - 1];\n  }\n  async addTag(id, value) {\n    await this.metadata.addTag(tagFormat, id, value);\n  }\n  addWarning(message) {\n    debug(`Warning: ${message}`);\n    this.metadata.addWarning(message);\n  }\n  /**\n   * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n   * @param metaAtom\n   * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n   */\n  parseMetadataItemData(metaAtom) {\n    let tagKey = metaAtom.header.name;\n    return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n      const payLoadLength = child.getPayloadLength(remaining);\n      switch (child.header.name) {\n        case 'data':\n          // value atom\n          return this.parseValueAtom(tagKey, child);\n        case 'name': // name atom (optional)\n        case 'mean':\n        case 'rate':\n          {\n            const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n            tagKey += `:${name.name}`;\n            break;\n          }\n        default:\n          {\n            const uint8Array = await this.tokenizer.readToken(new Token.Uint8ArrayType(payLoadLength));\n            this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${textDecode(uint8Array, 'ascii')}`);\n          }\n      }\n    }, metaAtom.getPayloadLength(0));\n  }\n  async parseValueAtom(tagKey, metaAtom) {\n    const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\n    if (dataAtom.type.set !== 0) {\n      throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);\n    }\n    // Use well-known-type table\n    // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n    switch (dataAtom.type.type) {\n      case 0:\n        // reserved: Reserved for use where no type needs to be indicated\n        switch (tagKey) {\n          case 'trkn':\n          case 'disk':\n            {\n              const num = Token.UINT8.get(dataAtom.value, 3);\n              const of = Token.UINT8.get(dataAtom.value, 5);\n              // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n              await this.addTag(tagKey, `${num}/${of}`);\n              break;\n            }\n          case 'gnre':\n            {\n              const genreInt = Token.UINT8.get(dataAtom.value, 1);\n              const genreStr = Genres[genreInt - 1];\n              // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n              await this.addTag(tagKey, genreStr);\n              break;\n            }\n          case 'rate':\n            {\n              const rate = textDecode(dataAtom.value, 'ascii');\n              await this.addTag(tagKey, rate);\n              break;\n            }\n          default:\n            debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);\n        }\n        break;\n      case 1: // UTF-8: Without any count or NULL terminator\n      case 18:\n        // Unknown: Found in m4b in combination with a '©gen' tag\n        await this.addTag(tagKey, textDecode(dataAtom.value));\n        break;\n      case 13:\n        // JPEG\n        if (this.options.skipCovers) break;\n        await this.addTag(tagKey, {\n          format: 'image/jpeg',\n          data: Uint8Array.from(dataAtom.value)\n        });\n        break;\n      case 14:\n        // PNG\n        if (this.options.skipCovers) break;\n        await this.addTag(tagKey, {\n          format: 'image/png',\n          data: Uint8Array.from(dataAtom.value)\n        });\n        break;\n      case 21:\n        // BE Signed Integer\n        await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\n        break;\n      case 22:\n        // BE Unsigned Integer\n        await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\n        break;\n      case 65:\n        // An 8-bit signed integer\n        await this.addTag(tagKey, Token.UINT8.get(dataAtom.value, 0));\n        break;\n      case 66:\n        // A big-endian 16-bit signed integer\n        await this.addTag(tagKey, Token.UINT16_BE.get(dataAtom.value, 0));\n        break;\n      case 67:\n        // A big-endian 32-bit signed integer\n        await this.addTag(tagKey, Token.UINT32_BE.get(dataAtom.value, 0));\n        break;\n      default:\n        this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n    }\n  }\n  async parseTrackBox(trakBox) {\n    // @ts-expect-error\n    const track = {\n      media: {},\n      fragments: []\n    };\n    await trakBox.readAtoms(this.tokenizer, async (child, remaining) => {\n      const payLoadLength = child.getPayloadLength(remaining);\n      switch (child.header.name) {\n        case 'chap':\n          {\n            const chap = await this.tokenizer.readToken(new ChapterTrackReferenceBox(remaining));\n            track.chapterList = chap;\n            break;\n          }\n        case 'tkhd':\n          // TrackHeaderBox\n          track.header = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(payLoadLength));\n          break;\n        case 'hdlr':\n          // TrackHeaderBox\n          track.handler = await this.tokenizer.readToken(new AtomToken.HandlerBox(payLoadLength));\n          track.isAudio = () => track.handler.handlerType === 'audi' || track.handler.handlerType === 'soun';\n          track.isVideo = () => track.handler.handlerType === 'vide';\n          if (track.isAudio()) {\n            this.hasAudioTrack = true;\n          } else if (track.isVideo()) {\n            this.hasVideoTrack = true;\n          }\n          break;\n        case 'mdhd':\n          {\n            // Parse media header (mdhd) box\n            const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(payLoadLength));\n            track.media.header = mdhd_data;\n            break;\n          }\n        case 'stco':\n          {\n            const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(payLoadLength));\n            track.chunkOffsetTable = stco.entries; // remember chunk offsets\n            break;\n          }\n        case 'stsc':\n          {\n            // sample-to-Chunk box\n            const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(payLoadLength));\n            track.sampleToChunkTable = stsc.entries;\n            break;\n          }\n        case 'stsd':\n          {\n            // sample description box\n            const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(payLoadLength));\n            track.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n            break;\n          }\n        case 'stts':\n          {\n            // time-to-sample table\n            const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(payLoadLength));\n            track.timeToSampleTable = stts.entries;\n            break;\n          }\n        case 'stsz':\n          {\n            const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(payLoadLength));\n            track.sampleSize = stsz.sampleSize;\n            track.sampleSizeTable = stsz.entries;\n            break;\n          }\n        case 'dinf':\n        case 'vmhd':\n        case 'smhd':\n          debug(`Ignoring: ${child.header.name}`);\n          await this.tokenizer.ignore(payLoadLength);\n          break;\n        default:\n          {\n            debug(`Unexpected track box: ${child.header.name}`);\n            await this.tokenizer.ignore(payLoadLength);\n          }\n      }\n    }, trakBox.getPayloadLength(0));\n    // Register track\n    this.tracks.set(track.header.trackId, track);\n  }\n  parseTrackFragmentBox(trafBox) {\n    let tfhd;\n    return trafBox.readAtoms(this.tokenizer, async (child, remaining) => {\n      const payLoadLength = child.getPayloadLength(remaining);\n      switch (child.header.name) {\n        case 'tfhd':\n          {\n            // TrackFragmentHeaderBox\n            const fragmentHeaderBox = new AtomToken.TrackFragmentHeaderBox(child.getPayloadLength(remaining));\n            tfhd = await this.tokenizer.readToken(fragmentHeaderBox);\n            break;\n          }\n        case 'tfdt':\n          // TrackFragmentBaseMediaDecodeTimeBo\n          await this.tokenizer.ignore(payLoadLength);\n          break;\n        case 'trun':\n          {\n            // TrackRunBox\n            const trackRunBox = new AtomToken.TrackRunBox(payLoadLength);\n            const trun = await this.tokenizer.readToken(trackRunBox);\n            if (tfhd) {\n              const track = this.tracks.get(tfhd.trackId);\n              track?.fragments.push({\n                header: tfhd,\n                trackRun: trun\n              });\n            }\n            break;\n          }\n        default:\n          {\n            debug(`Unexpected box: ${child.header.name}`);\n            await this.tokenizer.ignore(payLoadLength);\n          }\n      }\n    }, trafBox.getPayloadLength(0));\n  }\n  /**\n   * @param sampleDescription\n   * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n   */\n  parseSoundSampleDescription(sampleDescription) {\n    const ssd = {\n      dataFormat: sampleDescription.dataFormat,\n      dataReferenceIndex: sampleDescription.dataReferenceIndex\n    };\n    let offset = 0;\n    if (sampleDescription.description) {\n      const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n      offset += AtomToken.SoundSampleDescriptionVersion.len;\n      if (version.version === 0 || version.version === 1) {\n        // Sound Sample Description (Version 0)\n        ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n      } else {\n        debug(`Warning: sound-sample-description ${version} not implemented`);\n      }\n    }\n    return ssd;\n  }\n  async parseChapterTrack(chapterTrack, track, len) {\n    if (!chapterTrack.sampleSize) {\n      if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length) throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n    }\n    const chapters = [];\n    for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n      const start = chapterTrack.timeToSampleTable.slice(0, i).reduce((acc, cur) => acc + cur.duration, 0);\n      const chunkOffset = chapterTrack.chunkOffsetTable[i];\n      const nextChunkLen = chunkOffset - this.tokenizer.position;\n      const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n      len -= nextChunkLen + sampleSize;\n      if (len < 0) throw new Mp4ContentError('Chapter chunk exceeding token length');\n      await this.tokenizer.ignore(nextChunkLen);\n      const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n      debug(`Chapter ${i + 1}: ${title}`);\n      const chapter = {\n        title,\n        timeScale: chapterTrack.media.header ? chapterTrack.media.header.timeScale : 0,\n        start,\n        sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n      };\n      debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${track.header.duration}`); // ToDo, use media duration if required!!!\n      chapters.push(chapter);\n    }\n    this.metadata.setFormat('chapters', chapters);\n    await this.tokenizer.ignore(len);\n  }\n  findSampleOffset(track, chapterOffset) {\n    let chunkIndex = 0;\n    while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n      ++chunkIndex;\n    }\n    return this.getChunkDuration(chunkIndex + 1, track);\n  }\n  getChunkDuration(chunkId, track) {\n    let ttsi = 0;\n    let ttsc = track.timeToSampleTable[ttsi].count;\n    let ttsd = track.timeToSampleTable[ttsi].duration;\n    let curChunkId = 1;\n    let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n    let totalDuration = 0;\n    while (curChunkId < chunkId) {\n      const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n      totalDuration += nrOfSamples * ttsd;\n      ttsc -= nrOfSamples;\n      samplesPerChunk -= nrOfSamples;\n      if (samplesPerChunk === 0) {\n        ++curChunkId;\n        samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n      } else {\n        ++ttsi;\n        ttsc = track.timeToSampleTable[ttsi].count;\n        ttsd = track.timeToSampleTable[ttsi].duration;\n      }\n    }\n    return totalDuration;\n  }\n  getSamplesPerChunk(chunkId, stcTable) {\n    for (let i = 0; i < stcTable.length - 1; ++i) {\n      if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n        return stcTable[i].samplesPerChunk;\n      }\n    }\n    return stcTable[stcTable.length - 1].samplesPerChunk;\n  }\n}","map":{"version":3,"names":["initDebug","Token","BasicParser","Genres","Atom","AtomToken","ChapterTrackReferenceBox","Mp4ContentError","TrackType","uint8ArrayToHex","textDecode","debug","tagFormat","encoderDict","raw","lossy","format","MAC3","MAC6","ima4","ulaw","alaw","Qclp","alac","mp4a","mp4s","c608","c708","distinct","value","index","self","indexOf","MP4Parser","constructor","arguments","tracks","Map","hasVideoTrack","hasAudioTrack","atomParsers","mvhd","len","tokenizer","readToken","MvhdAtom","metadata","setFormat","creationTime","modificationTime","chap","td","getTrackDescription","trackIds","UINT32_BE","push","readNumber","chapterList","mdat","options","includeChapters","trackWithChapters","values","filter","track","length","chapterTrackIds","chapterTracks","header","trackId","parseChapterTrack","ignore","ftyp","types","ftype","type","replace","join","x","stsd","StsdAtom","trackDescription","soundSampleDescription","table","map","dfEntry","parseSoundSampleDescription","stsz","StszAtom","sampleSize","sampleSizeTable","entries","date","StringType","addTag","read_BE_Integer","array","signed","integerType","token","Number","get","parse","clear","remainingFileSize","fileInfo","size","peekToken","Header","name","errMsg","position","addWarning","error","Error","message","rootAtom","readAtom","atom","remaining","handleAtom","BigInt","formatList","forEach","trackFormats","ssd","streamInfo","encoderInfo","dataFormat","codecName","description","sampleRate","audio","samplingFrequency","bitDepth","channels","numAudioChannels","addStreamInfo","audioTracks","audioTrack","media","timeScale","duration","samples","fragments","totalTimeUnits","sizeInBytes","fragment","sample","trackRun","dur","sampleDuration","defaultSampleDuration","defaultSampleSize","reduce","sum","n","timeToSampleTable","totalSampleSize","ttstEntry","count","total","firstAudioTrack","parent","parseMetadataItemData","parseTrackBox","parseTrackFragmentBox","atomPath","id","metaAtom","tagKey","readAtoms","child","payLoadLength","getPayloadLength","parseValueAtom","NameAtom","uint8Array","Uint8ArrayType","dataAtom","DataAtom","set","num","UINT8","of","genreInt","genreStr","rate","skipCovers","data","Uint8Array","from","UINT16_BE","trakBox","TrackHeaderAtom","handler","HandlerBox","isAudio","handlerType","isVideo","mdhd_data","MdhdAtom","stco","StcoAtom","chunkOffsetTable","stsc","StscAtom","sampleToChunkTable","stts","SttsAtom","trafBox","tfhd","fragmentHeaderBox","TrackFragmentHeaderBox","trackRunBox","TrackRunBox","trun","sampleDescription","dataReferenceIndex","offset","version","SoundSampleDescriptionVersion","SoundSampleDescriptionV0","chapterTrack","chapters","i","start","slice","acc","cur","chunkOffset","nextChunkLen","title","ChapterText","chapter","sampleOffset","findSampleOffset","chapterOffset","chunkIndex","getChunkDuration","chunkId","ttsi","ttsc","ttsd","curChunkId","samplesPerChunk","getSamplesPerChunk","totalDuration","nrOfSamples","Math","min","stcTable","firstChunk"],"sources":["/home/kup/my_projects/vue/osi/node_modules/music-metadata/lib/mp4/MP4Parser.js"],"sourcesContent":["import initDebug from 'debug';\nimport * as Token from 'token-types';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { Genres } from '../id3v1/ID3v1Parser.js';\nimport { Atom } from './Atom.js';\nimport * as AtomToken from './AtomToken.js';\nimport { ChapterTrackReferenceBox, Mp4ContentError } from './AtomToken.js';\nimport { TrackType } from '../type.js';\nimport { uint8ArrayToHex } from 'uint8array-extras';\nimport { textDecode } from '@borewit/text-codec';\nconst debug = initDebug('music-metadata:parser:MP4');\nconst tagFormat = 'iTunes';\nconst encoderDict = {\n    raw: {\n        lossy: false,\n        format: 'raw'\n    },\n    MAC3: {\n        lossy: true,\n        format: 'MACE 3:1'\n    },\n    MAC6: {\n        lossy: true,\n        format: 'MACE 6:1'\n    },\n    ima4: {\n        lossy: true,\n        format: 'IMA 4:1'\n    },\n    ulaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    alaw: {\n        lossy: true,\n        format: 'uLaw 2:1'\n    },\n    Qclp: {\n        lossy: true,\n        format: 'QUALCOMM PureVoice'\n    },\n    '.mp3': {\n        lossy: true,\n        format: 'MPEG-1 layer 3'\n    },\n    alac: {\n        lossy: false,\n        format: 'ALAC'\n    },\n    'ac-3': {\n        lossy: true,\n        format: 'AC-3'\n    },\n    mp4a: {\n        lossy: true,\n        format: 'MPEG-4/AAC'\n    },\n    mp4s: {\n        lossy: true,\n        format: 'MP4S'\n    },\n    // Closed Captioning Media, https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-SW87\n    c608: {\n        lossy: true,\n        format: 'CEA-608'\n    },\n    c708: {\n        lossy: true,\n        format: 'CEA-708'\n    }\n};\nfunction distinct(value, index, self) {\n    return self.indexOf(value) === index;\n}\n/*\n * Parser for the MP4 (MPEG-4 Part 14) container format\n * Standard: ISO/IEC 14496-14\n * supporting:\n * - QuickTime container\n * - MP4 File Format\n * - 3GPP file format\n * - 3GPP2 file format\n *\n * MPEG-4 Audio / Part 3 (.m4a)& MPEG 4 Video (m4v, mp4) extension.\n * Support for Apple iTunes tags as found in a M4A/M4V files.\n * Ref:\n *   https://en.wikipedia.org/wiki/ISO_base_media_file_format\n *   https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/Metadata/Metadata.html\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\n *   https://github.com/sergiomb2/libmp4v2/wiki/iTunesMetadata\n *   https://wiki.multimedia.cx/index.php/QuickTime_container\n */\nexport class MP4Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.tracks = new Map();\n        this.hasVideoTrack = false;\n        this.hasAudioTrack = true;\n        this.atomParsers = {\n            /**\n             * Parse movie header (mvhd) atom\n             * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap2/qtff2.html#//apple_ref/doc/uid/TP40000939-CH204-56313\n             */\n            mvhd: async (len) => {\n                const mvhd = await this.tokenizer.readToken(new AtomToken.MvhdAtom(len));\n                this.metadata.setFormat('creationTime', mvhd.creationTime);\n                this.metadata.setFormat('modificationTime', mvhd.modificationTime);\n            },\n            chap: async (len) => {\n                const td = this.getTrackDescription();\n                const trackIds = [];\n                while (len >= Token.UINT32_BE.len) {\n                    trackIds.push(await this.tokenizer.readNumber(Token.UINT32_BE));\n                    len -= Token.UINT32_BE.len;\n                }\n                td.chapterList = trackIds;\n            },\n            /**\n             * Parse mdat atom.\n             * Will scan for chapters\n             */\n            mdat: async (len) => {\n                if (this.options.includeChapters) {\n                    const trackWithChapters = [...this.tracks.values()].filter(track => track.chapterList);\n                    if (trackWithChapters.length === 1) {\n                        const chapterTrackIds = trackWithChapters[0].chapterList;\n                        const chapterTracks = [...this.tracks.values()].filter(track => chapterTrackIds.indexOf(track.header.trackId) !== -1);\n                        if (chapterTracks.length === 1) {\n                            return this.parseChapterTrack(chapterTracks[0], trackWithChapters[0], len);\n                        }\n                    }\n                }\n                await this.tokenizer.ignore(len);\n            },\n            ftyp: async (len) => {\n                const types = [];\n                while (len > 0) {\n                    const ftype = await this.tokenizer.readToken(AtomToken.ftyp);\n                    len -= AtomToken.ftyp.len;\n                    const value = ftype.type.replace(/\\W/g, '');\n                    if (value.length > 0) {\n                        types.push(value); // unshift for backward compatibility\n                    }\n                }\n                debug(`ftyp: ${types.join('/')}`);\n                const x = types.filter(distinct).join('/');\n                this.metadata.setFormat('container', x);\n            },\n            /**\n             * Parse sample description atom\n             */\n            stsd: async (len) => {\n                const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(len));\n                const trackDescription = this.getTrackDescription();\n                trackDescription.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n            },\n            /**\n             * Parse sample-sizes atom ('stsz')\n             */\n            stsz: async (len) => {\n                const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(len));\n                const td = this.getTrackDescription();\n                td.sampleSize = stsz.sampleSize;\n                td.sampleSizeTable = stsz.entries;\n            },\n            date: async (len) => {\n                const date = await this.tokenizer.readToken(new Token.StringType(len, 'utf-8'));\n                await this.addTag('date', date);\n            }\n        };\n    }\n    static read_BE_Integer(array, signed) {\n        const integerType = (signed ? 'INT' : 'UINT') + array.length * 8 + (array.length > 1 ? '_BE' : '');\n        const token = Token[integerType];\n        if (!token) {\n            throw new Mp4ContentError(`Token for integer type not found: \"${integerType}\"`);\n        }\n        return Number(token.get(array, 0));\n    }\n    async parse() {\n        this.hasVideoTrack = false;\n        this.hasAudioTrack = true;\n        this.tracks.clear();\n        let remainingFileSize = this.tokenizer.fileInfo.size || 0;\n        while (!this.tokenizer.fileInfo.size || remainingFileSize > 0) {\n            try {\n                const token = await this.tokenizer.peekToken(AtomToken.Header);\n                if (token.name === '\\0\\0\\0\\0') {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: box.id=0`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                    break;\n                }\n            }\n            catch (error) {\n                if (error instanceof Error) {\n                    const errMsg = `Error at offset=${this.tokenizer.position}: ${error.message}`;\n                    debug(errMsg);\n                    this.addWarning(errMsg);\n                }\n                else\n                    throw error;\n                break;\n            }\n            const rootAtom = await Atom.readAtom(this.tokenizer, (atom, remaining) => this.handleAtom(atom, remaining), null, remainingFileSize);\n            remainingFileSize -= rootAtom.header.length === BigInt(0) ? remainingFileSize : Number(rootAtom.header.length);\n        }\n        // Post process metadata\n        const formatList = [];\n        this.tracks.forEach(track => {\n            const trackFormats = [];\n            track.soundSampleDescription.forEach(ssd => {\n                const streamInfo = {};\n                const encoderInfo = encoderDict[ssd.dataFormat];\n                if (encoderInfo) {\n                    trackFormats.push(encoderInfo.format);\n                    streamInfo.codecName = encoderInfo.format;\n                }\n                else {\n                    streamInfo.codecName = `<${ssd.dataFormat}>`;\n                }\n                if (ssd.description) {\n                    const { description } = ssd;\n                    if (description.sampleRate > 0) {\n                        streamInfo.type = TrackType.audio;\n                        streamInfo.audio = {\n                            samplingFrequency: description.sampleRate,\n                            bitDepth: description.sampleSize,\n                            channels: description.numAudioChannels\n                        };\n                    }\n                }\n                this.metadata.addStreamInfo(streamInfo);\n            });\n            if (trackFormats.length >= 1) {\n                formatList.push(trackFormats.join('/'));\n            }\n        });\n        if (formatList.length > 0) {\n            this.metadata.setFormat('codec', formatList.filter(distinct).join('+'));\n        }\n        const audioTracks = [...this.tracks.values()].filter(track => {\n            return track.soundSampleDescription.length >= 1 && track.soundSampleDescription[0].description && track.soundSampleDescription[0].description.numAudioChannels > 0;\n        });\n        // Calculate duration and bitrate of audio tracks\n        for (const audioTrack of audioTracks) {\n            if (audioTrack.media.header && audioTrack.media.header.timeScale > 0) {\n                audioTrack.sampleRate = audioTrack.media.header.timeScale;\n                if (audioTrack.media.header.duration > 0) {\n                    debug('Using duration defined on audio track');\n                    audioTrack.samples = audioTrack.media.header.duration;\n                    audioTrack.duration = audioTrack.samples / audioTrack.sampleRate;\n                }\n                if (audioTrack.fragments.length > 0) {\n                    debug('Calculate duration defined in track fragments');\n                    let totalTimeUnits = 0;\n                    audioTrack.sizeInBytes = 0;\n                    for (const fragment of audioTrack.fragments) {\n                        for (const sample of fragment.trackRun.samples) {\n                            const dur = sample.sampleDuration ?? fragment.header.defaultSampleDuration ?? 0;\n                            const size = sample.sampleSize ?? fragment.header.defaultSampleSize ?? 0;\n                            if (dur === 0) {\n                                throw new Error(\"Missing sampleDuration and no defaultSampleDuration in track fragment header\");\n                            }\n                            if (size === 0) {\n                                throw new Error(\"Missing sampleSize and no defaultSampleSize in track fragment header\");\n                            }\n                            totalTimeUnits += dur;\n                            audioTrack.sizeInBytes += size;\n                        }\n                    }\n                    if (!audioTrack.samples) {\n                        audioTrack.samples = totalTimeUnits;\n                    }\n                    if (!audioTrack.duration) {\n                        audioTrack.duration = totalTimeUnits / audioTrack.sampleRate;\n                    }\n                }\n                else if (audioTrack.sampleSizeTable.length > 0) {\n                    audioTrack.sizeInBytes = audioTrack.sampleSizeTable.reduce((sum, n) => sum + n, 0);\n                }\n            }\n            const ssd = audioTrack.soundSampleDescription[0];\n            if (ssd.description && audioTrack.media.header) {\n                this.metadata.setFormat('sampleRate', ssd.description.sampleRate);\n                this.metadata.setFormat('bitsPerSample', ssd.description.sampleSize);\n                this.metadata.setFormat('numberOfChannels', ssd.description.numAudioChannels);\n                if (audioTrack.media.header.timeScale === 0 && audioTrack.timeToSampleTable.length > 0) {\n                    const totalSampleSize = audioTrack.timeToSampleTable\n                        .map(ttstEntry => ttstEntry.count * ttstEntry.duration)\n                        .reduce((total, sampleSize) => total + sampleSize);\n                    audioTrack.duration = totalSampleSize / ssd.description.sampleRate;\n                }\n            }\n            const encoderInfo = encoderDict[ssd.dataFormat];\n            if (encoderInfo) {\n                this.metadata.setFormat('lossless', !encoderInfo.lossy);\n            }\n        }\n        if (audioTracks.length >= 1) {\n            const firstAudioTrack = audioTracks[0];\n            if (firstAudioTrack.duration) {\n                this.metadata.setFormat('duration', firstAudioTrack.duration);\n                if (firstAudioTrack.sizeInBytes) {\n                    this.metadata.setFormat('bitrate', 8 * firstAudioTrack.sizeInBytes / firstAudioTrack.duration);\n                }\n            }\n        }\n        this.metadata.setFormat('hasAudio', this.hasAudioTrack);\n        this.metadata.setFormat('hasVideo', this.hasVideoTrack);\n    }\n    async handleAtom(atom, remaining) {\n        if (atom.parent) {\n            switch (atom.parent.header.name) {\n                case 'ilst':\n                case '<id>':\n                    return this.parseMetadataItemData(atom);\n                case 'moov':\n                    switch (atom.header.name) {\n                        case 'trak':\n                            return this.parseTrackBox(atom);\n                        case 'udta':\n                            return this.parseTrackBox(atom);\n                    }\n                    break;\n                case 'moof':\n                    switch (atom.header.name) {\n                        case 'traf':\n                            return this.parseTrackFragmentBox(atom);\n                    }\n            }\n        }\n        // const payloadLength = atom.getPayloadLength(remaining);\n        if (this.atomParsers[atom.header.name]) {\n            return this.atomParsers[atom.header.name](remaining);\n        }\n        debug(`No parser for atom path=${atom.atomPath}, payload-len=${remaining}, ignoring atom`);\n        await this.tokenizer.ignore(remaining);\n    }\n    getTrackDescription() {\n        // ToDo: pick the right track, not the last track!!!!\n        const tracks = [...this.tracks.values()];\n        return tracks[tracks.length - 1];\n    }\n    async addTag(id, value) {\n        await this.metadata.addTag(tagFormat, id, value);\n    }\n    addWarning(message) {\n        debug(`Warning: ${message}`);\n        this.metadata.addWarning(message);\n    }\n    /**\n     * Parse data of Meta-item-list-atom (item of 'ilst' atom)\n     * @param metaAtom\n     * Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW8\n     */\n    parseMetadataItemData(metaAtom) {\n        let tagKey = metaAtom.header.name;\n        return metaAtom.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'data': // value atom\n                    return this.parseValueAtom(tagKey, child);\n                case 'name': // name atom (optional)\n                case 'mean':\n                case 'rate': {\n                    const name = await this.tokenizer.readToken(new AtomToken.NameAtom(payLoadLength));\n                    tagKey += `:${name.name}`;\n                    break;\n                }\n                default: {\n                    const uint8Array = await this.tokenizer.readToken(new Token.Uint8ArrayType(payLoadLength));\n                    this.addWarning(`Unsupported meta-item: ${tagKey}[${child.header.name}] => value=${uint8ArrayToHex(uint8Array)} ascii=${textDecode(uint8Array, 'ascii')}`);\n                }\n            }\n        }, metaAtom.getPayloadLength(0));\n    }\n    async parseValueAtom(tagKey, metaAtom) {\n        const dataAtom = await this.tokenizer.readToken(new AtomToken.DataAtom(Number(metaAtom.header.length) - AtomToken.Header.len));\n        if (dataAtom.type.set !== 0) {\n            throw new Mp4ContentError(`Unsupported type-set != 0: ${dataAtom.type.set}`);\n        }\n        // Use well-known-type table\n        // Ref: https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\n        switch (dataAtom.type.type) {\n            case 0: // reserved: Reserved for use where no type needs to be indicated\n                switch (tagKey) {\n                    case 'trkn':\n                    case 'disk': {\n                        const num = Token.UINT8.get(dataAtom.value, 3);\n                        const of = Token.UINT8.get(dataAtom.value, 5);\n                        // console.log(\"  %s[data] = %s/%s\", tagKey, num, of);\n                        await this.addTag(tagKey, `${num}/${of}`);\n                        break;\n                    }\n                    case 'gnre': {\n                        const genreInt = Token.UINT8.get(dataAtom.value, 1);\n                        const genreStr = Genres[genreInt - 1];\n                        // console.log(\"  %s[data] = %s\", tagKey, genreStr);\n                        await this.addTag(tagKey, genreStr);\n                        break;\n                    }\n                    case 'rate': {\n                        const rate = textDecode(dataAtom.value, 'ascii');\n                        await this.addTag(tagKey, rate);\n                        break;\n                    }\n                    default:\n                        debug(`unknown proprietary value type for: ${metaAtom.atomPath}`);\n                }\n                break;\n            case 1: // UTF-8: Without any count or NULL terminator\n            case 18: // Unknown: Found in m4b in combination with a '©gen' tag\n                await this.addTag(tagKey, textDecode(dataAtom.value));\n                break;\n            case 13: // JPEG\n                if (this.options.skipCovers)\n                    break;\n                await this.addTag(tagKey, {\n                    format: 'image/jpeg',\n                    data: Uint8Array.from(dataAtom.value)\n                });\n                break;\n            case 14: // PNG\n                if (this.options.skipCovers)\n                    break;\n                await this.addTag(tagKey, {\n                    format: 'image/png',\n                    data: Uint8Array.from(dataAtom.value)\n                });\n                break;\n            case 21: // BE Signed Integer\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, true));\n                break;\n            case 22: // BE Unsigned Integer\n                await this.addTag(tagKey, MP4Parser.read_BE_Integer(dataAtom.value, false));\n                break;\n            case 65: // An 8-bit signed integer\n                await this.addTag(tagKey, Token.UINT8.get(dataAtom.value, 0));\n                break;\n            case 66: // A big-endian 16-bit signed integer\n                await this.addTag(tagKey, Token.UINT16_BE.get(dataAtom.value, 0));\n                break;\n            case 67: // A big-endian 32-bit signed integer\n                await this.addTag(tagKey, Token.UINT32_BE.get(dataAtom.value, 0));\n                break;\n            default:\n                this.addWarning(`atom key=${tagKey}, has unknown well-known-type (data-type): ${dataAtom.type.type}`);\n        }\n    }\n    async parseTrackBox(trakBox) {\n        // @ts-expect-error\n        const track = {\n            media: {},\n            fragments: []\n        };\n        await trakBox.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'chap': {\n                    const chap = await this.tokenizer.readToken(new ChapterTrackReferenceBox(remaining));\n                    track.chapterList = chap;\n                    break;\n                }\n                case 'tkhd': // TrackHeaderBox\n                    track.header = await this.tokenizer.readToken(new AtomToken.TrackHeaderAtom(payLoadLength));\n                    break;\n                case 'hdlr': // TrackHeaderBox\n                    track.handler = await this.tokenizer.readToken(new AtomToken.HandlerBox(payLoadLength));\n                    track.isAudio = () => track.handler.handlerType === 'audi' || track.handler.handlerType === 'soun';\n                    track.isVideo = () => track.handler.handlerType === 'vide';\n                    if (track.isAudio()) {\n                        this.hasAudioTrack = true;\n                    }\n                    else if (track.isVideo()) {\n                        this.hasVideoTrack = true;\n                    }\n                    break;\n                case 'mdhd': { // Parse media header (mdhd) box\n                    const mdhd_data = await this.tokenizer.readToken(new AtomToken.MdhdAtom(payLoadLength));\n                    track.media.header = mdhd_data;\n                    break;\n                }\n                case 'stco': {\n                    const stco = await this.tokenizer.readToken(new AtomToken.StcoAtom(payLoadLength));\n                    track.chunkOffsetTable = stco.entries; // remember chunk offsets\n                    break;\n                }\n                case 'stsc': { // sample-to-Chunk box\n                    const stsc = await this.tokenizer.readToken(new AtomToken.StscAtom(payLoadLength));\n                    track.sampleToChunkTable = stsc.entries;\n                    break;\n                }\n                case 'stsd': { // sample description box\n                    const stsd = await this.tokenizer.readToken(new AtomToken.StsdAtom(payLoadLength));\n                    track.soundSampleDescription = stsd.table.map(dfEntry => this.parseSoundSampleDescription(dfEntry));\n                    break;\n                }\n                case 'stts': { // time-to-sample table\n                    const stts = await this.tokenizer.readToken(new AtomToken.SttsAtom(payLoadLength));\n                    track.timeToSampleTable = stts.entries;\n                    break;\n                }\n                case 'stsz': {\n                    const stsz = await this.tokenizer.readToken(new AtomToken.StszAtom(payLoadLength));\n                    track.sampleSize = stsz.sampleSize;\n                    track.sampleSizeTable = stsz.entries;\n                    break;\n                }\n                case 'dinf':\n                case 'vmhd':\n                case 'smhd':\n                    debug(`Ignoring: ${child.header.name}`);\n                    await this.tokenizer.ignore(payLoadLength);\n                    break;\n                default: {\n                    debug(`Unexpected track box: ${child.header.name}`);\n                    await this.tokenizer.ignore(payLoadLength);\n                }\n            }\n        }, trakBox.getPayloadLength(0));\n        // Register track\n        this.tracks.set(track.header.trackId, track);\n    }\n    parseTrackFragmentBox(trafBox) {\n        let tfhd;\n        return trafBox.readAtoms(this.tokenizer, async (child, remaining) => {\n            const payLoadLength = child.getPayloadLength(remaining);\n            switch (child.header.name) {\n                case 'tfhd': { // TrackFragmentHeaderBox\n                    const fragmentHeaderBox = new AtomToken.TrackFragmentHeaderBox(child.getPayloadLength(remaining));\n                    tfhd = await this.tokenizer.readToken(fragmentHeaderBox);\n                    break;\n                }\n                case 'tfdt': // TrackFragmentBaseMediaDecodeTimeBo\n                    await this.tokenizer.ignore(payLoadLength);\n                    break;\n                case 'trun': { // TrackRunBox\n                    const trackRunBox = new AtomToken.TrackRunBox(payLoadLength);\n                    const trun = await this.tokenizer.readToken(trackRunBox);\n                    if (tfhd) {\n                        const track = this.tracks.get(tfhd.trackId);\n                        track?.fragments.push({ header: tfhd, trackRun: trun });\n                    }\n                    break;\n                }\n                default: {\n                    debug(`Unexpected box: ${child.header.name}`);\n                    await this.tokenizer.ignore(payLoadLength);\n                }\n            }\n        }, trafBox.getPayloadLength(0));\n    }\n    /**\n     * @param sampleDescription\n     * Ref: https://developer.apple.com/library/archive/documentation/QuickTime/QTFF/QTFFChap3/qtff3.html#//apple_ref/doc/uid/TP40000939-CH205-128916\n     */\n    parseSoundSampleDescription(sampleDescription) {\n        const ssd = {\n            dataFormat: sampleDescription.dataFormat,\n            dataReferenceIndex: sampleDescription.dataReferenceIndex\n        };\n        let offset = 0;\n        if (sampleDescription.description) {\n            const version = AtomToken.SoundSampleDescriptionVersion.get(sampleDescription.description, offset);\n            offset += AtomToken.SoundSampleDescriptionVersion.len;\n            if (version.version === 0 || version.version === 1) {\n                // Sound Sample Description (Version 0)\n                ssd.description = AtomToken.SoundSampleDescriptionV0.get(sampleDescription.description, offset);\n            }\n            else {\n                debug(`Warning: sound-sample-description ${version} not implemented`);\n            }\n        }\n        return ssd;\n    }\n    async parseChapterTrack(chapterTrack, track, len) {\n        if (!chapterTrack.sampleSize) {\n            if (chapterTrack.chunkOffsetTable.length !== chapterTrack.sampleSizeTable.length)\n                throw new Error('Expected equal chunk-offset-table & sample-size-table length.');\n        }\n        const chapters = [];\n        for (let i = 0; i < chapterTrack.chunkOffsetTable.length && len > 0; ++i) {\n            const start = chapterTrack.timeToSampleTable\n                .slice(0, i)\n                .reduce((acc, cur) => acc + cur.duration, 0);\n            const chunkOffset = chapterTrack.chunkOffsetTable[i];\n            const nextChunkLen = chunkOffset - this.tokenizer.position;\n            const sampleSize = chapterTrack.sampleSize > 0 ? chapterTrack.sampleSize : chapterTrack.sampleSizeTable[i];\n            len -= nextChunkLen + sampleSize;\n            if (len < 0)\n                throw new Mp4ContentError('Chapter chunk exceeding token length');\n            await this.tokenizer.ignore(nextChunkLen);\n            const title = await this.tokenizer.readToken(new AtomToken.ChapterText(sampleSize));\n            debug(`Chapter ${i + 1}: ${title}`);\n            const chapter = {\n                title,\n                timeScale: chapterTrack.media.header ? chapterTrack.media.header.timeScale : 0,\n                start,\n                sampleOffset: this.findSampleOffset(track, this.tokenizer.position)\n            };\n            debug(`Chapter title=${chapter.title}, offset=${chapter.sampleOffset}/${track.header.duration}`); // ToDo, use media duration if required!!!\n            chapters.push(chapter);\n        }\n        this.metadata.setFormat('chapters', chapters);\n        await this.tokenizer.ignore(len);\n    }\n    findSampleOffset(track, chapterOffset) {\n        let chunkIndex = 0;\n        while (chunkIndex < track.chunkOffsetTable.length && track.chunkOffsetTable[chunkIndex] < chapterOffset) {\n            ++chunkIndex;\n        }\n        return this.getChunkDuration(chunkIndex + 1, track);\n    }\n    getChunkDuration(chunkId, track) {\n        let ttsi = 0;\n        let ttsc = track.timeToSampleTable[ttsi].count;\n        let ttsd = track.timeToSampleTable[ttsi].duration;\n        let curChunkId = 1;\n        let samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n        let totalDuration = 0;\n        while (curChunkId < chunkId) {\n            const nrOfSamples = Math.min(ttsc, samplesPerChunk);\n            totalDuration += nrOfSamples * ttsd;\n            ttsc -= nrOfSamples;\n            samplesPerChunk -= nrOfSamples;\n            if (samplesPerChunk === 0) {\n                ++curChunkId;\n                samplesPerChunk = this.getSamplesPerChunk(curChunkId, track.sampleToChunkTable);\n            }\n            else {\n                ++ttsi;\n                ttsc = track.timeToSampleTable[ttsi].count;\n                ttsd = track.timeToSampleTable[ttsi].duration;\n            }\n        }\n        return totalDuration;\n    }\n    getSamplesPerChunk(chunkId, stcTable) {\n        for (let i = 0; i < stcTable.length - 1; ++i) {\n            if (chunkId >= stcTable[i].firstChunk && chunkId < stcTable[i + 1].firstChunk) {\n                return stcTable[i].samplesPerChunk;\n            }\n        }\n        return stcTable[stcTable.length - 1].samplesPerChunk;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}