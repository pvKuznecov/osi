{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport { defineAsyncComponent, markRaw } from 'vue';\n\n// Кэш загруженных компонентов\nconst componentCache = new Map();\n\n// Загрузчик компонентов с обработкой ошибок\nexport const loadComponent = async appName => {\n  const {\n    appConfig\n  } = await import('@/config/applications');\n  const app = appConfig.getAppByName(appName);\n  if (!app || !app.componentPath) {\n    console.error(`Приложение \"${appName}\" не найдено в конфигурации`);\n    return null;\n  }\n\n  // Проверяем кэш\n  if (componentCache.has(app.componentPath)) {\n    return componentCache.get(app.componentPath);\n  }\n  try {\n    // Создаем асинхронный компонент с обработчиками состояний\n    const asyncComponent = defineAsyncComponent({\n      loader: app.asyncImport,\n      loadingComponent: {\n        template: '<div class=\"app-loading\">Загрузка приложения...</div>'\n      },\n      errorComponent: {\n        template: '<div class=\"app-error\">Ошибка загрузки приложения</div>',\n        props: ['error']\n      },\n      delay: 200,\n      timeout: 10000\n    });\n\n    // Помечаем компонент как НЕ реактивный с помощью markRaw\n    const nonReactiveComponent = markRaw(asyncComponent);\n\n    // Кэшируем компонент\n    componentCache.set(app.componentPath, nonReactiveComponent);\n    return nonReactiveComponent;\n  } catch (error) {\n    console.error(`Ошибка загрузки компонента \"${app.componentPath}\":`, error);\n    return null;\n  }\n};\n\n// Предзагрузка приложений (опционально)\nexport const preloadApps = async (appNames = []) => {\n  const appsToLoad = appNames.length > 0 ? appNames : (await import('@/config/applications')).appConfig.getAllApps().map(app => app.name);\n  const promises = appsToLoad.map(appName => loadComponent(appName));\n  await Promise.allSettled(promises);\n};","map":{"version":3,"names":["defineAsyncComponent","markRaw","componentCache","Map","loadComponent","appName","appConfig","app","getAppByName","componentPath","console","error","has","get","asyncComponent","loader","asyncImport","loadingComponent","template","errorComponent","props","delay","timeout","nonReactiveComponent","set","preloadApps","appNames","appsToLoad","length","getAllApps","map","name","promises","Promise","allSettled"],"sources":["/home/kup/my_projects/vue/osi/src/utils/componentLoader.js"],"sourcesContent":["import { defineAsyncComponent, markRaw } from 'vue';\n\n// Кэш загруженных компонентов\nconst componentCache = new Map();\n\n// Загрузчик компонентов с обработкой ошибок\nexport const loadComponent = async (appName) => {\n  const { appConfig } = await import('@/config/applications');\n  const app = appConfig.getAppByName(appName);\n  \n  if (!app || !app.componentPath) {\n    console.error(`Приложение \"${appName}\" не найдено в конфигурации`);\n    return null;\n  }\n  \n  // Проверяем кэш\n  if (componentCache.has(app.componentPath)) {\n    return componentCache.get(app.componentPath);\n  }\n  \n  try {\n    // Создаем асинхронный компонент с обработчиками состояний\n    const asyncComponent = defineAsyncComponent({\n      loader: app.asyncImport,\n      loadingComponent: {\n        template: '<div class=\"app-loading\">Загрузка приложения...</div>'\n      },\n      errorComponent: {\n        template: '<div class=\"app-error\">Ошибка загрузки приложения</div>',\n        props: ['error']\n      },\n      delay: 200,\n      timeout: 10000\n    });\n    \n    // Помечаем компонент как НЕ реактивный с помощью markRaw\n    const nonReactiveComponent = markRaw(asyncComponent);\n    \n    // Кэшируем компонент\n    componentCache.set(app.componentPath, nonReactiveComponent);\n    \n    return nonReactiveComponent;\n  } catch (error) {\n    console.error(`Ошибка загрузки компонента \"${app.componentPath}\":`, error);\n    return null;\n  }\n};\n\n// Предзагрузка приложений (опционально)\nexport const preloadApps = async (appNames = []) => {\n  const appsToLoad = appNames.length > 0 \n    ? appNames \n    : (await import('@/config/applications')).appConfig.getAllApps().map(app => app.name);\n  \n  const promises = appsToLoad.map(appName => loadComponent(appName));\n  await Promise.allSettled(promises);\n};"],"mappings":";;AAAA,SAASA,oBAAoB,EAAEC,OAAO,QAAQ,KAAK;;AAEnD;AACA,MAAMC,cAAc,GAAG,IAAIC,GAAG,CAAC,CAAC;;AAEhC;AACA,OAAO,MAAMC,aAAa,GAAG,MAAOC,OAAO,IAAK;EAC9C,MAAM;IAAEC;EAAU,CAAC,GAAG,MAAM,MAAM,CAAC,uBAAuB,CAAC;EAC3D,MAAMC,GAAG,GAAGD,SAAS,CAACE,YAAY,CAACH,OAAO,CAAC;EAE3C,IAAI,CAACE,GAAG,IAAI,CAACA,GAAG,CAACE,aAAa,EAAE;IAC9BC,OAAO,CAACC,KAAK,CAAC,eAAeN,OAAO,6BAA6B,CAAC;IAClE,OAAO,IAAI;EACb;;EAEA;EACA,IAAIH,cAAc,CAACU,GAAG,CAACL,GAAG,CAACE,aAAa,CAAC,EAAE;IACzC,OAAOP,cAAc,CAACW,GAAG,CAACN,GAAG,CAACE,aAAa,CAAC;EAC9C;EAEA,IAAI;IACF;IACA,MAAMK,cAAc,GAAGd,oBAAoB,CAAC;MAC1Ce,MAAM,EAAER,GAAG,CAACS,WAAW;MACvBC,gBAAgB,EAAE;QAChBC,QAAQ,EAAE;MACZ,CAAC;MACDC,cAAc,EAAE;QACdD,QAAQ,EAAE,yDAAyD;QACnEE,KAAK,EAAE,CAAC,OAAO;MACjB,CAAC;MACDC,KAAK,EAAE,GAAG;MACVC,OAAO,EAAE;IACX,CAAC,CAAC;;IAEF;IACA,MAAMC,oBAAoB,GAAGtB,OAAO,CAACa,cAAc,CAAC;;IAEpD;IACAZ,cAAc,CAACsB,GAAG,CAACjB,GAAG,CAACE,aAAa,EAAEc,oBAAoB,CAAC;IAE3D,OAAOA,oBAAoB;EAC7B,CAAC,CAAC,OAAOZ,KAAK,EAAE;IACdD,OAAO,CAACC,KAAK,CAAC,+BAA+BJ,GAAG,CAACE,aAAa,IAAI,EAAEE,KAAK,CAAC;IAC1E,OAAO,IAAI;EACb;AACF,CAAC;;AAED;AACA,OAAO,MAAMc,WAAW,GAAG,MAAAA,CAAOC,QAAQ,GAAG,EAAE,KAAK;EAClD,MAAMC,UAAU,GAAGD,QAAQ,CAACE,MAAM,GAAG,CAAC,GAClCF,QAAQ,GACR,CAAC,MAAM,MAAM,CAAC,uBAAuB,CAAC,EAAEpB,SAAS,CAACuB,UAAU,CAAC,CAAC,CAACC,GAAG,CAACvB,GAAG,IAAIA,GAAG,CAACwB,IAAI,CAAC;EAEvF,MAAMC,QAAQ,GAAGL,UAAU,CAACG,GAAG,CAACzB,OAAO,IAAID,aAAa,CAACC,OAAO,CAAC,CAAC;EAClE,MAAM4B,OAAO,CAACC,UAAU,CAACF,QAAQ,CAAC;AACpC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}