{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.filter.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport * as Token from 'token-types';\nimport initDebug from 'debug';\nimport * as strtok3 from 'strtok3';\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport * as AiffToken from './AiffToken.js';\nimport { AiffContentError, compressionTypes } from './AiffToken.js';\nimport * as iff from '../iff/index.js';\nconst debug = initDebug('music-metadata:parser:aiff');\n/**\r\n * AIFF - Audio Interchange File Format\r\n *\r\n * Ref:\r\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\r\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\r\n */\nexport class AIFFParser extends BasicParser {\n  constructor() {\n    super(...arguments);\n    this.isCompressed = null;\n  }\n  async parse() {\n    const header = await this.tokenizer.readToken(iff.Header);\n    if (header.chunkID !== 'FORM') throw new AiffContentError('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\n    const type = await this.tokenizer.readToken(FourCcToken);\n    switch (type) {\n      case 'AIFF':\n        this.metadata.setFormat('container', type);\n        this.isCompressed = false;\n        break;\n      case 'AIFC':\n        this.metadata.setFormat('container', 'AIFF-C');\n        this.isCompressed = true;\n        break;\n      default:\n        throw new AiffContentError(`Unsupported AIFF type: ${type}`);\n    }\n    this.metadata.setFormat('lossless', !this.isCompressed);\n    this.metadata.setAudioOnly();\n    try {\n      while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\n        debug(`Reading AIFF chunk at offset=${this.tokenizer.position}`);\n        const chunkHeader = await this.tokenizer.readToken(iff.Header);\n        const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\n        const bytesRead = await this.readData(chunkHeader);\n        await this.tokenizer.ignore(nextChunk - bytesRead);\n      }\n    } catch (err) {\n      if (err instanceof strtok3.EndOfStreamError) {\n        debug(\"End-of-stream\");\n      } else {\n        throw err;\n      }\n    }\n  }\n  async readData(header) {\n    switch (header.chunkID) {\n      case 'COMM':\n        {\n          // The Common Chunk\n          if (this.isCompressed === null) {\n            throw new AiffContentError('Failed to parse AIFF.COMM chunk when compression type is unknown');\n          }\n          const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\n          this.metadata.setFormat('bitsPerSample', common.sampleSize);\n          this.metadata.setFormat('sampleRate', common.sampleRate);\n          this.metadata.setFormat('numberOfChannels', common.numChannels);\n          this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\n          this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\n          if (common.compressionName || common.compressionType) {\n            this.metadata.setFormat('codec', common.compressionName ?? compressionTypes[common.compressionType]);\n          }\n          return header.chunkSize;\n        }\n      case 'ID3 ':\n        {\n          // ID3-meta-data\n          const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n          const rst = strtok3.fromBuffer(id3_data);\n          await new ID3v2Parser().parse(this.metadata, rst, this.options);\n          return header.chunkSize;\n        }\n      case 'SSND':\n        // Sound Data Chunk\n        if (this.metadata.format.duration) {\n          this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\n        }\n        return 0;\n      case 'NAME': // Sample name chunk\n      case 'AUTH': // Author chunk\n      case '(c) ': // Copyright chunk\n      case 'ANNO':\n        // Annotation chunk\n        return this.readTextChunk(header);\n      default:\n        debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);\n        return 0;\n    }\n  }\n  async readTextChunk(header) {\n    const value = await this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));\n    const values = value.split('\\0').map(v => v.trim()).filter(v => v?.length);\n    await Promise.all(values.map(v => this.metadata.addTag('AIFF', header.chunkID, v)));\n    return header.chunkSize;\n  }\n}","map":{"version":3,"names":["Token","initDebug","strtok3","ID3v2Parser","FourCcToken","BasicParser","AiffToken","AiffContentError","compressionTypes","iff","debug","AIFFParser","constructor","arguments","isCompressed","parse","header","tokenizer","readToken","Header","chunkID","type","metadata","setFormat","setAudioOnly","fileInfo","size","position","len","chunkHeader","nextChunk","Math","round","chunkSize","bytesRead","readData","ignore","err","EndOfStreamError","common","Common","sampleSize","sampleRate","numChannels","numSampleFrames","compressionName","compressionType","id3_data","Uint8ArrayType","rst","fromBuffer","options","format","duration","readTextChunk","value","StringType","values","split","map","v","trim","filter","length","Promise","all","addTag"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/aiff/AiffParser.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport initDebug from 'debug';\r\nimport * as strtok3 from 'strtok3';\r\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport * as AiffToken from './AiffToken.js';\r\nimport { AiffContentError, compressionTypes } from './AiffToken.js';\r\nimport * as iff from '../iff/index.js';\r\nconst debug = initDebug('music-metadata:parser:aiff');\r\n/**\r\n * AIFF - Audio Interchange File Format\r\n *\r\n * Ref:\r\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/AIFF.html\r\n * - http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/AIFF/Docs/AIFF-1.3.pdf\r\n */\r\nexport class AIFFParser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.isCompressed = null;\r\n    }\r\n    async parse() {\r\n        const header = await this.tokenizer.readToken(iff.Header);\r\n        if (header.chunkID !== 'FORM')\r\n            throw new AiffContentError('Invalid Chunk-ID, expected \\'FORM\\''); // Not AIFF format\r\n        const type = await this.tokenizer.readToken(FourCcToken);\r\n        switch (type) {\r\n            case 'AIFF':\r\n                this.metadata.setFormat('container', type);\r\n                this.isCompressed = false;\r\n                break;\r\n            case 'AIFC':\r\n                this.metadata.setFormat('container', 'AIFF-C');\r\n                this.isCompressed = true;\r\n                break;\r\n            default:\r\n                throw new AiffContentError(`Unsupported AIFF type: ${type}`);\r\n        }\r\n        this.metadata.setFormat('lossless', !this.isCompressed);\r\n        this.metadata.setAudioOnly();\r\n        try {\r\n            while (!this.tokenizer.fileInfo.size || this.tokenizer.fileInfo.size - this.tokenizer.position >= iff.Header.len) {\r\n                debug(`Reading AIFF chunk at offset=${this.tokenizer.position}`);\r\n                const chunkHeader = await this.tokenizer.readToken(iff.Header);\r\n                const nextChunk = 2 * Math.round(chunkHeader.chunkSize / 2);\r\n                const bytesRead = await this.readData(chunkHeader);\r\n                await this.tokenizer.ignore(nextChunk - bytesRead);\r\n            }\r\n        }\r\n        catch (err) {\r\n            if (err instanceof strtok3.EndOfStreamError) {\r\n                debug(\"End-of-stream\");\r\n            }\r\n            else {\r\n                throw err;\r\n            }\r\n        }\r\n    }\r\n    async readData(header) {\r\n        switch (header.chunkID) {\r\n            case 'COMM': { // The Common Chunk\r\n                if (this.isCompressed === null) {\r\n                    throw new AiffContentError('Failed to parse AIFF.COMM chunk when compression type is unknown');\r\n                }\r\n                const common = await this.tokenizer.readToken(new AiffToken.Common(header, this.isCompressed));\r\n                this.metadata.setFormat('bitsPerSample', common.sampleSize);\r\n                this.metadata.setFormat('sampleRate', common.sampleRate);\r\n                this.metadata.setFormat('numberOfChannels', common.numChannels);\r\n                this.metadata.setFormat('numberOfSamples', common.numSampleFrames);\r\n                this.metadata.setFormat('duration', common.numSampleFrames / common.sampleRate);\r\n                if (common.compressionName || common.compressionType) {\r\n                    this.metadata.setFormat('codec', common.compressionName ?? compressionTypes[common.compressionType]);\r\n                }\r\n                return header.chunkSize;\r\n            }\r\n            case 'ID3 ': { // ID3-meta-data\r\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\r\n                const rst = strtok3.fromBuffer(id3_data);\r\n                await new ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                return header.chunkSize;\r\n            }\r\n            case 'SSND': // Sound Data Chunk\r\n                if (this.metadata.format.duration) {\r\n                    this.metadata.setFormat('bitrate', 8 * header.chunkSize / this.metadata.format.duration);\r\n                }\r\n                return 0;\r\n            case 'NAME': // Sample name chunk\r\n            case 'AUTH': // Author chunk\r\n            case '(c) ': // Copyright chunk\r\n            case 'ANNO': // Annotation chunk\r\n                return this.readTextChunk(header);\r\n            default:\r\n                debug(`Ignore chunk id=${header.chunkID}, size=${header.chunkSize}`);\r\n                return 0;\r\n        }\r\n    }\r\n    async readTextChunk(header) {\r\n        const value = await this.tokenizer.readToken(new Token.StringType(header.chunkSize, 'ascii'));\r\n        const values = value.split('\\0').map(v => v.trim()).filter(v => v?.length);\r\n        await Promise.all(values.map(v => this.metadata.addTag('AIFF', header.chunkID, v)));\r\n        return header.chunkSize;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}