{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { EndOfStreamError, AbortError } from \"./Errors.js\";\nexport class AbstractStreamReader {\n  constructor() {\n    this.endOfStream = false;\n    this.interrupted = false;\n    /**\n     * Store peeked data\n     * @type {Array}\n     */\n    this.peekQueue = [];\n  }\n  async peek(uint8Array, mayBeLess = false) {\n    const bytesRead = await this.read(uint8Array, mayBeLess);\n    this.peekQueue.push(uint8Array.subarray(0, bytesRead)); // Put read data back to peek buffer\n    return bytesRead;\n  }\n  async read(buffer, mayBeLess = false) {\n    if (buffer.length === 0) {\n      return 0;\n    }\n    let bytesRead = this.readFromPeekBuffer(buffer);\n    if (!this.endOfStream) {\n      bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);\n    }\n    if (bytesRead === 0 && !mayBeLess) {\n      throw new EndOfStreamError();\n    }\n    return bytesRead;\n  }\n  /**\n   * Read chunk from stream\n   * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\n   * @returns Number of bytes read\n   */\n  readFromPeekBuffer(buffer) {\n    let remaining = buffer.length;\n    let bytesRead = 0;\n    // consume peeked data first\n    while (this.peekQueue.length > 0 && remaining > 0) {\n      const peekData = this.peekQueue.pop(); // Front of queue\n      if (!peekData) throw new Error('peekData should be defined');\n      const lenCopy = Math.min(peekData.length, remaining);\n      buffer.set(peekData.subarray(0, lenCopy), bytesRead);\n      bytesRead += lenCopy;\n      remaining -= lenCopy;\n      if (lenCopy < peekData.length) {\n        // remainder back to queue\n        this.peekQueue.push(peekData.subarray(lenCopy));\n      }\n    }\n    return bytesRead;\n  }\n  async readRemainderFromStream(buffer, mayBeLess) {\n    let bytesRead = 0;\n    // Continue reading from stream if required\n    while (bytesRead < buffer.length && !this.endOfStream) {\n      if (this.interrupted) {\n        throw new AbortError();\n      }\n      const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);\n      if (chunkLen === 0) break;\n      bytesRead += chunkLen;\n    }\n    if (!mayBeLess && bytesRead < buffer.length) {\n      throw new EndOfStreamError();\n    }\n    return bytesRead;\n  }\n}","map":{"version":3,"names":["EndOfStreamError","AbortError","AbstractStreamReader","constructor","endOfStream","interrupted","peekQueue","peek","uint8Array","mayBeLess","bytesRead","read","push","subarray","buffer","length","readFromPeekBuffer","readRemainderFromStream","remaining","peekData","pop","Error","lenCopy","Math","min","set","chunkLen","readFromStream"],"sources":["/home/kup/my_projects/vue/osi/node_modules/strtok3/lib/stream/AbstractStreamReader.js"],"sourcesContent":["import { EndOfStreamError, AbortError } from \"./Errors.js\";\nexport class AbstractStreamReader {\n    constructor() {\n        this.endOfStream = false;\n        this.interrupted = false;\n        /**\n         * Store peeked data\n         * @type {Array}\n         */\n        this.peekQueue = [];\n    }\n    async peek(uint8Array, mayBeLess = false) {\n        const bytesRead = await this.read(uint8Array, mayBeLess);\n        this.peekQueue.push(uint8Array.subarray(0, bytesRead)); // Put read data back to peek buffer\n        return bytesRead;\n    }\n    async read(buffer, mayBeLess = false) {\n        if (buffer.length === 0) {\n            return 0;\n        }\n        let bytesRead = this.readFromPeekBuffer(buffer);\n        if (!this.endOfStream) {\n            bytesRead += await this.readRemainderFromStream(buffer.subarray(bytesRead), mayBeLess);\n        }\n        if (bytesRead === 0 && !mayBeLess) {\n            throw new EndOfStreamError();\n        }\n        return bytesRead;\n    }\n    /**\n     * Read chunk from stream\n     * @param buffer - Target Uint8Array (or Buffer) to store data read from stream in\n     * @returns Number of bytes read\n     */\n    readFromPeekBuffer(buffer) {\n        let remaining = buffer.length;\n        let bytesRead = 0;\n        // consume peeked data first\n        while (this.peekQueue.length > 0 && remaining > 0) {\n            const peekData = this.peekQueue.pop(); // Front of queue\n            if (!peekData)\n                throw new Error('peekData should be defined');\n            const lenCopy = Math.min(peekData.length, remaining);\n            buffer.set(peekData.subarray(0, lenCopy), bytesRead);\n            bytesRead += lenCopy;\n            remaining -= lenCopy;\n            if (lenCopy < peekData.length) {\n                // remainder back to queue\n                this.peekQueue.push(peekData.subarray(lenCopy));\n            }\n        }\n        return bytesRead;\n    }\n    async readRemainderFromStream(buffer, mayBeLess) {\n        let bytesRead = 0;\n        // Continue reading from stream if required\n        while (bytesRead < buffer.length && !this.endOfStream) {\n            if (this.interrupted) {\n                throw new AbortError();\n            }\n            const chunkLen = await this.readFromStream(buffer.subarray(bytesRead), mayBeLess);\n            if (chunkLen === 0)\n                break;\n            bytesRead += chunkLen;\n        }\n        if (!mayBeLess && bytesRead < buffer.length) {\n            throw new EndOfStreamError();\n        }\n        return bytesRead;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}