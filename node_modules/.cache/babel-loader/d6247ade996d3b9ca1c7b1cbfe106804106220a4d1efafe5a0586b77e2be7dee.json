{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport \"core-js/modules/es.set.difference.v2.js\";\nimport \"core-js/modules/es.set.intersection.v2.js\";\nimport \"core-js/modules/es.set.is-disjoint-from.v2.js\";\nimport \"core-js/modules/es.set.is-subset-of.v2.js\";\nimport \"core-js/modules/es.set.is-superset-of.v2.js\";\nimport \"core-js/modules/es.set.symmetric-difference.v2.js\";\nimport \"core-js/modules/es.set.union.v2.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport { fileTypeFromBuffer } from 'file-type';\nimport ContentType from 'content-type';\nimport { parse as mimeTypeParse } from 'media-typer';\nimport initDebug from 'debug';\nimport { MetadataCollector } from './common/MetadataCollector.js';\nimport { TrackType } from './type.js';\nimport { mpegParserLoader } from './mpeg/MpegLoader.js';\nimport { CouldNotDetermineFileTypeError, UnsupportedFileTypeError } from './ParseError.js';\nimport { apeParserLoader } from './apev2/Apev2Loader.js';\nimport { asfParserLoader } from './asf/AsfLoader.js';\nimport { dsdiffParserLoader } from './dsdiff/DsdiffLoader.js';\nimport { aiffParserLoader } from './aiff/AiffLoader.js';\nimport { dsfParserLoader } from './dsf/DsfLoader.js';\nimport { flacParserLoader } from './flac/FlacLoader.js';\nimport { matroskaParserLoader } from './matroska/MatroskaLoader.js';\nimport { mp4ParserLoader } from './mp4/Mp4Loader.js';\nimport { musepackParserLoader } from './musepack/MusepackLoader.js';\nimport { oggParserLoader } from './ogg/OggLoader.js';\nimport { wavpackParserLoader } from './wavpack/WavPackLoader.js';\nimport { riffParserLoader } from './wav/WaveLoader.js';\nimport { scanAppendingHeaders } from './core.js';\nconst debug = initDebug('music-metadata:parser:factory');\nexport function parseHttpContentType(contentType) {\n  const type = ContentType.parse(contentType);\n  const mime = mimeTypeParse(type.type);\n  return {\n    type: mime.type,\n    subtype: mime.subtype,\n    suffix: mime.suffix,\n    parameters: type.parameters\n  };\n}\nexport class ParserFactory {\n  constructor() {\n    this.parsers = [];\n    [flacParserLoader, mpegParserLoader, apeParserLoader, mp4ParserLoader, matroskaParserLoader, riffParserLoader, oggParserLoader, asfParserLoader, aiffParserLoader, wavpackParserLoader, musepackParserLoader, dsfParserLoader, dsdiffParserLoader].forEach(parser => {\n      this.registerParser(parser);\n    });\n  }\n  registerParser(parser) {\n    this.parsers.push(parser);\n  }\n  async parse(tokenizer, parserLoader, opts) {\n    if (tokenizer.supportsRandomAccess()) {\n      debug('tokenizer supports random-access, scanning for appending headers');\n      await scanAppendingHeaders(tokenizer, opts);\n    } else {\n      debug('tokenizer does not support random-access, cannot scan for appending headers');\n    }\n    if (!parserLoader) {\n      const buf = new Uint8Array(4100);\n      if (tokenizer.fileInfo.mimeType) {\n        parserLoader = this.findLoaderForContentType(tokenizer.fileInfo.mimeType);\n      }\n      if (!parserLoader && tokenizer.fileInfo.path) {\n        parserLoader = this.findLoaderForExtension(tokenizer.fileInfo.path);\n      }\n      if (!parserLoader) {\n        // Parser could not be determined on MIME-type or extension\n        debug('Guess parser on content...');\n        await tokenizer.peekBuffer(buf, {\n          mayBeLess: true\n        });\n        const guessedType = await fileTypeFromBuffer(buf, {\n          mpegOffsetTolerance: 10\n        });\n        if (!guessedType || !guessedType.mime) {\n          throw new CouldNotDetermineFileTypeError('Failed to determine audio format');\n        }\n        debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);\n        parserLoader = this.findLoaderForContentType(guessedType.mime);\n        if (!parserLoader) {\n          throw new UnsupportedFileTypeError(`Guessed MIME-type not supported: ${guessedType.mime}`);\n        }\n      }\n    }\n    // Parser found, execute parser\n    debug(`Loading ${parserLoader.parserType} parser...`);\n    const metadata = new MetadataCollector(opts);\n    const ParserImpl = await parserLoader.load();\n    const parser = new ParserImpl(metadata, tokenizer, opts ?? {});\n    debug(`Parser ${parserLoader.parserType} loaded`);\n    await parser.parse();\n    if (metadata.format.trackInfo) {\n      if (metadata.format.hasAudio === undefined) {\n        metadata.setFormat('hasAudio', !!metadata.format.trackInfo.find(track => track.type === TrackType.audio));\n      }\n      if (metadata.format.hasVideo === undefined) {\n        metadata.setFormat('hasVideo', !!metadata.format.trackInfo.find(track => track.type === TrackType.video));\n      }\n    }\n    return metadata.toCommonMetadata();\n  }\n  /**\r\n   * @param filePath - Path, filename or extension to audio file\r\n   * @return Parser submodule name\r\n   */\n  findLoaderForExtension(filePath) {\n    if (!filePath) return;\n    const extension = getExtension(filePath).toLocaleLowerCase() || filePath;\n    return this.parsers.find(parser => parser.extensions.indexOf(extension) !== -1);\n  }\n  findLoaderForContentType(httpContentType) {\n    let mime;\n    if (!httpContentType) return;\n    try {\n      mime = parseHttpContentType(httpContentType);\n    } catch (_err) {\n      debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);\n      return;\n    }\n    const subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;\n    return this.parsers.find(parser => parser.mimeTypes.find(loader => loader.indexOf(`${mime.type}/${subType}`) !== -1));\n  }\n  getSupportedMimeTypes() {\n    const mimeTypeSet = new Set();\n    this.parsers.forEach(loader => {\n      loader.mimeTypes.forEach(mimeType => {\n        mimeTypeSet.add(mimeType);\n        mimeTypeSet.add(mimeType.replace('/', '/x-'));\n      });\n    });\n    return Array.from(mimeTypeSet);\n  }\n}\nfunction getExtension(fname) {\n  const i = fname.lastIndexOf('.');\n  return i === -1 ? '' : fname.substring(i);\n}","map":{"version":3,"names":["fileTypeFromBuffer","ContentType","parse","mimeTypeParse","initDebug","MetadataCollector","TrackType","mpegParserLoader","CouldNotDetermineFileTypeError","UnsupportedFileTypeError","apeParserLoader","asfParserLoader","dsdiffParserLoader","aiffParserLoader","dsfParserLoader","flacParserLoader","matroskaParserLoader","mp4ParserLoader","musepackParserLoader","oggParserLoader","wavpackParserLoader","riffParserLoader","scanAppendingHeaders","debug","parseHttpContentType","contentType","type","mime","subtype","suffix","parameters","ParserFactory","constructor","parsers","forEach","parser","registerParser","push","tokenizer","parserLoader","opts","supportsRandomAccess","buf","Uint8Array","fileInfo","mimeType","findLoaderForContentType","path","findLoaderForExtension","peekBuffer","mayBeLess","guessedType","mpegOffsetTolerance","ext","parserType","metadata","ParserImpl","load","format","trackInfo","hasAudio","undefined","setFormat","find","track","audio","hasVideo","video","toCommonMetadata","filePath","extension","getExtension","toLocaleLowerCase","extensions","indexOf","httpContentType","_err","subType","substring","mimeTypes","loader","getSupportedMimeTypes","mimeTypeSet","Set","add","replace","Array","from","fname","i","lastIndexOf"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/ParserFactory.js"],"sourcesContent":["import { fileTypeFromBuffer } from 'file-type';\r\nimport ContentType from 'content-type';\r\nimport { parse as mimeTypeParse } from 'media-typer';\r\nimport initDebug from 'debug';\r\nimport { MetadataCollector } from './common/MetadataCollector.js';\r\nimport { TrackType } from './type.js';\r\nimport { mpegParserLoader } from './mpeg/MpegLoader.js';\r\nimport { CouldNotDetermineFileTypeError, UnsupportedFileTypeError } from './ParseError.js';\r\nimport { apeParserLoader } from './apev2/Apev2Loader.js';\r\nimport { asfParserLoader } from './asf/AsfLoader.js';\r\nimport { dsdiffParserLoader } from './dsdiff/DsdiffLoader.js';\r\nimport { aiffParserLoader } from './aiff/AiffLoader.js';\r\nimport { dsfParserLoader } from './dsf/DsfLoader.js';\r\nimport { flacParserLoader } from './flac/FlacLoader.js';\r\nimport { matroskaParserLoader } from './matroska/MatroskaLoader.js';\r\nimport { mp4ParserLoader } from './mp4/Mp4Loader.js';\r\nimport { musepackParserLoader } from './musepack/MusepackLoader.js';\r\nimport { oggParserLoader } from './ogg/OggLoader.js';\r\nimport { wavpackParserLoader } from './wavpack/WavPackLoader.js';\r\nimport { riffParserLoader } from './wav/WaveLoader.js';\r\nimport { scanAppendingHeaders } from './core.js';\r\nconst debug = initDebug('music-metadata:parser:factory');\r\nexport function parseHttpContentType(contentType) {\r\n    const type = ContentType.parse(contentType);\r\n    const mime = mimeTypeParse(type.type);\r\n    return {\r\n        type: mime.type,\r\n        subtype: mime.subtype,\r\n        suffix: mime.suffix,\r\n        parameters: type.parameters\r\n    };\r\n}\r\nexport class ParserFactory {\r\n    constructor() {\r\n        this.parsers = [];\r\n        [\r\n            flacParserLoader,\r\n            mpegParserLoader,\r\n            apeParserLoader,\r\n            mp4ParserLoader,\r\n            matroskaParserLoader,\r\n            riffParserLoader,\r\n            oggParserLoader,\r\n            asfParserLoader,\r\n            aiffParserLoader,\r\n            wavpackParserLoader,\r\n            musepackParserLoader,\r\n            dsfParserLoader,\r\n            dsdiffParserLoader\r\n        ].forEach(parser => { this.registerParser(parser); });\r\n    }\r\n    registerParser(parser) {\r\n        this.parsers.push(parser);\r\n    }\r\n    async parse(tokenizer, parserLoader, opts) {\r\n        if (tokenizer.supportsRandomAccess()) {\r\n            debug('tokenizer supports random-access, scanning for appending headers');\r\n            await scanAppendingHeaders(tokenizer, opts);\r\n        }\r\n        else {\r\n            debug('tokenizer does not support random-access, cannot scan for appending headers');\r\n        }\r\n        if (!parserLoader) {\r\n            const buf = new Uint8Array(4100);\r\n            if (tokenizer.fileInfo.mimeType) {\r\n                parserLoader = this.findLoaderForContentType(tokenizer.fileInfo.mimeType);\r\n            }\r\n            if (!parserLoader && tokenizer.fileInfo.path) {\r\n                parserLoader = this.findLoaderForExtension(tokenizer.fileInfo.path);\r\n            }\r\n            if (!parserLoader) {\r\n                // Parser could not be determined on MIME-type or extension\r\n                debug('Guess parser on content...');\r\n                await tokenizer.peekBuffer(buf, { mayBeLess: true });\r\n                const guessedType = await fileTypeFromBuffer(buf, { mpegOffsetTolerance: 10 });\r\n                if (!guessedType || !guessedType.mime) {\r\n                    throw new CouldNotDetermineFileTypeError('Failed to determine audio format');\r\n                }\r\n                debug(`Guessed file type is mime=${guessedType.mime}, extension=${guessedType.ext}`);\r\n                parserLoader = this.findLoaderForContentType(guessedType.mime);\r\n                if (!parserLoader) {\r\n                    throw new UnsupportedFileTypeError(`Guessed MIME-type not supported: ${guessedType.mime}`);\r\n                }\r\n            }\r\n        }\r\n        // Parser found, execute parser\r\n        debug(`Loading ${parserLoader.parserType} parser...`);\r\n        const metadata = new MetadataCollector(opts);\r\n        const ParserImpl = await parserLoader.load();\r\n        const parser = new ParserImpl(metadata, tokenizer, opts ?? {});\r\n        debug(`Parser ${parserLoader.parserType} loaded`);\r\n        await parser.parse();\r\n        if (metadata.format.trackInfo) {\r\n            if (metadata.format.hasAudio === undefined) {\r\n                metadata.setFormat('hasAudio', !!metadata.format.trackInfo.find(track => track.type === TrackType.audio));\r\n            }\r\n            if (metadata.format.hasVideo === undefined) {\r\n                metadata.setFormat('hasVideo', !!metadata.format.trackInfo.find(track => track.type === TrackType.video));\r\n            }\r\n        }\r\n        return metadata.toCommonMetadata();\r\n    }\r\n    /**\r\n     * @param filePath - Path, filename or extension to audio file\r\n     * @return Parser submodule name\r\n     */\r\n    findLoaderForExtension(filePath) {\r\n        if (!filePath)\r\n            return;\r\n        const extension = getExtension(filePath).toLocaleLowerCase() || filePath;\r\n        return this.parsers.find(parser => parser.extensions.indexOf(extension) !== -1);\r\n    }\r\n    findLoaderForContentType(httpContentType) {\r\n        let mime;\r\n        if (!httpContentType)\r\n            return;\r\n        try {\r\n            mime = parseHttpContentType(httpContentType);\r\n        }\r\n        catch (_err) {\r\n            debug(`Invalid HTTP Content-Type header value: ${httpContentType}`);\r\n            return;\r\n        }\r\n        const subType = mime.subtype.indexOf('x-') === 0 ? mime.subtype.substring(2) : mime.subtype;\r\n        return this.parsers.find(parser => parser.mimeTypes.find(loader => loader.indexOf(`${mime.type}/${subType}`) !== -1));\r\n    }\r\n    getSupportedMimeTypes() {\r\n        const mimeTypeSet = new Set();\r\n        this.parsers.forEach(loader => {\r\n            loader.mimeTypes.forEach(mimeType => {\r\n                mimeTypeSet.add(mimeType);\r\n                mimeTypeSet.add(mimeType.replace('/', '/x-'));\r\n            });\r\n        });\r\n        return Array.from(mimeTypeSet);\r\n    }\r\n}\r\nfunction getExtension(fname) {\r\n    const i = fname.lastIndexOf('.');\r\n    return i === -1 ? '' : fname.substring(i);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}