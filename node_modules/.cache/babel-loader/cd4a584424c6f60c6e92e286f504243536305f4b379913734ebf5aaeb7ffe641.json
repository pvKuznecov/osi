{"ast":null,"code":"import * as Token from 'token-types';\nimport { FourCcToken } from '../common/FourCC.js';\nexport const DataType = {\n  text_utf8: 0,\n  binary: 1,\n  external_info: 2,\n  reserved: 3\n};\n/**\r\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\r\n */\nexport const DescriptorParser = {\n  len: 52,\n  get: (buf, off) => {\n    return {\n      // should equal 'MAC '\n      ID: FourCcToken.get(buf, off),\n      // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\n      version: Token.UINT32_LE.get(buf, off + 4) / 1000,\n      // the number of descriptor bytes (allows later expansion of this header)\n      descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\n      // the number of header APE_HEADER bytes\n      headerBytes: Token.UINT32_LE.get(buf, off + 12),\n      // the number of header APE_HEADER bytes\n      seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\n      // the number of header data bytes (from original file)\n      headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\n      // the number of bytes of APE frame data\n      apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\n      // the high order number of APE frame data bytes\n      apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\n      // the terminating data of the file (not including tag data)\n      terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\n      // the MD5 hash of the file (see notes for usage... it's a little tricky)\n      fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)\n    };\n  }\n};\n/**\r\n * APE_HEADER: describes all of the necessary information about the APE file\r\n */\nexport const Header = {\n  len: 24,\n  get: (buf, off) => {\n    return {\n      // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\n      compressionLevel: Token.UINT16_LE.get(buf, off),\n      // any format flags (for future use)\n      formatFlags: Token.UINT16_LE.get(buf, off + 2),\n      // the number of audio blocks in one frame\n      blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\n      // the number of audio blocks in the final frame\n      finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\n      // the total number of frames\n      totalFrames: Token.UINT32_LE.get(buf, off + 12),\n      // the bits per sample (typically 16)\n      bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\n      // the number of channels (1 or 2)\n      channel: Token.UINT16_LE.get(buf, off + 18),\n      // the sample rate (typically 44100)\n      sampleRate: Token.UINT32_LE.get(buf, off + 20)\n    };\n  }\n};\n/**\r\n * APE Tag Header/Footer Version 2.0\r\n * TAG: describes all the properties of the file [optional]\r\n */\nexport const TagFooter = {\n  len: 32,\n  get: (buf, off) => {\n    return {\n      // should equal 'APETAGEX'\n      ID: new Token.StringType(8, 'ascii').get(buf, off),\n      // equals CURRENT_APE_TAG_VERSION\n      version: Token.UINT32_LE.get(buf, off + 8),\n      // the complete size of the tag, including this footer (excludes header)\n      size: Token.UINT32_LE.get(buf, off + 12),\n      // the number of fields in the tag\n      fields: Token.UINT32_LE.get(buf, off + 16),\n      // reserved for later use (must be zero),\n      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\n    };\n  }\n};\n/**\r\n * APE Tag v2.0 Item Header\r\n */\nexport const TagItemHeader = {\n  len: 8,\n  get: (buf, off) => {\n    return {\n      // Length of assigned value in bytes\n      size: Token.UINT32_LE.get(buf, off),\n      // reserved for later use (must be zero),\n      flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\n    };\n  }\n};\nexport function parseTagFlags(flags) {\n  return {\n    containsHeader: isBitSet(flags, 31),\n    containsFooter: isBitSet(flags, 30),\n    isHeader: isBitSet(flags, 29),\n    readOnly: isBitSet(flags, 0),\n    dataType: (flags & 6) >> 1\n  };\n}\n/**\r\n * @param num {number}\r\n * @param bit 0 is least significant bit (LSB)\r\n * @return {boolean} true if bit is 1; otherwise false\r\n */\nexport function isBitSet(num, bit) {\n  return (num & 1 << bit) !== 0;\n}","map":{"version":3,"names":["Token","FourCcToken","DataType","text_utf8","binary","external_info","reserved","DescriptorParser","len","get","buf","off","ID","version","UINT32_LE","descriptorBytes","headerBytes","seekTableBytes","headerDataBytes","apeFrameDataBytes","apeFrameDataBytesHigh","terminatingDataBytes","fileMD5","Uint8ArrayType","Header","compressionLevel","UINT16_LE","formatFlags","blocksPerFrame","finalFrameBlocks","totalFrames","bitsPerSample","channel","sampleRate","TagFooter","StringType","size","fields","flags","parseTagFlags","TagItemHeader","containsHeader","isBitSet","containsFooter","isHeader","readOnly","dataType","num","bit"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/apev2/APEv2Token.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nexport const DataType = {\r\n    text_utf8: 0,\r\n    binary: 1,\r\n    external_info: 2,\r\n    reserved: 3\r\n};\r\n/**\r\n * APE_DESCRIPTOR: defines the sizes (and offsets) of all the pieces, as well as the MD5 checksum\r\n */\r\nexport const DescriptorParser = {\r\n    len: 52,\r\n    get: (buf, off) => {\r\n        return {\r\n            // should equal 'MAC '\r\n            ID: FourCcToken.get(buf, off),\r\n            // versionIndex number * 1000 (3.81 = 3810) (remember that 4-byte alignment causes this to take 4-bytes)\r\n            version: Token.UINT32_LE.get(buf, off + 4) / 1000,\r\n            // the number of descriptor bytes (allows later expansion of this header)\r\n            descriptorBytes: Token.UINT32_LE.get(buf, off + 8),\r\n            // the number of header APE_HEADER bytes\r\n            headerBytes: Token.UINT32_LE.get(buf, off + 12),\r\n            // the number of header APE_HEADER bytes\r\n            seekTableBytes: Token.UINT32_LE.get(buf, off + 16),\r\n            // the number of header data bytes (from original file)\r\n            headerDataBytes: Token.UINT32_LE.get(buf, off + 20),\r\n            // the number of bytes of APE frame data\r\n            apeFrameDataBytes: Token.UINT32_LE.get(buf, off + 24),\r\n            // the high order number of APE frame data bytes\r\n            apeFrameDataBytesHigh: Token.UINT32_LE.get(buf, off + 28),\r\n            // the terminating data of the file (not including tag data)\r\n            terminatingDataBytes: Token.UINT32_LE.get(buf, off + 32),\r\n            // the MD5 hash of the file (see notes for usage... it's a little tricky)\r\n            fileMD5: new Token.Uint8ArrayType(16).get(buf, off + 36)\r\n        };\r\n    }\r\n};\r\n/**\r\n * APE_HEADER: describes all of the necessary information about the APE file\r\n */\r\nexport const Header = {\r\n    len: 24,\r\n    get: (buf, off) => {\r\n        return {\r\n            // the compression level (see defines I.E. COMPRESSION_LEVEL_FAST)\r\n            compressionLevel: Token.UINT16_LE.get(buf, off),\r\n            // any format flags (for future use)\r\n            formatFlags: Token.UINT16_LE.get(buf, off + 2),\r\n            // the number of audio blocks in one frame\r\n            blocksPerFrame: Token.UINT32_LE.get(buf, off + 4),\r\n            // the number of audio blocks in the final frame\r\n            finalFrameBlocks: Token.UINT32_LE.get(buf, off + 8),\r\n            // the total number of frames\r\n            totalFrames: Token.UINT32_LE.get(buf, off + 12),\r\n            // the bits per sample (typically 16)\r\n            bitsPerSample: Token.UINT16_LE.get(buf, off + 16),\r\n            // the number of channels (1 or 2)\r\n            channel: Token.UINT16_LE.get(buf, off + 18),\r\n            // the sample rate (typically 44100)\r\n            sampleRate: Token.UINT32_LE.get(buf, off + 20)\r\n        };\r\n    }\r\n};\r\n/**\r\n * APE Tag Header/Footer Version 2.0\r\n * TAG: describes all the properties of the file [optional]\r\n */\r\nexport const TagFooter = {\r\n    len: 32,\r\n    get: (buf, off) => {\r\n        return {\r\n            // should equal 'APETAGEX'\r\n            ID: new Token.StringType(8, 'ascii').get(buf, off),\r\n            // equals CURRENT_APE_TAG_VERSION\r\n            version: Token.UINT32_LE.get(buf, off + 8),\r\n            // the complete size of the tag, including this footer (excludes header)\r\n            size: Token.UINT32_LE.get(buf, off + 12),\r\n            // the number of fields in the tag\r\n            fields: Token.UINT32_LE.get(buf, off + 16),\r\n            // reserved for later use (must be zero),\r\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 20))\r\n        };\r\n    }\r\n};\r\n/**\r\n * APE Tag v2.0 Item Header\r\n */\r\nexport const TagItemHeader = {\r\n    len: 8,\r\n    get: (buf, off) => {\r\n        return {\r\n            // Length of assigned value in bytes\r\n            size: Token.UINT32_LE.get(buf, off),\r\n            // reserved for later use (must be zero),\r\n            flags: parseTagFlags(Token.UINT32_LE.get(buf, off + 4))\r\n        };\r\n    }\r\n};\r\nexport function parseTagFlags(flags) {\r\n    return {\r\n        containsHeader: isBitSet(flags, 31),\r\n        containsFooter: isBitSet(flags, 30),\r\n        isHeader: isBitSet(flags, 29),\r\n        readOnly: isBitSet(flags, 0),\r\n        dataType: (flags & 6) >> 1\r\n    };\r\n}\r\n/**\r\n * @param num {number}\r\n * @param bit 0 is least significant bit (LSB)\r\n * @return {boolean} true if bit is 1; otherwise false\r\n */\r\nexport function isBitSet(num, bit) {\r\n    return (num & 1 << bit) !== 0;\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}