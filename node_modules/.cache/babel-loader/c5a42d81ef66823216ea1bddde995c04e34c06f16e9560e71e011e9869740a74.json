{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.for-each.js\";\nimport * as strtok3 from 'strtok3';\nimport * as Token from 'token-types';\nimport initDebug from 'debug';\nimport * as riff from '../riff/RiffChunk.js';\nimport * as WaveChunk from './WaveChunk.js';\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\nimport * as util from '../common/Util.js';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { BroadcastAudioExtensionChunk } from './BwfChunk.js';\nimport { WaveContentError } from './WaveChunk.js';\nconst debug = initDebug('music-metadata:parser:RIFF');\n/**\r\n * Resource Interchange File Format (RIFF) Parser\r\n *\r\n * WAVE PCM soundfile format\r\n *\r\n * Ref:\r\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\r\n * - http://soundfile.sapp.org/doc/WaveFormat\r\n *\r\n * ToDo: Split WAVE part from RIFF parser\r\n */\nexport class WaveParser extends BasicParser {\n  constructor() {\n    super(...arguments);\n    this.blockAlign = 0;\n  }\n  async parse() {\n    const riffHeader = await this.tokenizer.readToken(riff.Header);\n    debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\n    if (riffHeader.chunkID !== 'RIFF') return; // Not RIFF format\n    this.metadata.setAudioOnly();\n    return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\n      if (!(err instanceof strtok3.EndOfStreamError)) {\n        throw err;\n      }\n    });\n  }\n  async parseRiffChunk(chunkSize) {\n    const type = await this.tokenizer.readToken(FourCcToken);\n    this.metadata.setFormat('container', type);\n    switch (type) {\n      case 'WAVE':\n        return this.readWaveChunk(chunkSize - FourCcToken.len);\n      default:\n        throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);\n    }\n  }\n  async readWaveChunk(remaining) {\n    while (remaining >= riff.Header.len) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      remaining -= riff.Header.len + header.chunkSize;\n      if (header.chunkSize > remaining) {\n        this.metadata.addWarning('Data chunk size exceeds file size');\n      }\n      this.header = header;\n      debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\n      switch (header.chunkID) {\n        case 'LIST':\n          await this.parseListTag(header);\n          break;\n        case 'fact':\n          // extended Format chunk,\n          this.metadata.setFormat('lossless', false);\n          this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\n          break;\n        case 'fmt ':\n          {\n            // The Util Chunk, non-PCM Formats\n            const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\n            let subFormat = WaveChunk.WaveFormatNameMap[fmt.wFormatTag];\n            if (!subFormat) {\n              debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);\n              subFormat = `non-PCM (${fmt.wFormatTag})`;\n            }\n            this.metadata.setFormat('codec', subFormat);\n            this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\n            this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\n            this.metadata.setFormat('numberOfChannels', fmt.nChannels);\n            this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\n            this.blockAlign = fmt.nBlockAlign;\n            break;\n          }\n        case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\n        case 'ID3 ':\n          {\n            // The way Mp3Tags stores ID3 meta-data\n            const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\n            const rst = strtok3.fromBuffer(id3_data);\n            await new ID3v2Parser().parse(this.metadata, rst, this.options);\n            break;\n          }\n        case 'data':\n          {\n            // PCM-data\n            if (this.metadata.format.lossless !== false) {\n              this.metadata.setFormat('lossless', true);\n            }\n            let chunkSize = header.chunkSize;\n            if (this.tokenizer.fileInfo.size) {\n              const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\n              if (calcRemaining < chunkSize) {\n                this.metadata.addWarning('data chunk length exceeding file length');\n                chunkSize = calcRemaining;\n              }\n            }\n            const numberOfSamples = this.fact ? this.fact.dwSampleLength : chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign;\n            if (numberOfSamples) {\n              this.metadata.setFormat('numberOfSamples', numberOfSamples);\n              if (this.metadata.format.sampleRate) {\n                this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\n              }\n            }\n            if (this.metadata.format.codec === 'ADPCM') {\n              // ADPCM is 4 bits lossy encoding resulting in 352kbps\n              this.metadata.setFormat('bitrate', 352000);\n            } else if (this.metadata.format.sampleRate) {\n              this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\n            }\n            await this.tokenizer.ignore(header.chunkSize);\n            break;\n          }\n        case 'bext':\n          {\n            // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\n            const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);\n            Object.keys(bext).forEach(key => {\n              this.metadata.addTag('exif', `bext.${key}`, bext[key]);\n            });\n            const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;\n            await this.tokenizer.ignore(bextRemaining);\n            break;\n          }\n        case '\\x00\\x00\\x00\\x00':\n          // padding ??\n          debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n          this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\n          await this.tokenizer.ignore(header.chunkSize);\n          break;\n        default:\n          debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\n          this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\n          await this.tokenizer.ignore(header.chunkSize);\n      }\n      if (this.header.chunkSize % 2 === 1) {\n        debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\n        await this.tokenizer.ignore(1);\n      }\n    }\n  }\n  async parseListTag(listHeader) {\n    const listType = await this.tokenizer.readToken(new Token.StringType(4, 'latin1'));\n    debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\n    switch (listType) {\n      case 'INFO':\n        return this.parseRiffInfoTags(listHeader.chunkSize - 4);\n      default:\n        this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);\n        debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);\n        return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\n    }\n  }\n  async parseRiffInfoTags(chunkSize) {\n    while (chunkSize >= 8) {\n      const header = await this.tokenizer.readToken(riff.Header);\n      const valueToken = new riff.ListInfoTagValue(header);\n      const value = await this.tokenizer.readToken(valueToken);\n      this.addTag(header.chunkID, util.stripNulls(value));\n      chunkSize -= 8 + valueToken.len;\n    }\n    if (chunkSize !== 0) {\n      throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);\n    }\n  }\n  addTag(id, value) {\n    this.metadata.addTag('exif', id, value);\n  }\n}","map":{"version":3,"names":["strtok3","Token","initDebug","riff","WaveChunk","ID3v2Parser","util","FourCcToken","BasicParser","BroadcastAudioExtensionChunk","WaveContentError","debug","WaveParser","constructor","arguments","blockAlign","parse","riffHeader","tokenizer","readToken","Header","position","chunkID","metadata","setAudioOnly","parseRiffChunk","chunkSize","catch","err","EndOfStreamError","type","setFormat","readWaveChunk","len","remaining","header","addWarning","parseListTag","fact","FactChunk","fmt","Format","subFormat","WaveFormatNameMap","wFormatTag","wBitsPerSample","nSamplesPerSec","nChannels","nBlockAlign","id3_data","Uint8ArrayType","rst","fromBuffer","options","format","lossless","fileInfo","size","calcRemaining","numberOfSamples","dwSampleLength","undefined","sampleRate","codec","ignore","bext","Object","keys","forEach","key","addTag","bextRemaining","listHeader","listType","StringType","parseRiffInfoTags","then","valueToken","ListInfoTagValue","value","stripNulls","id"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/wav/WaveParser.js"],"sourcesContent":["import * as strtok3 from 'strtok3';\r\nimport * as Token from 'token-types';\r\nimport initDebug from 'debug';\r\nimport * as riff from '../riff/RiffChunk.js';\r\nimport * as WaveChunk from './WaveChunk.js';\r\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\r\nimport * as util from '../common/Util.js';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { BroadcastAudioExtensionChunk } from './BwfChunk.js';\r\nimport { WaveContentError } from './WaveChunk.js';\r\nconst debug = initDebug('music-metadata:parser:RIFF');\r\n/**\r\n * Resource Interchange File Format (RIFF) Parser\r\n *\r\n * WAVE PCM soundfile format\r\n *\r\n * Ref:\r\n * - http://www.johnloomis.org/cpe102/asgn/asgn1/riff.html\r\n * - http://soundfile.sapp.org/doc/WaveFormat\r\n *\r\n * ToDo: Split WAVE part from RIFF parser\r\n */\r\nexport class WaveParser extends BasicParser {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.blockAlign = 0;\r\n    }\r\n    async parse() {\r\n        const riffHeader = await this.tokenizer.readToken(riff.Header);\r\n        debug(`pos=${this.tokenizer.position}, parse: chunkID=${riffHeader.chunkID}`);\r\n        if (riffHeader.chunkID !== 'RIFF')\r\n            return; // Not RIFF format\r\n        this.metadata.setAudioOnly();\r\n        return this.parseRiffChunk(riffHeader.chunkSize).catch(err => {\r\n            if (!(err instanceof strtok3.EndOfStreamError)) {\r\n                throw err;\r\n            }\r\n        });\r\n    }\r\n    async parseRiffChunk(chunkSize) {\r\n        const type = await this.tokenizer.readToken(FourCcToken);\r\n        this.metadata.setFormat('container', type);\r\n        switch (type) {\r\n            case 'WAVE':\r\n                return this.readWaveChunk(chunkSize - FourCcToken.len);\r\n            default:\r\n                throw new WaveContentError(`Unsupported RIFF format: RIFF/${type}`);\r\n        }\r\n    }\r\n    async readWaveChunk(remaining) {\r\n        while (remaining >= riff.Header.len) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            remaining -= riff.Header.len + header.chunkSize;\r\n            if (header.chunkSize > remaining) {\r\n                this.metadata.addWarning('Data chunk size exceeds file size');\r\n            }\r\n            this.header = header;\r\n            debug(`pos=${this.tokenizer.position}, readChunk: chunkID=RIFF/WAVE/${header.chunkID}`);\r\n            switch (header.chunkID) {\r\n                case 'LIST':\r\n                    await this.parseListTag(header);\r\n                    break;\r\n                case 'fact': // extended Format chunk,\r\n                    this.metadata.setFormat('lossless', false);\r\n                    this.fact = await this.tokenizer.readToken(new WaveChunk.FactChunk(header));\r\n                    break;\r\n                case 'fmt ': { // The Util Chunk, non-PCM Formats\r\n                    const fmt = await this.tokenizer.readToken(new WaveChunk.Format(header));\r\n                    let subFormat = WaveChunk.WaveFormatNameMap[fmt.wFormatTag];\r\n                    if (!subFormat) {\r\n                        debug(`WAVE/non-PCM format=${fmt.wFormatTag}`);\r\n                        subFormat = `non-PCM (${fmt.wFormatTag})`;\r\n                    }\r\n                    this.metadata.setFormat('codec', subFormat);\r\n                    this.metadata.setFormat('bitsPerSample', fmt.wBitsPerSample);\r\n                    this.metadata.setFormat('sampleRate', fmt.nSamplesPerSec);\r\n                    this.metadata.setFormat('numberOfChannels', fmt.nChannels);\r\n                    this.metadata.setFormat('bitrate', fmt.nBlockAlign * fmt.nSamplesPerSec * 8);\r\n                    this.blockAlign = fmt.nBlockAlign;\r\n                    break;\r\n                }\r\n                case 'id3 ': // The way Picard, FooBar currently stores, ID3 meta-data\r\n                case 'ID3 ': { // The way Mp3Tags stores ID3 meta-data\r\n                    const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(header.chunkSize));\r\n                    const rst = strtok3.fromBuffer(id3_data);\r\n                    await new ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                    break;\r\n                }\r\n                case 'data': { // PCM-data\r\n                    if (this.metadata.format.lossless !== false) {\r\n                        this.metadata.setFormat('lossless', true);\r\n                    }\r\n                    let chunkSize = header.chunkSize;\r\n                    if (this.tokenizer.fileInfo.size) {\r\n                        const calcRemaining = this.tokenizer.fileInfo.size - this.tokenizer.position;\r\n                        if (calcRemaining < chunkSize) {\r\n                            this.metadata.addWarning('data chunk length exceeding file length');\r\n                            chunkSize = calcRemaining;\r\n                        }\r\n                    }\r\n                    const numberOfSamples = this.fact ? this.fact.dwSampleLength : (chunkSize === 0xffffffff ? undefined : chunkSize / this.blockAlign);\r\n                    if (numberOfSamples) {\r\n                        this.metadata.setFormat('numberOfSamples', numberOfSamples);\r\n                        if (this.metadata.format.sampleRate) {\r\n                            this.metadata.setFormat('duration', numberOfSamples / this.metadata.format.sampleRate);\r\n                        }\r\n                    }\r\n                    if (this.metadata.format.codec === 'ADPCM') { // ADPCM is 4 bits lossy encoding resulting in 352kbps\r\n                        this.metadata.setFormat('bitrate', 352000);\r\n                    }\r\n                    else if (this.metadata.format.sampleRate) {\r\n                        this.metadata.setFormat('bitrate', this.blockAlign * this.metadata.format.sampleRate * 8);\r\n                    }\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n                    break;\r\n                }\r\n                case 'bext': { // Broadcast Audio Extension chunk\thttps://tech.ebu.ch/docs/tech/tech3285.pdf\r\n                    const bext = await this.tokenizer.readToken(BroadcastAudioExtensionChunk);\r\n                    Object.keys(bext).forEach(key => {\r\n                        this.metadata.addTag('exif', `bext.${key}`, bext[key]);\r\n                    });\r\n                    const bextRemaining = header.chunkSize - BroadcastAudioExtensionChunk.len;\r\n                    await this.tokenizer.ignore(bextRemaining);\r\n                    break;\r\n                }\r\n                case '\\x00\\x00\\x00\\x00': // padding ??\r\n                    debug(`Ignore padding chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\r\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n                    break;\r\n                default:\r\n                    debug(`Ignore chunk: RIFF/${header.chunkID} of ${header.chunkSize} bytes`);\r\n                    this.metadata.addWarning(`Ignore chunk: RIFF/${header.chunkID}`);\r\n                    await this.tokenizer.ignore(header.chunkSize);\r\n            }\r\n            if (this.header.chunkSize % 2 === 1) {\r\n                debug('Read odd padding byte'); // https://wiki.multimedia.cx/index.php/RIFF\r\n                await this.tokenizer.ignore(1);\r\n            }\r\n        }\r\n    }\r\n    async parseListTag(listHeader) {\r\n        const listType = await this.tokenizer.readToken(new Token.StringType(4, 'latin1'));\r\n        debug('pos=%s, parseListTag: chunkID=RIFF/WAVE/LIST/%s', this.tokenizer.position, listType);\r\n        switch (listType) {\r\n            case 'INFO':\r\n                return this.parseRiffInfoTags(listHeader.chunkSize - 4);\r\n            default:\r\n                this.metadata.addWarning(`Ignore chunk: RIFF/WAVE/LIST/${listType}`);\r\n                debug(`Ignoring chunkID=RIFF/WAVE/LIST/${listType}`);\r\n                return this.tokenizer.ignore(listHeader.chunkSize - 4).then();\r\n        }\r\n    }\r\n    async parseRiffInfoTags(chunkSize) {\r\n        while (chunkSize >= 8) {\r\n            const header = await this.tokenizer.readToken(riff.Header);\r\n            const valueToken = new riff.ListInfoTagValue(header);\r\n            const value = await this.tokenizer.readToken(valueToken);\r\n            this.addTag(header.chunkID, util.stripNulls(value));\r\n            chunkSize -= (8 + valueToken.len);\r\n        }\r\n        if (chunkSize !== 0) {\r\n            throw new WaveContentError(`Illegal remaining size: ${chunkSize}`);\r\n        }\r\n    }\r\n    addTag(id, value) {\r\n        this.metadata.addTag('exif', id, value);\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}