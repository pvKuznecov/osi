{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport * as Token from 'token-types';\nimport initDebug from 'debug';\nimport * as strtok3 from 'strtok3';\nimport { FourCcToken } from '../common/FourCC.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\nimport { ChunkHeader64 } from './DsdiffToken.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nconst debug = initDebug('music-metadata:parser:aiff');\nexport class DsdiffContentParseError extends makeUnexpectedFileContentError('DSDIFF') {}\n/**\r\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\r\n *\r\n * Ref:\r\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\r\n */\nexport class DsdiffParser extends BasicParser {\n  async parse() {\n    const header = await this.tokenizer.readToken(ChunkHeader64);\n    if (header.chunkID !== 'FRM8') throw new DsdiffContentParseError('Unexpected chunk-ID');\n    this.metadata.setAudioOnly();\n    const type = (await this.tokenizer.readToken(FourCcToken)).trim();\n    switch (type) {\n      case 'DSD':\n        this.metadata.setFormat('container', `DSDIFF/${type}`);\n        this.metadata.setFormat('lossless', true);\n        return this.readFmt8Chunks(header.chunkSize - BigInt(FourCcToken.len));\n      default:\n        throw new DsdiffContentParseError(`Unsupported DSDIFF type: ${type}`);\n    }\n  }\n  async readFmt8Chunks(remainingSize) {\n    while (remainingSize >= ChunkHeader64.len) {\n      const chunkHeader = await this.tokenizer.readToken(ChunkHeader64);\n      //  If the data is an odd number of bytes in length, a pad byte must be added at the end\n      debug(`Chunk id=${chunkHeader.chunkID}`);\n      await this.readData(chunkHeader);\n      remainingSize -= BigInt(ChunkHeader64.len) + chunkHeader.chunkSize;\n    }\n  }\n  async readData(header) {\n    debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n    const p0 = this.tokenizer.position;\n    switch (header.chunkID.trim()) {\n      case 'FVER':\n        {\n          // 3.1 FORMAT VERSION CHUNK\n          const version = await this.tokenizer.readToken(Token.UINT32_LE);\n          debug(`DSDIFF version=${version}`);\n          break;\n        }\n      case 'PROP':\n        {\n          // 3.2 PROPERTY CHUNK\n          const propType = await this.tokenizer.readToken(FourCcToken);\n          if (propType !== 'SND ') throw new DsdiffContentParseError('Unexpected PROP-chunk ID');\n          await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCcToken.len));\n          break;\n        }\n      case 'ID3':\n        {\n          // Unofficial ID3 tag support\n          const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\n          const rst = strtok3.fromBuffer(id3_data);\n          await new ID3v2Parser().parse(this.metadata, rst, this.options);\n          break;\n        }\n      case 'DSD':\n        if (this.metadata.format.numberOfChannels) {\n          this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\n        }\n        if (this.metadata.format.numberOfSamples && this.metadata.format.sampleRate) {\n          this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\n        }\n        break;\n      default:\n        debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\n        break;\n    }\n    const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\n    if (remaining > 0) {\n      debug(`After Parsing chunk, remaining ${remaining} bytes`);\n      await this.tokenizer.ignore(Number(remaining));\n    }\n  }\n  async handleSoundPropertyChunks(remainingSize) {\n    debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n    while (remainingSize > 0) {\n      const sndPropHeader = await this.tokenizer.readToken(ChunkHeader64);\n      debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n      const p0 = this.tokenizer.position;\n      switch (sndPropHeader.chunkID.trim()) {\n        case 'FS':\n          {\n            // 3.2.1 Sample Rate Chunk\n            const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\n            this.metadata.setFormat('sampleRate', sampleRate);\n            break;\n          }\n        case 'CHNL':\n          {\n            // 3.2.2 Channels Chunk\n            const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\n            this.metadata.setFormat('numberOfChannels', numChannels);\n            await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\n            break;\n          }\n        case 'CMPR':\n          {\n            // 3.2.3 Compression Type Chunk\n            const compressionIdCode = (await this.tokenizer.readToken(FourCcToken)).trim();\n            const count = await this.tokenizer.readToken(Token.UINT8);\n            const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\n            if (compressionIdCode === 'DSD') {\n              this.metadata.setFormat('lossless', true);\n              this.metadata.setFormat('bitsPerSample', 1);\n            }\n            this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\n            break;\n          }\n        case 'ABSS':\n          {\n            // 3.2.4 Absolute Start Time Chunk\n            const hours = await this.tokenizer.readToken(Token.UINT16_BE);\n            const minutes = await this.tokenizer.readToken(Token.UINT8);\n            const seconds = await this.tokenizer.readToken(Token.UINT8);\n            const samples = await this.tokenizer.readToken(Token.UINT32_BE);\n            debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\n            break;\n          }\n        case 'LSCO':\n          {\n            // 3.2.5 Loudspeaker Configuration Chunk\n            const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\n            debug(`LSCO lsConfig=${lsConfig}`);\n            break;\n          }\n        default:\n          debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\n          await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\n      }\n      const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\n      if (remaining > 0) {\n        debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\n        await this.tokenizer.ignore(Number(remaining));\n      }\n      remainingSize -= BigInt(ChunkHeader64.len) + sndPropHeader.chunkSize;\n      debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\n    }\n    if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\n      const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\n      this.metadata.setFormat('bitrate', bitrate);\n    }\n  }\n  async handleChannelChunks(remainingSize) {\n    debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\n    const channels = [];\n    while (remainingSize >= FourCcToken.len) {\n      const channelId = await this.tokenizer.readToken(FourCcToken);\n      debug(`Channel[ID=${channelId}]`);\n      channels.push(channelId);\n      remainingSize -= BigInt(FourCcToken.len);\n    }\n    debug(`Channels: ${channels.join(', ')}`);\n    return channels;\n  }\n}","map":{"version":3,"names":["Token","initDebug","strtok3","FourCcToken","BasicParser","ID3v2Parser","ChunkHeader64","makeUnexpectedFileContentError","debug","DsdiffContentParseError","DsdiffParser","parse","header","tokenizer","readToken","chunkID","metadata","setAudioOnly","type","trim","setFormat","readFmt8Chunks","chunkSize","BigInt","len","remainingSize","chunkHeader","readData","p0","position","version","UINT32_LE","propType","handleSoundPropertyChunks","id3_data","Uint8ArrayType","Number","rst","fromBuffer","options","format","numberOfChannels","numberOfSamples","sampleRate","remaining","ignore","sndPropHeader","UINT32_BE","numChannels","UINT16_BE","handleChannelChunks","compressionIdCode","count","UINT8","compressionName","StringType","hours","minutes","seconds","samples","lsConfig","lossless","bitsPerSample","bitrate","channels","channelId","push","join"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/dsdiff/DsdiffParser.js"],"sourcesContent":["import * as Token from 'token-types';\r\nimport initDebug from 'debug';\r\nimport * as strtok3 from 'strtok3';\r\nimport { FourCcToken } from '../common/FourCC.js';\r\nimport { BasicParser } from '../common/BasicParser.js';\r\nimport { ID3v2Parser } from '../id3v2/ID3v2Parser.js';\r\nimport { ChunkHeader64 } from './DsdiffToken.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nconst debug = initDebug('music-metadata:parser:aiff');\r\nexport class DsdiffContentParseError extends makeUnexpectedFileContentError('DSDIFF') {\r\n}\r\n/**\r\n * DSDIFF - Direct Stream Digital Interchange File Format (Phillips)\r\n *\r\n * Ref:\r\n * - http://www.sonicstudio.com/pdf/dsd/DSDIFF_1.5_Spec.pdf\r\n */\r\nexport class DsdiffParser extends BasicParser {\r\n    async parse() {\r\n        const header = await this.tokenizer.readToken(ChunkHeader64);\r\n        if (header.chunkID !== 'FRM8')\r\n            throw new DsdiffContentParseError('Unexpected chunk-ID');\r\n        this.metadata.setAudioOnly();\r\n        const type = (await this.tokenizer.readToken(FourCcToken)).trim();\r\n        switch (type) {\r\n            case 'DSD':\r\n                this.metadata.setFormat('container', `DSDIFF/${type}`);\r\n                this.metadata.setFormat('lossless', true);\r\n                return this.readFmt8Chunks(header.chunkSize - BigInt(FourCcToken.len));\r\n            default:\r\n                throw new DsdiffContentParseError(`Unsupported DSDIFF type: ${type}`);\r\n        }\r\n    }\r\n    async readFmt8Chunks(remainingSize) {\r\n        while (remainingSize >= ChunkHeader64.len) {\r\n            const chunkHeader = await this.tokenizer.readToken(ChunkHeader64);\r\n            //  If the data is an odd number of bytes in length, a pad byte must be added at the end\r\n            debug(`Chunk id=${chunkHeader.chunkID}`);\r\n            await this.readData(chunkHeader);\r\n            remainingSize -= (BigInt(ChunkHeader64.len) + chunkHeader.chunkSize);\r\n        }\r\n    }\r\n    async readData(header) {\r\n        debug(`Reading data of chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\r\n        const p0 = this.tokenizer.position;\r\n        switch (header.chunkID.trim()) {\r\n            case 'FVER': { // 3.1 FORMAT VERSION CHUNK\r\n                const version = await this.tokenizer.readToken(Token.UINT32_LE);\r\n                debug(`DSDIFF version=${version}`);\r\n                break;\r\n            }\r\n            case 'PROP': { // 3.2 PROPERTY CHUNK\r\n                const propType = await this.tokenizer.readToken(FourCcToken);\r\n                if (propType !== 'SND ')\r\n                    throw new DsdiffContentParseError('Unexpected PROP-chunk ID');\r\n                await this.handleSoundPropertyChunks(header.chunkSize - BigInt(FourCcToken.len));\r\n                break;\r\n            }\r\n            case 'ID3': { // Unofficial ID3 tag support\r\n                const id3_data = await this.tokenizer.readToken(new Token.Uint8ArrayType(Number(header.chunkSize)));\r\n                const rst = strtok3.fromBuffer(id3_data);\r\n                await new ID3v2Parser().parse(this.metadata, rst, this.options);\r\n                break;\r\n            }\r\n            case 'DSD':\r\n                if (this.metadata.format.numberOfChannels) {\r\n                    this.metadata.setFormat('numberOfSamples', Number(header.chunkSize * BigInt(8) / BigInt(this.metadata.format.numberOfChannels)));\r\n                }\r\n                if (this.metadata.format.numberOfSamples && this.metadata.format.sampleRate) {\r\n                    this.metadata.setFormat('duration', this.metadata.format.numberOfSamples / this.metadata.format.sampleRate);\r\n                }\r\n                break;\r\n            default:\r\n                debug(`Ignore chunk[ID=${header.chunkID}, size=${header.chunkSize}]`);\r\n                break;\r\n        }\r\n        const remaining = header.chunkSize - BigInt(this.tokenizer.position - p0);\r\n        if (remaining > 0) {\r\n            debug(`After Parsing chunk, remaining ${remaining} bytes`);\r\n            await this.tokenizer.ignore(Number(remaining));\r\n        }\r\n    }\r\n    async handleSoundPropertyChunks(remainingSize) {\r\n        debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\r\n        while (remainingSize > 0) {\r\n            const sndPropHeader = await this.tokenizer.readToken(ChunkHeader64);\r\n            debug(`Sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\r\n            const p0 = this.tokenizer.position;\r\n            switch (sndPropHeader.chunkID.trim()) {\r\n                case 'FS': { // 3.2.1 Sample Rate Chunk\r\n                    const sampleRate = await this.tokenizer.readToken(Token.UINT32_BE);\r\n                    this.metadata.setFormat('sampleRate', sampleRate);\r\n                    break;\r\n                }\r\n                case 'CHNL': { // 3.2.2 Channels Chunk\r\n                    const numChannels = await this.tokenizer.readToken(Token.UINT16_BE);\r\n                    this.metadata.setFormat('numberOfChannels', numChannels);\r\n                    await this.handleChannelChunks(sndPropHeader.chunkSize - BigInt(Token.UINT16_BE.len));\r\n                    break;\r\n                }\r\n                case 'CMPR': { // 3.2.3 Compression Type Chunk\r\n                    const compressionIdCode = (await this.tokenizer.readToken(FourCcToken)).trim();\r\n                    const count = await this.tokenizer.readToken(Token.UINT8);\r\n                    const compressionName = await this.tokenizer.readToken(new Token.StringType(count, 'ascii'));\r\n                    if (compressionIdCode === 'DSD') {\r\n                        this.metadata.setFormat('lossless', true);\r\n                        this.metadata.setFormat('bitsPerSample', 1);\r\n                    }\r\n                    this.metadata.setFormat('codec', `${compressionIdCode} (${compressionName})`);\r\n                    break;\r\n                }\r\n                case 'ABSS': { // 3.2.4 Absolute Start Time Chunk\r\n                    const hours = await this.tokenizer.readToken(Token.UINT16_BE);\r\n                    const minutes = await this.tokenizer.readToken(Token.UINT8);\r\n                    const seconds = await this.tokenizer.readToken(Token.UINT8);\r\n                    const samples = await this.tokenizer.readToken(Token.UINT32_BE);\r\n                    debug(`ABSS ${hours}:${minutes}:${seconds}.${samples}`);\r\n                    break;\r\n                }\r\n                case 'LSCO': { // 3.2.5 Loudspeaker Configuration Chunk\r\n                    const lsConfig = await this.tokenizer.readToken(Token.UINT16_BE);\r\n                    debug(`LSCO lsConfig=${lsConfig}`);\r\n                    break;\r\n                }\r\n                default:\r\n                    debug(`Unknown sound-property-chunk[ID=${sndPropHeader.chunkID}, size=${sndPropHeader.chunkSize}]`);\r\n                    await this.tokenizer.ignore(Number(sndPropHeader.chunkSize));\r\n            }\r\n            const remaining = sndPropHeader.chunkSize - BigInt(this.tokenizer.position - p0);\r\n            if (remaining > 0) {\r\n                debug(`After Parsing sound-property-chunk ${sndPropHeader.chunkSize}, remaining ${remaining} bytes`);\r\n                await this.tokenizer.ignore(Number(remaining));\r\n            }\r\n            remainingSize -= BigInt(ChunkHeader64.len) + sndPropHeader.chunkSize;\r\n            debug(`Parsing sound-property-chunks, remainingSize=${remainingSize}`);\r\n        }\r\n        if (this.metadata.format.lossless && this.metadata.format.sampleRate && this.metadata.format.numberOfChannels && this.metadata.format.bitsPerSample) {\r\n            const bitrate = this.metadata.format.sampleRate * this.metadata.format.numberOfChannels * this.metadata.format.bitsPerSample;\r\n            this.metadata.setFormat('bitrate', bitrate);\r\n        }\r\n    }\r\n    async handleChannelChunks(remainingSize) {\r\n        debug(`Parsing channel-chunks, remainingSize=${remainingSize}`);\r\n        const channels = [];\r\n        while (remainingSize >= FourCcToken.len) {\r\n            const channelId = await this.tokenizer.readToken(FourCcToken);\r\n            debug(`Channel[ID=${channelId}]`);\r\n            channels.push(channelId);\r\n            remainingSize -= BigInt(FourCcToken.len);\r\n        }\r\n        debug(`Channels: ${channels.join(', ')}`);\r\n        return channels;\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}