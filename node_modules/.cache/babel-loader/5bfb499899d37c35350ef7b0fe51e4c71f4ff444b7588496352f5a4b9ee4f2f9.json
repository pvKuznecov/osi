{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\nimport initDebug from 'debug';\nimport * as Token from 'token-types';\nimport * as util from '../common/Util.js';\nimport { AttachedPictureType, SyncTextHeader, TextEncodingToken, TextHeader } from './ID3v2Token.js';\nimport { Genres } from '../id3v1/ID3v1Parser.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport { decodeUintBE } from '../common/Util.js';\nconst debug = initDebug('music-metadata:id3v2:frame-parser');\nconst defaultEnc = 'latin1'; // latin1 == iso-8859-1;\nexport function parseGenre(origVal) {\n  // match everything inside parentheses\n  const genres = [];\n  let code;\n  let word = '';\n  for (const c of origVal) {\n    if (typeof code === 'string') {\n      if (c === '(' && code === '') {\n        word += '(';\n        code = undefined;\n      } else if (c === ')') {\n        if (word !== '') {\n          genres.push(word);\n          word = '';\n        }\n        const genre = parseGenreCode(code);\n        if (genre) {\n          genres.push(genre);\n        }\n        code = undefined;\n      } else code += c;\n    } else if (c === '(') {\n      code = '';\n    } else {\n      word += c;\n    }\n  }\n  if (word) {\n    if (genres.length === 0 && word.match(/^\\d*$/)) {\n      word = parseGenreCode(word);\n    }\n    if (word) {\n      genres.push(word);\n    }\n  }\n  return genres;\n}\nfunction parseGenreCode(code) {\n  if (code === 'RX') return 'Remix';\n  if (code === 'CR') return 'Cover';\n  if (code.match(/^\\d*$/)) {\n    return Genres[Number.parseInt(code, 10)];\n  }\n}\nexport class FrameParser {\n  /**\r\n   * Create id3v2 frame parser\r\n   * @param major - Major version, e.g. (4) for  id3v2.4\r\n   * @param warningCollector - Used to collect decode issue\r\n   */\n  constructor(major, warningCollector) {\n    this.major = major;\n    this.warningCollector = warningCollector;\n  }\n  readData(uint8Array, type, includeCovers) {\n    if (uint8Array.length === 0) {\n      this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);\n      return;\n    }\n    const {\n      encoding,\n      bom\n    } = TextEncodingToken.get(uint8Array, 0);\n    const length = uint8Array.length;\n    let offset = 0;\n    let output = []; // ToDo\n    const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);\n    let fzero;\n    debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);\n    switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {\n      case 'T*': // 4.2.1. Text information frames - details\n      case 'GRP1': // iTunes-specific ID3v2 grouping field\n      case 'IPLS': // v2.3: Involved people list\n      case 'MVIN':\n      case 'MVNM':\n      case 'PCS':\n      case 'PCST':\n        {\n          let text;\n          try {\n            text = util.decodeString(uint8Array.subarray(1), encoding).replace(/\\x00+$/, '');\n          } catch (error) {\n            if (error instanceof Error) {\n              this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);\n              break;\n            }\n            throw error;\n          }\n          switch (type) {\n            case 'TMCL': // Musician credits list\n            case 'TIPL': // Involved people list\n            case 'IPLS':\n              // Involved people list\n              output = FrameParser.functionList(this.splitValue(type, text));\n              break;\n            case 'TRK':\n            case 'TRCK':\n            case 'TPOS':\n              output = text;\n              break;\n            case 'TCOM':\n            case 'TEXT':\n            case 'TOLY':\n            case 'TOPE':\n            case 'TPE1':\n            case 'TSRC':\n              // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\n              output = this.splitValue(type, text);\n              break;\n            case 'TCO':\n            case 'TCON':\n              output = this.splitValue(type, text).map(v => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);\n              break;\n            case 'PCS':\n            case 'PCST':\n              // TODO: Why `default` not results `1` but `''`?\n              output = this.major >= 4 ? this.splitValue(type, text) : [text];\n              output = Array.isArray(output) && output[0] === '' ? 1 : 0;\n              break;\n            default:\n              output = this.major >= 4 ? this.splitValue(type, text) : [text];\n          }\n          break;\n        }\n      case 'TXXX':\n        {\n          const idAndData = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);\n          const textTag = {\n            description: idAndData.id,\n            text: this.splitValue(type, util.decodeString(idAndData.data, encoding).replace(/\\x00+$/, ''))\n          };\n          output = textTag;\n          break;\n        }\n      case 'PIC':\n      case 'APIC':\n        if (includeCovers) {\n          const pic = {};\n          offset += 1;\n          switch (this.major) {\n            case 2:\n              pic.format = util.decodeString(uint8Array.subarray(offset, offset + 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;\n              offset += 3;\n              break;\n            case 3:\n            case 4:\n              fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n              pic.format = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\n              offset = fzero + 1;\n              break;\n            default:\n              throw makeUnexpectedMajorVersionError(this.major);\n          }\n          pic.format = FrameParser.fixPictureMimeType(pic.format);\n          pic.type = AttachedPictureType[uint8Array[offset]];\n          offset += 1;\n          fzero = util.findZero(uint8Array, offset, length, encoding);\n          pic.description = util.decodeString(uint8Array.subarray(offset, fzero), encoding);\n          offset = fzero + nullTerminatorLength;\n          pic.data = uint8Array.subarray(offset, length);\n          output = pic;\n        }\n        break;\n      case 'CNT':\n      case 'PCNT':\n        output = decodeUintBE(uint8Array);\n        break;\n      case 'SYLT':\n        {\n          const syltHeader = SyncTextHeader.get(uint8Array, 0);\n          offset += SyncTextHeader.len;\n          const result = {\n            descriptor: '',\n            language: syltHeader.language,\n            contentType: syltHeader.contentType,\n            timeStampFormat: syltHeader.timeStampFormat,\n            syncText: []\n          };\n          let readSyllables = false;\n          while (offset < length) {\n            const nullStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), syltHeader.encoding);\n            offset += nullStr.len;\n            if (readSyllables) {\n              const timestamp = Token.UINT32_BE.get(uint8Array, offset);\n              offset += Token.UINT32_BE.len;\n              result.syncText.push({\n                text: nullStr.text,\n                timestamp\n              });\n            } else {\n              result.descriptor = nullStr.text;\n              readSyllables = true;\n            }\n          }\n          output = result;\n          break;\n        }\n      case 'ULT':\n      case 'USLT':\n      case 'COM':\n      case 'COMM':\n        {\n          const textHeader = TextHeader.get(uint8Array, offset);\n          offset += TextHeader.len;\n          const descriptorStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);\n          offset += descriptorStr.len;\n          const textStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);\n          const comment = {\n            language: textHeader.language,\n            descriptor: descriptorStr.text,\n            text: textStr.text\n          };\n          output = comment;\n          break;\n        }\n      case 'UFID':\n        {\n          const ufid = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n          output = {\n            owner_identifier: ufid.id,\n            identifier: ufid.data\n          };\n          break;\n        }\n      case 'PRIV':\n        {\n          // private frame\n          const priv = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\n          output = {\n            owner_identifier: priv.id,\n            data: priv.data\n          };\n          break;\n        }\n      case 'POPM':\n        {\n          // Popularimeter\n          fzero = util.findZero(uint8Array, offset, length, defaultEnc);\n          const email = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\n          offset = fzero + 1;\n          const valueLen = length - offset - 1;\n          output = {\n            email,\n            rating: Token.UINT8.get(uint8Array, offset),\n            counter: valueLen > 0 ? util.decodeUintBE(uint8Array.subarray(offset + 1)) : undefined\n          };\n          break;\n        }\n      case 'GEOB':\n        {\n          // General encapsulated object\n          fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n          const mimeType = util.decodeString(uint8Array.subarray(offset + 1, fzero), defaultEnc);\n          offset = fzero + 1;\n          fzero = util.findZero(uint8Array, offset, length, encoding);\n          const filename = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\n          offset = fzero + 1;\n          fzero = util.findZero(uint8Array, offset, length, encoding);\n          const description = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\n          offset = fzero + 1;\n          const geob = {\n            type: mimeType,\n            filename,\n            description,\n            data: uint8Array.subarray(offset, length)\n          };\n          output = geob;\n          break;\n        }\n      // W-Frames:\n      case 'WCOM':\n      case 'WCOP':\n      case 'WOAF':\n      case 'WOAR':\n      case 'WOAS':\n      case 'WORS':\n      case 'WPAY':\n      case 'WPUB':\n        // Decode URL\n        fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n        output = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\n        break;\n      case 'WXXX':\n        {\n          // Decode URL\n          fzero = util.findZero(uint8Array, offset + 1, length, encoding);\n          const description = util.decodeString(uint8Array.subarray(offset + 1, fzero), encoding);\n          offset = fzero + (encoding === 'utf-16le' ? 2 : 1);\n          output = {\n            description,\n            url: util.decodeString(uint8Array.subarray(offset, length), defaultEnc)\n          };\n          break;\n        }\n      case 'WFD':\n      case 'WFED':\n        output = util.decodeString(uint8Array.subarray(offset + 1, util.findZero(uint8Array, offset + 1, length, encoding)), encoding);\n        break;\n      case 'MCDI':\n        {\n          // Music CD identifier\n          output = uint8Array.subarray(0, length);\n          break;\n        }\n      default:\n        debug(`Warning: unsupported id3v2-tag-type: ${type}`);\n        break;\n    }\n    return output;\n  }\n  static readNullTerminatedString(uint8Array, encoding) {\n    let offset = encoding.bom ? 2 : 0;\n    const zeroIndex = util.findZero(uint8Array, offset, uint8Array.length, encoding.encoding);\n    const txt = uint8Array.subarray(offset, zeroIndex);\n    if (encoding.encoding === 'utf-16le') {\n      offset = zeroIndex + 2;\n    } else {\n      offset = zeroIndex + 1;\n    }\n    return {\n      text: util.decodeString(txt, encoding.encoding),\n      len: offset\n    };\n  }\n  static fixPictureMimeType(pictureType) {\n    pictureType = pictureType.toLocaleLowerCase();\n    switch (pictureType) {\n      case 'jpg':\n        return 'image/jpeg';\n      case 'png':\n        return 'image/png';\n    }\n    return pictureType;\n  }\n  /**\r\n   * Converts TMCL (Musician credits list) or TIPL (Involved people list)\r\n   * @param entries\r\n   */\n  static functionList(entries) {\n    const res = {};\n    for (let i = 0; i + 1 < entries.length; i += 2) {\n      const names = entries[i + 1].split(',');\n      res[entries[i]] = res[entries[i]] ? res[entries[i]].concat(names) : names;\n    }\n    return res;\n  }\n  /**\r\n   * id3v2.4 defines that multiple T* values are separated by 0x00\r\n   * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\r\n   * @param tag - Tag name\r\n   * @param text - Concatenated tag value\r\n   * @returns Split tag value\r\n   */\n  splitValue(tag, text) {\n    let values;\n    if (this.major < 4) {\n      values = text.split(/\\x00/g);\n      if (values.length > 1) {\n        this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);\n      } else {\n        values = text.split(/\\//g);\n      }\n    } else {\n      values = text.split(/\\x00/g);\n    }\n    return FrameParser.trimArray(values);\n  }\n  static trimArray(values) {\n    return values.map(value => value.replace(/\\x00+$/, '').trim());\n  }\n  static readIdentifierAndData(uint8Array, offset, length, encoding) {\n    const fzero = util.findZero(uint8Array, offset, length, encoding);\n    const id = util.decodeString(uint8Array.subarray(offset, fzero), encoding);\n    offset = fzero + FrameParser.getNullTerminatorLength(encoding);\n    return {\n      id,\n      data: uint8Array.subarray(offset, length)\n    };\n  }\n  static getNullTerminatorLength(enc) {\n    return enc === 'utf-16le' ? 2 : 1;\n  }\n}\nexport class Id3v2ContentError extends makeUnexpectedFileContentError('id3v2') {}\nfunction makeUnexpectedMajorVersionError(majorVer) {\n  throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);\n}","map":{"version":3,"names":["initDebug","Token","util","AttachedPictureType","SyncTextHeader","TextEncodingToken","TextHeader","Genres","makeUnexpectedFileContentError","decodeUintBE","debug","defaultEnc","parseGenre","origVal","genres","code","word","c","undefined","push","genre","parseGenreCode","length","match","Number","parseInt","FrameParser","constructor","major","warningCollector","readData","uint8Array","type","includeCovers","addWarning","encoding","bom","get","offset","output","nullTerminatorLength","getNullTerminatorLength","fzero","text","decodeString","subarray","replace","error","Error","message","functionList","splitValue","map","v","reduce","acc","val","concat","Array","isArray","idAndData","readIdentifierAndData","textTag","description","id","data","pic","format","findZero","makeUnexpectedMajorVersionError","fixPictureMimeType","syltHeader","len","result","descriptor","language","contentType","timeStampFormat","syncText","readSyllables","nullStr","readNullTerminatedString","timestamp","UINT32_BE","textHeader","descriptorStr","textStr","comment","ufid","owner_identifier","identifier","priv","email","valueLen","rating","UINT8","counter","mimeType","filename","geob","url","zeroIndex","txt","pictureType","toLocaleLowerCase","entries","res","i","names","split","tag","values","trimArray","value","trim","enc","Id3v2ContentError","majorVer"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/id3v2/FrameParser.js"],"sourcesContent":["import initDebug from 'debug';\r\nimport * as Token from 'token-types';\r\nimport * as util from '../common/Util.js';\r\nimport { AttachedPictureType, SyncTextHeader, TextEncodingToken, TextHeader } from './ID3v2Token.js';\r\nimport { Genres } from '../id3v1/ID3v1Parser.js';\r\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\r\nimport { decodeUintBE } from '../common/Util.js';\r\nconst debug = initDebug('music-metadata:id3v2:frame-parser');\r\nconst defaultEnc = 'latin1'; // latin1 == iso-8859-1;\r\nexport function parseGenre(origVal) {\r\n    // match everything inside parentheses\r\n    const genres = [];\r\n    let code;\r\n    let word = '';\r\n    for (const c of origVal) {\r\n        if (typeof code === 'string') {\r\n            if (c === '(' && code === '') {\r\n                word += '(';\r\n                code = undefined;\r\n            }\r\n            else if (c === ')') {\r\n                if (word !== '') {\r\n                    genres.push(word);\r\n                    word = '';\r\n                }\r\n                const genre = parseGenreCode(code);\r\n                if (genre) {\r\n                    genres.push(genre);\r\n                }\r\n                code = undefined;\r\n            }\r\n            else\r\n                code += c;\r\n        }\r\n        else if (c === '(') {\r\n            code = '';\r\n        }\r\n        else {\r\n            word += c;\r\n        }\r\n    }\r\n    if (word) {\r\n        if (genres.length === 0 && word.match(/^\\d*$/)) {\r\n            word = parseGenreCode(word);\r\n        }\r\n        if (word) {\r\n            genres.push(word);\r\n        }\r\n    }\r\n    return genres;\r\n}\r\nfunction parseGenreCode(code) {\r\n    if (code === 'RX')\r\n        return 'Remix';\r\n    if (code === 'CR')\r\n        return 'Cover';\r\n    if (code.match(/^\\d*$/)) {\r\n        return Genres[Number.parseInt(code, 10)];\r\n    }\r\n}\r\nexport class FrameParser {\r\n    /**\r\n     * Create id3v2 frame parser\r\n     * @param major - Major version, e.g. (4) for  id3v2.4\r\n     * @param warningCollector - Used to collect decode issue\r\n     */\r\n    constructor(major, warningCollector) {\r\n        this.major = major;\r\n        this.warningCollector = warningCollector;\r\n    }\r\n    readData(uint8Array, type, includeCovers) {\r\n        if (uint8Array.length === 0) {\r\n            this.warningCollector.addWarning(`id3v2.${this.major} header has empty tag type=${type}`);\r\n            return;\r\n        }\r\n        const { encoding, bom } = TextEncodingToken.get(uint8Array, 0);\r\n        const length = uint8Array.length;\r\n        let offset = 0;\r\n        let output = []; // ToDo\r\n        const nullTerminatorLength = FrameParser.getNullTerminatorLength(encoding);\r\n        let fzero;\r\n        debug(`Parsing tag type=${type}, encoding=${encoding}, bom=${bom}`);\r\n        switch (type !== 'TXXX' && type[0] === 'T' ? 'T*' : type) {\r\n            case 'T*': // 4.2.1. Text information frames - details\r\n            case 'GRP1': // iTunes-specific ID3v2 grouping field\r\n            case 'IPLS': // v2.3: Involved people list\r\n            case 'MVIN':\r\n            case 'MVNM':\r\n            case 'PCS':\r\n            case 'PCST': {\r\n                let text;\r\n                try {\r\n                    text = util.decodeString(uint8Array.subarray(1), encoding).replace(/\\x00+$/, '');\r\n                }\r\n                catch (error) {\r\n                    if (error instanceof Error) {\r\n                        this.warningCollector.addWarning(`id3v2.${this.major} type=${type} header has invalid string value: ${error.message}`);\r\n                        break;\r\n                    }\r\n                    throw error;\r\n                }\r\n                switch (type) {\r\n                    case 'TMCL': // Musician credits list\r\n                    case 'TIPL': // Involved people list\r\n                    case 'IPLS': // Involved people list\r\n                        output = FrameParser.functionList(this.splitValue(type, text));\r\n                        break;\r\n                    case 'TRK':\r\n                    case 'TRCK':\r\n                    case 'TPOS':\r\n                        output = text;\r\n                        break;\r\n                    case 'TCOM':\r\n                    case 'TEXT':\r\n                    case 'TOLY':\r\n                    case 'TOPE':\r\n                    case 'TPE1':\r\n                    case 'TSRC':\r\n                        // id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\r\n                        output = this.splitValue(type, text);\r\n                        break;\r\n                    case 'TCO':\r\n                    case 'TCON':\r\n                        output = this.splitValue(type, text).map(v => parseGenre(v)).reduce((acc, val) => acc.concat(val), []);\r\n                        break;\r\n                    case 'PCS':\r\n                    case 'PCST':\r\n                        // TODO: Why `default` not results `1` but `''`?\r\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\r\n                        output = (Array.isArray(output) && output[0] === '') ? 1 : 0;\r\n                        break;\r\n                    default:\r\n                        output = this.major >= 4 ? this.splitValue(type, text) : [text];\r\n                }\r\n                break;\r\n            }\r\n            case 'TXXX': {\r\n                const idAndData = FrameParser.readIdentifierAndData(uint8Array, offset + 1, length, encoding);\r\n                const textTag = {\r\n                    description: idAndData.id,\r\n                    text: this.splitValue(type, util.decodeString(idAndData.data, encoding).replace(/\\x00+$/, ''))\r\n                };\r\n                output = textTag;\r\n                break;\r\n            }\r\n            case 'PIC':\r\n            case 'APIC':\r\n                if (includeCovers) {\r\n                    const pic = {};\r\n                    offset += 1;\r\n                    switch (this.major) {\r\n                        case 2:\r\n                            pic.format = util.decodeString(uint8Array.subarray(offset, offset + 3), 'latin1'); // 'latin1'; // latin1 == iso-8859-1;\r\n                            offset += 3;\r\n                            break;\r\n                        case 3:\r\n                        case 4:\r\n                            fzero = util.findZero(uint8Array, offset, length, defaultEnc);\r\n                            pic.format = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\r\n                            offset = fzero + 1;\r\n                            break;\r\n                        default:\r\n                            throw makeUnexpectedMajorVersionError(this.major);\r\n                    }\r\n                    pic.format = FrameParser.fixPictureMimeType(pic.format);\r\n                    pic.type = AttachedPictureType[uint8Array[offset]];\r\n                    offset += 1;\r\n                    fzero = util.findZero(uint8Array, offset, length, encoding);\r\n                    pic.description = util.decodeString(uint8Array.subarray(offset, fzero), encoding);\r\n                    offset = fzero + nullTerminatorLength;\r\n                    pic.data = uint8Array.subarray(offset, length);\r\n                    output = pic;\r\n                }\r\n                break;\r\n            case 'CNT':\r\n            case 'PCNT':\r\n                output = decodeUintBE(uint8Array);\r\n                break;\r\n            case 'SYLT': {\r\n                const syltHeader = SyncTextHeader.get(uint8Array, 0);\r\n                offset += SyncTextHeader.len;\r\n                const result = {\r\n                    descriptor: '',\r\n                    language: syltHeader.language,\r\n                    contentType: syltHeader.contentType,\r\n                    timeStampFormat: syltHeader.timeStampFormat,\r\n                    syncText: []\r\n                };\r\n                let readSyllables = false;\r\n                while (offset < length) {\r\n                    const nullStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), syltHeader.encoding);\r\n                    offset += nullStr.len;\r\n                    if (readSyllables) {\r\n                        const timestamp = Token.UINT32_BE.get(uint8Array, offset);\r\n                        offset += Token.UINT32_BE.len;\r\n                        result.syncText.push({\r\n                            text: nullStr.text,\r\n                            timestamp\r\n                        });\r\n                    }\r\n                    else {\r\n                        result.descriptor = nullStr.text;\r\n                        readSyllables = true;\r\n                    }\r\n                }\r\n                output = result;\r\n                break;\r\n            }\r\n            case 'ULT':\r\n            case 'USLT':\r\n            case 'COM':\r\n            case 'COMM': {\r\n                const textHeader = TextHeader.get(uint8Array, offset);\r\n                offset += TextHeader.len;\r\n                const descriptorStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);\r\n                offset += descriptorStr.len;\r\n                const textStr = FrameParser.readNullTerminatedString(uint8Array.subarray(offset), textHeader.encoding);\r\n                const comment = {\r\n                    language: textHeader.language,\r\n                    descriptor: descriptorStr.text,\r\n                    text: textStr.text\r\n                };\r\n                output = comment;\r\n                break;\r\n            }\r\n            case 'UFID': {\r\n                const ufid = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\r\n                output = { owner_identifier: ufid.id, identifier: ufid.data };\r\n                break;\r\n            }\r\n            case 'PRIV': { // private frame\r\n                const priv = FrameParser.readIdentifierAndData(uint8Array, offset, length, defaultEnc);\r\n                output = { owner_identifier: priv.id, data: priv.data };\r\n                break;\r\n            }\r\n            case 'POPM': { // Popularimeter\r\n                fzero = util.findZero(uint8Array, offset, length, defaultEnc);\r\n                const email = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\r\n                offset = fzero + 1;\r\n                const valueLen = length - offset - 1;\r\n                output = {\r\n                    email,\r\n                    rating: Token.UINT8.get(uint8Array, offset),\r\n                    counter: valueLen > 0 ? util.decodeUintBE(uint8Array.subarray(offset + 1)) : undefined\r\n                };\r\n                break;\r\n            }\r\n            case 'GEOB': { // General encapsulated object\r\n                fzero = util.findZero(uint8Array, offset + 1, length, encoding);\r\n                const mimeType = util.decodeString(uint8Array.subarray(offset + 1, fzero), defaultEnc);\r\n                offset = fzero + 1;\r\n                fzero = util.findZero(uint8Array, offset, length, encoding);\r\n                const filename = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\r\n                offset = fzero + 1;\r\n                fzero = util.findZero(uint8Array, offset, length, encoding);\r\n                const description = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\r\n                offset = fzero + 1;\r\n                const geob = {\r\n                    type: mimeType,\r\n                    filename,\r\n                    description,\r\n                    data: uint8Array.subarray(offset, length)\r\n                };\r\n                output = geob;\r\n                break;\r\n            }\r\n            // W-Frames:\r\n            case 'WCOM':\r\n            case 'WCOP':\r\n            case 'WOAF':\r\n            case 'WOAR':\r\n            case 'WOAS':\r\n            case 'WORS':\r\n            case 'WPAY':\r\n            case 'WPUB':\r\n                // Decode URL\r\n                fzero = util.findZero(uint8Array, offset + 1, length, encoding);\r\n                output = util.decodeString(uint8Array.subarray(offset, fzero), defaultEnc);\r\n                break;\r\n            case 'WXXX': {\r\n                // Decode URL\r\n                fzero = util.findZero(uint8Array, offset + 1, length, encoding);\r\n                const description = util.decodeString(uint8Array.subarray(offset + 1, fzero), encoding);\r\n                offset = fzero + (encoding === 'utf-16le' ? 2 : 1);\r\n                output = { description, url: util.decodeString(uint8Array.subarray(offset, length), defaultEnc) };\r\n                break;\r\n            }\r\n            case 'WFD':\r\n            case 'WFED':\r\n                output = util.decodeString(uint8Array.subarray(offset + 1, util.findZero(uint8Array, offset + 1, length, encoding)), encoding);\r\n                break;\r\n            case 'MCDI': {\r\n                // Music CD identifier\r\n                output = uint8Array.subarray(0, length);\r\n                break;\r\n            }\r\n            default:\r\n                debug(`Warning: unsupported id3v2-tag-type: ${type}`);\r\n                break;\r\n        }\r\n        return output;\r\n    }\r\n    static readNullTerminatedString(uint8Array, encoding) {\r\n        let offset = encoding.bom ? 2 : 0;\r\n        const zeroIndex = util.findZero(uint8Array, offset, uint8Array.length, encoding.encoding);\r\n        const txt = uint8Array.subarray(offset, zeroIndex);\r\n        if (encoding.encoding === 'utf-16le') {\r\n            offset = zeroIndex + 2;\r\n        }\r\n        else {\r\n            offset = zeroIndex + 1;\r\n        }\r\n        return {\r\n            text: util.decodeString(txt, encoding.encoding),\r\n            len: offset\r\n        };\r\n    }\r\n    static fixPictureMimeType(pictureType) {\r\n        pictureType = pictureType.toLocaleLowerCase();\r\n        switch (pictureType) {\r\n            case 'jpg':\r\n                return 'image/jpeg';\r\n            case 'png':\r\n                return 'image/png';\r\n        }\r\n        return pictureType;\r\n    }\r\n    /**\r\n     * Converts TMCL (Musician credits list) or TIPL (Involved people list)\r\n     * @param entries\r\n     */\r\n    static functionList(entries) {\r\n        const res = {};\r\n        for (let i = 0; i + 1 < entries.length; i += 2) {\r\n            const names = entries[i + 1].split(',');\r\n            res[entries[i]] = res[entries[i]] ? res[entries[i]].concat(names) : names;\r\n        }\r\n        return res;\r\n    }\r\n    /**\r\n     * id3v2.4 defines that multiple T* values are separated by 0x00\r\n     * id3v2.3 defines that TCOM, TEXT, TOLY, TOPE & TPE1 values are separated by /\r\n     * @param tag - Tag name\r\n     * @param text - Concatenated tag value\r\n     * @returns Split tag value\r\n     */\r\n    splitValue(tag, text) {\r\n        let values;\r\n        if (this.major < 4) {\r\n            values = text.split(/\\x00/g);\r\n            if (values.length > 1) {\r\n                this.warningCollector.addWarning(`ID3v2.${this.major} ${tag} uses non standard null-separator.`);\r\n            }\r\n            else {\r\n                values = text.split(/\\//g);\r\n            }\r\n        }\r\n        else {\r\n            values = text.split(/\\x00/g);\r\n        }\r\n        return FrameParser.trimArray(values);\r\n    }\r\n    static trimArray(values) {\r\n        return values.map(value => value.replace(/\\x00+$/, '').trim());\r\n    }\r\n    static readIdentifierAndData(uint8Array, offset, length, encoding) {\r\n        const fzero = util.findZero(uint8Array, offset, length, encoding);\r\n        const id = util.decodeString(uint8Array.subarray(offset, fzero), encoding);\r\n        offset = fzero + FrameParser.getNullTerminatorLength(encoding);\r\n        return { id, data: uint8Array.subarray(offset, length) };\r\n    }\r\n    static getNullTerminatorLength(enc) {\r\n        return enc === 'utf-16le' ? 2 : 1;\r\n    }\r\n}\r\nexport class Id3v2ContentError extends makeUnexpectedFileContentError('id3v2') {\r\n}\r\nfunction makeUnexpectedMajorVersionError(majorVer) {\r\n    throw new Id3v2ContentError(`Unexpected majorVer: ${majorVer}`);\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}