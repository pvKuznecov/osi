{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.set-from-hex.js\";\nimport \"core-js/modules/esnext.uint8-array.to-base64.js\";\nimport \"core-js/modules/esnext.uint8-array.to-hex.js\";\nimport initDebug from 'debug';\nimport * as strtok3 from 'strtok3';\nimport { StringType } from 'token-types';\nimport * as util from '../common/Util.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { DataType, DescriptorParser, Header, TagFooter, TagItemHeader } from './APEv2Token.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport { textDecode } from '@borewit/text-codec';\nconst debug = initDebug('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nexport class ApeContentError extends makeUnexpectedFileContentError('APEv2') {}\nexport function tryParseApeHeader(metadata, tokenizer, options) {\n  const apeParser = new APEv2Parser(metadata, tokenizer, options);\n  return apeParser.tryParseApeHeader();\n}\nexport class APEv2Parser extends BasicParser {\n  constructor() {\n    super(...arguments);\n    this.ape = {};\n  }\n  /**\n   * Calculate the media file duration\n   * @param ah ApeHeader\n   * @return {number} duration in seconds\n   */\n  static calculateDuration(ah) {\n    let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n    duration += ah.finalFrameBlocks;\n    return duration / ah.sampleRate;\n  }\n  /**\n   * Calculates the APEv1 / APEv2 first field offset\n   * @param tokenizer\n   * @param offset\n   */\n  static async findApeFooterOffset(tokenizer, offset) {\n    // Search for APE footer header at the end of the file\n    const apeBuf = new Uint8Array(TagFooter.len);\n    const position = tokenizer.position;\n    if (offset <= TagFooter.len) {\n      debug(`Offset is too small to read APE footer: offset=${offset}`);\n      return undefined;\n    }\n    if (offset > TagFooter.len) {\n      await tokenizer.readBuffer(apeBuf, {\n        position: offset - TagFooter.len\n      });\n      tokenizer.setPosition(position);\n      const tagFooter = TagFooter.get(apeBuf, 0);\n      if (tagFooter.ID === 'APETAGEX') {\n        if (tagFooter.flags.isHeader) {\n          debug(`APE Header found at offset=${offset - TagFooter.len}`);\n        } else {\n          debug(`APE Footer found at offset=${offset - TagFooter.len}`);\n          offset -= tagFooter.size;\n        }\n        return {\n          footer: tagFooter,\n          offset\n        };\n      }\n    }\n  }\n  static parseTagFooter(metadata, buffer, options) {\n    const footer = TagFooter.get(buffer, buffer.length - TagFooter.len);\n    if (footer.ID !== preamble) throw new ApeContentError('Unexpected APEv2 Footer ID preamble value');\n    strtok3.fromBuffer(buffer);\n    const apeParser = new APEv2Parser(metadata, strtok3.fromBuffer(buffer), options);\n    return apeParser.parseTags(footer);\n  }\n  /**\n   * Parse APEv1 / APEv2 header if header signature found\n   */\n  async tryParseApeHeader() {\n    if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {\n      debug(\"No APEv2 header found, end-of-file reached\");\n      return;\n    }\n    const footer = await this.tokenizer.peekToken(TagFooter);\n    if (footer.ID === preamble) {\n      await this.tokenizer.ignore(TagFooter.len);\n      return this.parseTags(footer);\n    }\n    debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n    if (this.tokenizer.fileInfo.size) {\n      // Try to read the APEv2 header using just the footer-header\n      const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n      const buffer = new Uint8Array(remaining);\n      await this.tokenizer.readBuffer(buffer);\n      return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n    }\n  }\n  async parse() {\n    const descriptor = await this.tokenizer.readToken(DescriptorParser);\n    if (descriptor.ID !== 'MAC ') throw new ApeContentError('Unexpected descriptor ID');\n    this.ape.descriptor = descriptor;\n    const lenExp = descriptor.descriptorBytes - DescriptorParser.len;\n    const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n    this.metadata.setAudioOnly();\n    await this.tokenizer.ignore(header.forwardBytes);\n    return this.tryParseApeHeader();\n  }\n  async parseTags(footer) {\n    const keyBuffer = new Uint8Array(256); // maximum tag key length\n    let bytesRemaining = footer.size - TagFooter.len;\n    debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n    for (let i = 0; i < footer.fields; i++) {\n      if (bytesRemaining < TagItemHeader.len) {\n        this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n        break;\n      }\n      // Only APEv2 tag has tag item headers\n      const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);\n      bytesRemaining -= TagItemHeader.len + tagItemHeader.size;\n      await this.tokenizer.peekBuffer(keyBuffer, {\n        length: Math.min(keyBuffer.length, bytesRemaining)\n      });\n      let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n      const key = await this.tokenizer.readToken(new StringType(zero, 'ascii'));\n      await this.tokenizer.ignore(1);\n      bytesRemaining -= key.length + 1;\n      switch (tagItemHeader.flags.dataType) {\n        case DataType.text_utf8:\n          {\n            // utf-8 text-string\n            const value = await this.tokenizer.readToken(new StringType(tagItemHeader.size, 'utf8'));\n            const values = value.split(/\\x00/g);\n            await Promise.all(values.map(val => this.metadata.addTag(tagFormat, key, val)));\n            break;\n          }\n        case DataType.binary:\n          // binary (probably artwork)\n          if (this.options.skipCovers) {\n            await this.tokenizer.ignore(tagItemHeader.size);\n          } else {\n            const picData = new Uint8Array(tagItemHeader.size);\n            await this.tokenizer.readBuffer(picData);\n            zero = util.findZero(picData, 0, picData.length);\n            const description = textDecode(picData.subarray(0, zero), 'utf-8');\n            const data = picData.subarray(zero + 1);\n            await this.metadata.addTag(tagFormat, key, {\n              description,\n              data\n            });\n          }\n          break;\n        case DataType.external_info:\n          debug(`Ignore external info ${key}`);\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n        case DataType.reserved:\n          debug(`Ignore external info ${key}`);\n          this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\n          await this.tokenizer.ignore(tagItemHeader.size);\n          break;\n      }\n    }\n  }\n  async parseDescriptorExpansion(lenExp) {\n    await this.tokenizer.ignore(lenExp);\n    return this.parseHeader();\n  }\n  async parseHeader() {\n    const header = await this.tokenizer.readToken(Header);\n    // ToDo before\n    this.metadata.setFormat('lossless', true);\n    this.metadata.setFormat('container', 'Monkey\\'s Audio');\n    this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n    this.metadata.setFormat('sampleRate', header.sampleRate);\n    this.metadata.setFormat('numberOfChannels', header.channel);\n    this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n    if (!this.ape.descriptor) {\n      throw new ApeContentError('Missing APE descriptor');\n    }\n    return {\n      forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes + this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n    };\n  }\n}","map":{"version":3,"names":["initDebug","strtok3","StringType","util","BasicParser","DataType","DescriptorParser","Header","TagFooter","TagItemHeader","makeUnexpectedFileContentError","textDecode","debug","tagFormat","preamble","ApeContentError","tryParseApeHeader","metadata","tokenizer","options","apeParser","APEv2Parser","constructor","arguments","ape","calculateDuration","ah","duration","totalFrames","blocksPerFrame","finalFrameBlocks","sampleRate","findApeFooterOffset","offset","apeBuf","Uint8Array","len","position","undefined","readBuffer","setPosition","tagFooter","get","ID","flags","isHeader","size","footer","parseTagFooter","buffer","length","fromBuffer","parseTags","fileInfo","peekToken","ignore","remaining","parse","descriptor","readToken","lenExp","descriptorBytes","header","parseDescriptorExpansion","parseHeader","setAudioOnly","forwardBytes","keyBuffer","bytesRemaining","i","fields","addWarning","tagItemHeader","peekBuffer","Math","min","zero","findZero","key","dataType","text_utf8","value","values","split","Promise","all","map","val","addTag","binary","skipCovers","picData","description","subarray","data","external_info","reserved","setFormat","bitsPerSample","channel","seekTableBytes","headerDataBytes","apeFrameDataBytes","terminatingDataBytes"],"sources":["/home/kup/my_projects/vue/osi/node_modules/music-metadata/lib/apev2/APEv2Parser.js"],"sourcesContent":["import initDebug from 'debug';\nimport * as strtok3 from 'strtok3';\nimport { StringType } from 'token-types';\nimport * as util from '../common/Util.js';\nimport { BasicParser } from '../common/BasicParser.js';\nimport { DataType, DescriptorParser, Header, TagFooter, TagItemHeader } from './APEv2Token.js';\nimport { makeUnexpectedFileContentError } from '../ParseError.js';\nimport { textDecode } from '@borewit/text-codec';\nconst debug = initDebug('music-metadata:parser:APEv2');\nconst tagFormat = 'APEv2';\nconst preamble = 'APETAGEX';\nexport class ApeContentError extends makeUnexpectedFileContentError('APEv2') {\n}\nexport function tryParseApeHeader(metadata, tokenizer, options) {\n    const apeParser = new APEv2Parser(metadata, tokenizer, options);\n    return apeParser.tryParseApeHeader();\n}\nexport class APEv2Parser extends BasicParser {\n    constructor() {\n        super(...arguments);\n        this.ape = {};\n    }\n    /**\n     * Calculate the media file duration\n     * @param ah ApeHeader\n     * @return {number} duration in seconds\n     */\n    static calculateDuration(ah) {\n        let duration = ah.totalFrames > 1 ? ah.blocksPerFrame * (ah.totalFrames - 1) : 0;\n        duration += ah.finalFrameBlocks;\n        return duration / ah.sampleRate;\n    }\n    /**\n     * Calculates the APEv1 / APEv2 first field offset\n     * @param tokenizer\n     * @param offset\n     */\n    static async findApeFooterOffset(tokenizer, offset) {\n        // Search for APE footer header at the end of the file\n        const apeBuf = new Uint8Array(TagFooter.len);\n        const position = tokenizer.position;\n        if (offset <= TagFooter.len) {\n            debug(`Offset is too small to read APE footer: offset=${offset}`);\n            return undefined;\n        }\n        if (offset > TagFooter.len) {\n            await tokenizer.readBuffer(apeBuf, { position: offset - TagFooter.len });\n            tokenizer.setPosition(position);\n            const tagFooter = TagFooter.get(apeBuf, 0);\n            if (tagFooter.ID === 'APETAGEX') {\n                if (tagFooter.flags.isHeader) {\n                    debug(`APE Header found at offset=${offset - TagFooter.len}`);\n                }\n                else {\n                    debug(`APE Footer found at offset=${offset - TagFooter.len}`);\n                    offset -= tagFooter.size;\n                }\n                return { footer: tagFooter, offset };\n            }\n        }\n    }\n    static parseTagFooter(metadata, buffer, options) {\n        const footer = TagFooter.get(buffer, buffer.length - TagFooter.len);\n        if (footer.ID !== preamble)\n            throw new ApeContentError('Unexpected APEv2 Footer ID preamble value');\n        strtok3.fromBuffer(buffer);\n        const apeParser = new APEv2Parser(metadata, strtok3.fromBuffer(buffer), options);\n        return apeParser.parseTags(footer);\n    }\n    /**\n     * Parse APEv1 / APEv2 header if header signature found\n     */\n    async tryParseApeHeader() {\n        if (this.tokenizer.fileInfo.size && this.tokenizer.fileInfo.size - this.tokenizer.position < TagFooter.len) {\n            debug(\"No APEv2 header found, end-of-file reached\");\n            return;\n        }\n        const footer = await this.tokenizer.peekToken(TagFooter);\n        if (footer.ID === preamble) {\n            await this.tokenizer.ignore(TagFooter.len);\n            return this.parseTags(footer);\n        }\n        debug(`APEv2 header not found at offset=${this.tokenizer.position}`);\n        if (this.tokenizer.fileInfo.size) {\n            // Try to read the APEv2 header using just the footer-header\n            const remaining = this.tokenizer.fileInfo.size - this.tokenizer.position; // ToDo: take ID3v1 into account\n            const buffer = new Uint8Array(remaining);\n            await this.tokenizer.readBuffer(buffer);\n            return APEv2Parser.parseTagFooter(this.metadata, buffer, this.options);\n        }\n    }\n    async parse() {\n        const descriptor = await this.tokenizer.readToken(DescriptorParser);\n        if (descriptor.ID !== 'MAC ')\n            throw new ApeContentError('Unexpected descriptor ID');\n        this.ape.descriptor = descriptor;\n        const lenExp = descriptor.descriptorBytes - DescriptorParser.len;\n        const header = await (lenExp > 0 ? this.parseDescriptorExpansion(lenExp) : this.parseHeader());\n        this.metadata.setAudioOnly();\n        await this.tokenizer.ignore(header.forwardBytes);\n        return this.tryParseApeHeader();\n    }\n    async parseTags(footer) {\n        const keyBuffer = new Uint8Array(256); // maximum tag key length\n        let bytesRemaining = footer.size - TagFooter.len;\n        debug(`Parse APE tags at offset=${this.tokenizer.position}, size=${bytesRemaining}`);\n        for (let i = 0; i < footer.fields; i++) {\n            if (bytesRemaining < TagItemHeader.len) {\n                this.metadata.addWarning(`APEv2 Tag-header: ${footer.fields - i} items remaining, but no more tag data to read.`);\n                break;\n            }\n            // Only APEv2 tag has tag item headers\n            const tagItemHeader = await this.tokenizer.readToken(TagItemHeader);\n            bytesRemaining -= TagItemHeader.len + tagItemHeader.size;\n            await this.tokenizer.peekBuffer(keyBuffer, { length: Math.min(keyBuffer.length, bytesRemaining) });\n            let zero = util.findZero(keyBuffer, 0, keyBuffer.length);\n            const key = await this.tokenizer.readToken(new StringType(zero, 'ascii'));\n            await this.tokenizer.ignore(1);\n            bytesRemaining -= key.length + 1;\n            switch (tagItemHeader.flags.dataType) {\n                case DataType.text_utf8: { // utf-8 text-string\n                    const value = await this.tokenizer.readToken(new StringType(tagItemHeader.size, 'utf8'));\n                    const values = value.split(/\\x00/g);\n                    await Promise.all(values.map(val => this.metadata.addTag(tagFormat, key, val)));\n                    break;\n                }\n                case DataType.binary: // binary (probably artwork)\n                    if (this.options.skipCovers) {\n                        await this.tokenizer.ignore(tagItemHeader.size);\n                    }\n                    else {\n                        const picData = new Uint8Array(tagItemHeader.size);\n                        await this.tokenizer.readBuffer(picData);\n                        zero = util.findZero(picData, 0, picData.length);\n                        const description = textDecode(picData.subarray(0, zero), 'utf-8');\n                        const data = picData.subarray(zero + 1);\n                        await this.metadata.addTag(tagFormat, key, {\n                            description,\n                            data\n                        });\n                    }\n                    break;\n                case DataType.external_info:\n                    debug(`Ignore external info ${key}`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n                case DataType.reserved:\n                    debug(`Ignore external info ${key}`);\n                    this.metadata.addWarning(`APEv2 header declares a reserved datatype for \"${key}\"`);\n                    await this.tokenizer.ignore(tagItemHeader.size);\n                    break;\n            }\n        }\n    }\n    async parseDescriptorExpansion(lenExp) {\n        await this.tokenizer.ignore(lenExp);\n        return this.parseHeader();\n    }\n    async parseHeader() {\n        const header = await this.tokenizer.readToken(Header);\n        // ToDo before\n        this.metadata.setFormat('lossless', true);\n        this.metadata.setFormat('container', 'Monkey\\'s Audio');\n        this.metadata.setFormat('bitsPerSample', header.bitsPerSample);\n        this.metadata.setFormat('sampleRate', header.sampleRate);\n        this.metadata.setFormat('numberOfChannels', header.channel);\n        this.metadata.setFormat('duration', APEv2Parser.calculateDuration(header));\n        if (!this.ape.descriptor) {\n            throw new ApeContentError('Missing APE descriptor');\n        }\n        return {\n            forwardBytes: this.ape.descriptor.seekTableBytes + this.ape.descriptor.headerDataBytes +\n                this.ape.descriptor.apeFrameDataBytes + this.ape.descriptor.terminatingDataBytes\n        };\n    }\n}\n"],"mappings":";;;;;;;;;;AAAA,OAAOA,SAAS,MAAM,OAAO;AAC7B,OAAO,KAAKC,OAAO,MAAM,SAAS;AAClC,SAASC,UAAU,QAAQ,aAAa;AACxC,OAAO,KAAKC,IAAI,MAAM,mBAAmB;AACzC,SAASC,WAAW,QAAQ,0BAA0B;AACtD,SAASC,QAAQ,EAAEC,gBAAgB,EAAEC,MAAM,EAAEC,SAAS,EAAEC,aAAa,QAAQ,iBAAiB;AAC9F,SAASC,8BAA8B,QAAQ,kBAAkB;AACjE,SAASC,UAAU,QAAQ,qBAAqB;AAChD,MAAMC,KAAK,GAAGZ,SAAS,CAAC,6BAA6B,CAAC;AACtD,MAAMa,SAAS,GAAG,OAAO;AACzB,MAAMC,QAAQ,GAAG,UAAU;AAC3B,OAAO,MAAMC,eAAe,SAASL,8BAA8B,CAAC,OAAO,CAAC,CAAC;AAE7E,OAAO,SAASM,iBAAiBA,CAACC,QAAQ,EAAEC,SAAS,EAAEC,OAAO,EAAE;EAC5D,MAAMC,SAAS,GAAG,IAAIC,WAAW,CAACJ,QAAQ,EAAEC,SAAS,EAAEC,OAAO,CAAC;EAC/D,OAAOC,SAAS,CAACJ,iBAAiB,CAAC,CAAC;AACxC;AACA,OAAO,MAAMK,WAAW,SAASjB,WAAW,CAAC;EACzCkB,WAAWA,CAAA,EAAG;IACV,KAAK,CAAC,GAAGC,SAAS,CAAC;IACnB,IAAI,CAACC,GAAG,GAAG,CAAC,CAAC;EACjB;EACA;AACJ;AACA;AACA;AACA;EACI,OAAOC,iBAAiBA,CAACC,EAAE,EAAE;IACzB,IAAIC,QAAQ,GAAGD,EAAE,CAACE,WAAW,GAAG,CAAC,GAAGF,EAAE,CAACG,cAAc,IAAIH,EAAE,CAACE,WAAW,GAAG,CAAC,CAAC,GAAG,CAAC;IAChFD,QAAQ,IAAID,EAAE,CAACI,gBAAgB;IAC/B,OAAOH,QAAQ,GAAGD,EAAE,CAACK,UAAU;EACnC;EACA;AACJ;AACA;AACA;AACA;EACI,aAAaC,mBAAmBA,CAACd,SAAS,EAAEe,MAAM,EAAE;IAChD;IACA,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC3B,SAAS,CAAC4B,GAAG,CAAC;IAC5C,MAAMC,QAAQ,GAAGnB,SAAS,CAACmB,QAAQ;IACnC,IAAIJ,MAAM,IAAIzB,SAAS,CAAC4B,GAAG,EAAE;MACzBxB,KAAK,CAAC,kDAAkDqB,MAAM,EAAE,CAAC;MACjE,OAAOK,SAAS;IACpB;IACA,IAAIL,MAAM,GAAGzB,SAAS,CAAC4B,GAAG,EAAE;MACxB,MAAMlB,SAAS,CAACqB,UAAU,CAACL,MAAM,EAAE;QAAEG,QAAQ,EAAEJ,MAAM,GAAGzB,SAAS,CAAC4B;MAAI,CAAC,CAAC;MACxElB,SAAS,CAACsB,WAAW,CAACH,QAAQ,CAAC;MAC/B,MAAMI,SAAS,GAAGjC,SAAS,CAACkC,GAAG,CAACR,MAAM,EAAE,CAAC,CAAC;MAC1C,IAAIO,SAAS,CAACE,EAAE,KAAK,UAAU,EAAE;QAC7B,IAAIF,SAAS,CAACG,KAAK,CAACC,QAAQ,EAAE;UAC1BjC,KAAK,CAAC,8BAA8BqB,MAAM,GAAGzB,SAAS,CAAC4B,GAAG,EAAE,CAAC;QACjE,CAAC,MACI;UACDxB,KAAK,CAAC,8BAA8BqB,MAAM,GAAGzB,SAAS,CAAC4B,GAAG,EAAE,CAAC;UAC7DH,MAAM,IAAIQ,SAAS,CAACK,IAAI;QAC5B;QACA,OAAO;UAAEC,MAAM,EAAEN,SAAS;UAAER;QAAO,CAAC;MACxC;IACJ;EACJ;EACA,OAAOe,cAAcA,CAAC/B,QAAQ,EAAEgC,MAAM,EAAE9B,OAAO,EAAE;IAC7C,MAAM4B,MAAM,GAAGvC,SAAS,CAACkC,GAAG,CAACO,MAAM,EAAEA,MAAM,CAACC,MAAM,GAAG1C,SAAS,CAAC4B,GAAG,CAAC;IACnE,IAAIW,MAAM,CAACJ,EAAE,KAAK7B,QAAQ,EACtB,MAAM,IAAIC,eAAe,CAAC,2CAA2C,CAAC;IAC1Ed,OAAO,CAACkD,UAAU,CAACF,MAAM,CAAC;IAC1B,MAAM7B,SAAS,GAAG,IAAIC,WAAW,CAACJ,QAAQ,EAAEhB,OAAO,CAACkD,UAAU,CAACF,MAAM,CAAC,EAAE9B,OAAO,CAAC;IAChF,OAAOC,SAAS,CAACgC,SAAS,CAACL,MAAM,CAAC;EACtC;EACA;AACJ;AACA;EACI,MAAM/B,iBAAiBA,CAAA,EAAG;IACtB,IAAI,IAAI,CAACE,SAAS,CAACmC,QAAQ,CAACP,IAAI,IAAI,IAAI,CAAC5B,SAAS,CAACmC,QAAQ,CAACP,IAAI,GAAG,IAAI,CAAC5B,SAAS,CAACmB,QAAQ,GAAG7B,SAAS,CAAC4B,GAAG,EAAE;MACxGxB,KAAK,CAAC,4CAA4C,CAAC;MACnD;IACJ;IACA,MAAMmC,MAAM,GAAG,MAAM,IAAI,CAAC7B,SAAS,CAACoC,SAAS,CAAC9C,SAAS,CAAC;IACxD,IAAIuC,MAAM,CAACJ,EAAE,KAAK7B,QAAQ,EAAE;MACxB,MAAM,IAAI,CAACI,SAAS,CAACqC,MAAM,CAAC/C,SAAS,CAAC4B,GAAG,CAAC;MAC1C,OAAO,IAAI,CAACgB,SAAS,CAACL,MAAM,CAAC;IACjC;IACAnC,KAAK,CAAC,oCAAoC,IAAI,CAACM,SAAS,CAACmB,QAAQ,EAAE,CAAC;IACpE,IAAI,IAAI,CAACnB,SAAS,CAACmC,QAAQ,CAACP,IAAI,EAAE;MAC9B;MACA,MAAMU,SAAS,GAAG,IAAI,CAACtC,SAAS,CAACmC,QAAQ,CAACP,IAAI,GAAG,IAAI,CAAC5B,SAAS,CAACmB,QAAQ,CAAC,CAAC;MAC1E,MAAMY,MAAM,GAAG,IAAId,UAAU,CAACqB,SAAS,CAAC;MACxC,MAAM,IAAI,CAACtC,SAAS,CAACqB,UAAU,CAACU,MAAM,CAAC;MACvC,OAAO5B,WAAW,CAAC2B,cAAc,CAAC,IAAI,CAAC/B,QAAQ,EAAEgC,MAAM,EAAE,IAAI,CAAC9B,OAAO,CAAC;IAC1E;EACJ;EACA,MAAMsC,KAAKA,CAAA,EAAG;IACV,MAAMC,UAAU,GAAG,MAAM,IAAI,CAACxC,SAAS,CAACyC,SAAS,CAACrD,gBAAgB,CAAC;IACnE,IAAIoD,UAAU,CAACf,EAAE,KAAK,MAAM,EACxB,MAAM,IAAI5B,eAAe,CAAC,0BAA0B,CAAC;IACzD,IAAI,CAACS,GAAG,CAACkC,UAAU,GAAGA,UAAU;IAChC,MAAME,MAAM,GAAGF,UAAU,CAACG,eAAe,GAAGvD,gBAAgB,CAAC8B,GAAG;IAChE,MAAM0B,MAAM,GAAG,OAAOF,MAAM,GAAG,CAAC,GAAG,IAAI,CAACG,wBAAwB,CAACH,MAAM,CAAC,GAAG,IAAI,CAACI,WAAW,CAAC,CAAC,CAAC;IAC9F,IAAI,CAAC/C,QAAQ,CAACgD,YAAY,CAAC,CAAC;IAC5B,MAAM,IAAI,CAAC/C,SAAS,CAACqC,MAAM,CAACO,MAAM,CAACI,YAAY,CAAC;IAChD,OAAO,IAAI,CAAClD,iBAAiB,CAAC,CAAC;EACnC;EACA,MAAMoC,SAASA,CAACL,MAAM,EAAE;IACpB,MAAMoB,SAAS,GAAG,IAAIhC,UAAU,CAAC,GAAG,CAAC,CAAC,CAAC;IACvC,IAAIiC,cAAc,GAAGrB,MAAM,CAACD,IAAI,GAAGtC,SAAS,CAAC4B,GAAG;IAChDxB,KAAK,CAAC,4BAA4B,IAAI,CAACM,SAAS,CAACmB,QAAQ,UAAU+B,cAAc,EAAE,CAAC;IACpF,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGtB,MAAM,CAACuB,MAAM,EAAED,CAAC,EAAE,EAAE;MACpC,IAAID,cAAc,GAAG3D,aAAa,CAAC2B,GAAG,EAAE;QACpC,IAAI,CAACnB,QAAQ,CAACsD,UAAU,CAAC,qBAAqBxB,MAAM,CAACuB,MAAM,GAAGD,CAAC,iDAAiD,CAAC;QACjH;MACJ;MACA;MACA,MAAMG,aAAa,GAAG,MAAM,IAAI,CAACtD,SAAS,CAACyC,SAAS,CAAClD,aAAa,CAAC;MACnE2D,cAAc,IAAI3D,aAAa,CAAC2B,GAAG,GAAGoC,aAAa,CAAC1B,IAAI;MACxD,MAAM,IAAI,CAAC5B,SAAS,CAACuD,UAAU,CAACN,SAAS,EAAE;QAAEjB,MAAM,EAAEwB,IAAI,CAACC,GAAG,CAACR,SAAS,CAACjB,MAAM,EAAEkB,cAAc;MAAE,CAAC,CAAC;MAClG,IAAIQ,IAAI,GAAGzE,IAAI,CAAC0E,QAAQ,CAACV,SAAS,EAAE,CAAC,EAAEA,SAAS,CAACjB,MAAM,CAAC;MACxD,MAAM4B,GAAG,GAAG,MAAM,IAAI,CAAC5D,SAAS,CAACyC,SAAS,CAAC,IAAIzD,UAAU,CAAC0E,IAAI,EAAE,OAAO,CAAC,CAAC;MACzE,MAAM,IAAI,CAAC1D,SAAS,CAACqC,MAAM,CAAC,CAAC,CAAC;MAC9Ba,cAAc,IAAIU,GAAG,CAAC5B,MAAM,GAAG,CAAC;MAChC,QAAQsB,aAAa,CAAC5B,KAAK,CAACmC,QAAQ;QAChC,KAAK1E,QAAQ,CAAC2E,SAAS;UAAE;YAAE;YACvB,MAAMC,KAAK,GAAG,MAAM,IAAI,CAAC/D,SAAS,CAACyC,SAAS,CAAC,IAAIzD,UAAU,CAACsE,aAAa,CAAC1B,IAAI,EAAE,MAAM,CAAC,CAAC;YACxF,MAAMoC,MAAM,GAAGD,KAAK,CAACE,KAAK,CAAC,OAAO,CAAC;YACnC,MAAMC,OAAO,CAACC,GAAG,CAACH,MAAM,CAACI,GAAG,CAACC,GAAG,IAAI,IAAI,CAACtE,QAAQ,CAACuE,MAAM,CAAC3E,SAAS,EAAEiE,GAAG,EAAES,GAAG,CAAC,CAAC,CAAC;YAC/E;UACJ;QACA,KAAKlF,QAAQ,CAACoF,MAAM;UAAE;UAClB,IAAI,IAAI,CAACtE,OAAO,CAACuE,UAAU,EAAE;YACzB,MAAM,IAAI,CAACxE,SAAS,CAACqC,MAAM,CAACiB,aAAa,CAAC1B,IAAI,CAAC;UACnD,CAAC,MACI;YACD,MAAM6C,OAAO,GAAG,IAAIxD,UAAU,CAACqC,aAAa,CAAC1B,IAAI,CAAC;YAClD,MAAM,IAAI,CAAC5B,SAAS,CAACqB,UAAU,CAACoD,OAAO,CAAC;YACxCf,IAAI,GAAGzE,IAAI,CAAC0E,QAAQ,CAACc,OAAO,EAAE,CAAC,EAAEA,OAAO,CAACzC,MAAM,CAAC;YAChD,MAAM0C,WAAW,GAAGjF,UAAU,CAACgF,OAAO,CAACE,QAAQ,CAAC,CAAC,EAAEjB,IAAI,CAAC,EAAE,OAAO,CAAC;YAClE,MAAMkB,IAAI,GAAGH,OAAO,CAACE,QAAQ,CAACjB,IAAI,GAAG,CAAC,CAAC;YACvC,MAAM,IAAI,CAAC3D,QAAQ,CAACuE,MAAM,CAAC3E,SAAS,EAAEiE,GAAG,EAAE;cACvCc,WAAW;cACXE;YACJ,CAAC,CAAC;UACN;UACA;QACJ,KAAKzF,QAAQ,CAAC0F,aAAa;UACvBnF,KAAK,CAAC,wBAAwBkE,GAAG,EAAE,CAAC;UACpC,MAAM,IAAI,CAAC5D,SAAS,CAACqC,MAAM,CAACiB,aAAa,CAAC1B,IAAI,CAAC;UAC/C;QACJ,KAAKzC,QAAQ,CAAC2F,QAAQ;UAClBpF,KAAK,CAAC,wBAAwBkE,GAAG,EAAE,CAAC;UACpC,IAAI,CAAC7D,QAAQ,CAACsD,UAAU,CAAC,kDAAkDO,GAAG,GAAG,CAAC;UAClF,MAAM,IAAI,CAAC5D,SAAS,CAACqC,MAAM,CAACiB,aAAa,CAAC1B,IAAI,CAAC;UAC/C;MACR;IACJ;EACJ;EACA,MAAMiB,wBAAwBA,CAACH,MAAM,EAAE;IACnC,MAAM,IAAI,CAAC1C,SAAS,CAACqC,MAAM,CAACK,MAAM,CAAC;IACnC,OAAO,IAAI,CAACI,WAAW,CAAC,CAAC;EAC7B;EACA,MAAMA,WAAWA,CAAA,EAAG;IAChB,MAAMF,MAAM,GAAG,MAAM,IAAI,CAAC5C,SAAS,CAACyC,SAAS,CAACpD,MAAM,CAAC;IACrD;IACA,IAAI,CAACU,QAAQ,CAACgF,SAAS,CAAC,UAAU,EAAE,IAAI,CAAC;IACzC,IAAI,CAAChF,QAAQ,CAACgF,SAAS,CAAC,WAAW,EAAE,iBAAiB,CAAC;IACvD,IAAI,CAAChF,QAAQ,CAACgF,SAAS,CAAC,eAAe,EAAEnC,MAAM,CAACoC,aAAa,CAAC;IAC9D,IAAI,CAACjF,QAAQ,CAACgF,SAAS,CAAC,YAAY,EAAEnC,MAAM,CAAC/B,UAAU,CAAC;IACxD,IAAI,CAACd,QAAQ,CAACgF,SAAS,CAAC,kBAAkB,EAAEnC,MAAM,CAACqC,OAAO,CAAC;IAC3D,IAAI,CAAClF,QAAQ,CAACgF,SAAS,CAAC,UAAU,EAAE5E,WAAW,CAACI,iBAAiB,CAACqC,MAAM,CAAC,CAAC;IAC1E,IAAI,CAAC,IAAI,CAACtC,GAAG,CAACkC,UAAU,EAAE;MACtB,MAAM,IAAI3C,eAAe,CAAC,wBAAwB,CAAC;IACvD;IACA,OAAO;MACHmD,YAAY,EAAE,IAAI,CAAC1C,GAAG,CAACkC,UAAU,CAAC0C,cAAc,GAAG,IAAI,CAAC5E,GAAG,CAACkC,UAAU,CAAC2C,eAAe,GAClF,IAAI,CAAC7E,GAAG,CAACkC,UAAU,CAAC4C,iBAAiB,GAAG,IAAI,CAAC9E,GAAG,CAACkC,UAAU,CAAC6C;IACpE,CAAC;EACL;AACJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}