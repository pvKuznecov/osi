{"ast":null,"code":"import { LangPack } from './lang';\nimport { parseBlob } from 'music-metadata';\nexport default {\n  name: 'OSIMPlayer',\n  props: {\n    windowId: {\n      type: String,\n      required: true\n    }\n  },\n  data() {\n    return {\n      LangData: {},\n      PlayLists: [],\n      isPlaying: false,\n      durationAll: 0,\n      TargetTrack: null,\n      ShowConfig: {\n        playlist: {\n          artist: true,\n          album: true,\n          genre: true,\n          duration: true\n        }\n      },\n      isLoading: false,\n      totalFiles: 0,\n      processedCount: 0,\n      MAX_FILE_SIZE: 100 * 1024 * 1024,\n      // 100MB,\n      MAX_PLAYLIST_SIZE: 1000 * 1024 * 1024,\n      // 1000MB,\n      curFilesSize: 0\n    };\n  },\n  mounted() {\n    console.log('MPlayer app mounted with windowId:', this.windowId);\n    const userLang = navigator.language || navigator.userLanguage;\n    const userLangS = userLang.split('-')[0];\n    this.UserLang = userLangS;\n    const LangPackData = LangPack;\n    this.LangData = userLangS && LangPackData && LangPackData[userLangS] ? LangPackData[userLangS] : LangPackData.en;\n  },\n  methods: {\n    // async handleFileSelect(event) {\n    //     const files = Array.from(event.target.files);\n    //     const audioFiles = files.filter(file => this.isAudio(file));\n\n    //     if (audioFiles.length === 0) {\n    //         this.showError(\"Не было выбрано ни одного аудиофайла.\");\n    //         this.resetInput(event.target);\n    //         return;\n    //     }\n\n    //     let cSize = 0;\n    //     files.forEach(function(item) { cSize += item.size; })\n\n    //     if (cSize > this.MAX_PLAYLIST_SIZE) {\n    //         this.showError(\"Превышен лимит доступной памяти! Максимальный размер - \" + (this.MAX_PLAYLIST_SIZE / 1024 / 1024) + \"MB.\");\n    //         this.resetInput(event.target);\n    //         return;\n    //     }\n\n    //     this.isLoading = true;\n    //     this.totalFiles = audioFiles.length;\n    //     this.processedCount = 0;\n\n    //     let validFiles = [];\n\n    //     for (let afile of audioFiles) {\n    //         try {\n    //             const blob = afile.slice(0, afile.size);\n    //             let parsedData = await parseBlob(blob);\n\n    //             afile.common = parsedData.common;\n    //             validFiles.push(afile); // Добавляем подходящий файл в массив\n    //         } catch (error) {\n    //             console.error('Ошибка при разборе файла:', error);\n    //         }\n    //         this.processedCount++;\n    //     }\n\n    //     this.isLoading = false;\n\n    //     if (validFiles.length > 0) {\n    //         this.$emit('files-selected', validFiles);\n    //         this.PlayList = true;\n    //     } else {\n    //         alert(\"Не было выбрано ни одного аудиофайла.\");\n    //     }\n    // },\n    // isAudio(file) {\n    //     if (file.size > this.MAX_FILE_SIZE) {\n    //         console.warn(`Файл ${file.name} слишком большой: ${file.size} bytes`);\n    //         return false;\n    //     }\n\n    //     // Более надежная проверка аудиофайлов\n    //     const audioTypes = [ 'audio/mpeg', 'audio/wav', 'audio/flac', 'audio/ogg', 'audio/aac', 'audio/x-m4a' ];\n    //     const extension = file.name.toLowerCase().split('.').pop();\n    //     const audioExtensions = ['mp3', 'wav', 'flac', 'ogg', 'aac', 'm4a'];\n\n    //     return audioTypes.includes(file.type) || audioExtensions.includes(extension);\n    // },\n    // showError(message) {\n    //     alert(message);\n    //     console.error(message);\n    // },\n    // // Сброс input (открывает возможность повторно загружать те-же файлы)\n    // resetInput(inputElement) {\n    //     inputElement.value = '';\n    // }\n  }\n};","map":{"version":3,"names":["LangPack","parseBlob","name","props","windowId","type","String","required","data","LangData","PlayLists","isPlaying","durationAll","TargetTrack","ShowConfig","playlist","artist","album","genre","duration","isLoading","totalFiles","processedCount","MAX_FILE_SIZE","MAX_PLAYLIST_SIZE","curFilesSize","mounted","console","log","userLang","navigator","language","userLanguage","userLangS","split","UserLang","LangPackData","en","methods"],"sources":["/home/kup/my_projects/vue/osi/src/apps/system/OSIMPlayer/OSIMPlayer.vue"],"sourcesContent":["<template src=\"./template.html\"></template>\n<style src=\"./style.css\"></style>\n<script>\n    import { LangPack } from './lang';\n    import { parseBlob } from 'music-metadata';\n\n    export default {\n        name: 'OSIMPlayer',\n\n        props: {\n            windowId: {\n                type: String,\n                required: true\n            },\n        },\n\n        data() {\n            return {\n                LangData: {},\n                PlayLists: [],\n                isPlaying: false,\n                durationAll: 0,\n                TargetTrack: null,\n                ShowConfig: {\n                    playlist: {\n                        artist: true,\n                        album: true,\n                        genre: true,\n                        duration: true,\n                    }\n                },\n                isLoading: false,\n                totalFiles: 0,\n                processedCount: 0,\n                MAX_FILE_SIZE: 100 * 1024 * 1024, // 100MB,\n                MAX_PLAYLIST_SIZE: 1000 * 1024 * 1024, // 1000MB,\n                curFilesSize: 0,\n            }\n        },\n\n        mounted() {\n            console.log('MPlayer app mounted with windowId:', this.windowId);\n\n            const userLang = navigator.language || navigator.userLanguage;\n            const userLangS = userLang.split('-')[0];\n            this.UserLang = userLangS; \n            \n            const LangPackData = LangPack;\n            this.LangData = (userLangS && LangPackData && LangPackData[userLangS]) ? LangPackData[userLangS] : LangPackData.en;\n        },\n\n        methods: {\n            // async handleFileSelect(event) {\n            //     const files = Array.from(event.target.files);\n            //     const audioFiles = files.filter(file => this.isAudio(file));\n\n            //     if (audioFiles.length === 0) {\n            //         this.showError(\"Не было выбрано ни одного аудиофайла.\");\n            //         this.resetInput(event.target);\n            //         return;\n            //     }\n\n            //     let cSize = 0;\n            //     files.forEach(function(item) { cSize += item.size; })\n\n            //     if (cSize > this.MAX_PLAYLIST_SIZE) {\n            //         this.showError(\"Превышен лимит доступной памяти! Максимальный размер - \" + (this.MAX_PLAYLIST_SIZE / 1024 / 1024) + \"MB.\");\n            //         this.resetInput(event.target);\n            //         return;\n            //     }\n\n            //     this.isLoading = true;\n            //     this.totalFiles = audioFiles.length;\n            //     this.processedCount = 0;\n\n            //     let validFiles = [];\n\n            //     for (let afile of audioFiles) {\n            //         try {\n            //             const blob = afile.slice(0, afile.size);\n            //             let parsedData = await parseBlob(blob);\n\n            //             afile.common = parsedData.common;\n            //             validFiles.push(afile); // Добавляем подходящий файл в массив\n            //         } catch (error) {\n            //             console.error('Ошибка при разборе файла:', error);\n            //         }\n            //         this.processedCount++;\n            //     }\n\n            //     this.isLoading = false;\n\n            //     if (validFiles.length > 0) {\n            //         this.$emit('files-selected', validFiles);\n            //         this.PlayList = true;\n            //     } else {\n            //         alert(\"Не было выбрано ни одного аудиофайла.\");\n            //     }\n            // },\n            // isAudio(file) {\n            //     if (file.size > this.MAX_FILE_SIZE) {\n            //         console.warn(`Файл ${file.name} слишком большой: ${file.size} bytes`);\n            //         return false;\n            //     }\n\n            //     // Более надежная проверка аудиофайлов\n            //     const audioTypes = [ 'audio/mpeg', 'audio/wav', 'audio/flac', 'audio/ogg', 'audio/aac', 'audio/x-m4a' ];\n            //     const extension = file.name.toLowerCase().split('.').pop();\n            //     const audioExtensions = ['mp3', 'wav', 'flac', 'ogg', 'aac', 'm4a'];\n            \n            //     return audioTypes.includes(file.type) || audioExtensions.includes(extension);\n            // },\n            // showError(message) {\n            //     alert(message);\n            //     console.error(message);\n            // },\n            // // Сброс input (открывает возможность повторно загружать те-же файлы)\n            // resetInput(inputElement) {\n            //     inputElement.value = '';\n            // }\n        }\n    }\n</script>"],"mappings":"AAGI,SAASA,QAAO,QAAS,QAAQ;AACjC,SAASC,SAAQ,QAAS,gBAAgB;AAE1C,eAAe;EACXC,IAAI,EAAE,YAAY;EAElBC,KAAK,EAAE;IACHC,QAAQ,EAAE;MACNC,IAAI,EAAEC,MAAM;MACZC,QAAQ,EAAE;IACd;EACJ,CAAC;EAEDC,IAAIA,CAAA,EAAG;IACH,OAAO;MACHC,QAAQ,EAAE,CAAC,CAAC;MACZC,SAAS,EAAE,EAAE;MACbC,SAAS,EAAE,KAAK;MAChBC,WAAW,EAAE,CAAC;MACdC,WAAW,EAAE,IAAI;MACjBC,UAAU,EAAE;QACRC,QAAQ,EAAE;UACNC,MAAM,EAAE,IAAI;UACZC,KAAK,EAAE,IAAI;UACXC,KAAK,EAAE,IAAI;UACXC,QAAQ,EAAE;QACd;MACJ,CAAC;MACDC,SAAS,EAAE,KAAK;MAChBC,UAAU,EAAE,CAAC;MACbC,cAAc,EAAE,CAAC;MACjBC,aAAa,EAAE,GAAE,GAAI,IAAG,GAAI,IAAI;MAAE;MAClCC,iBAAiB,EAAE,IAAG,GAAI,IAAG,GAAI,IAAI;MAAE;MACvCC,YAAY,EAAE;IAClB;EACJ,CAAC;EAEDC,OAAOA,CAAA,EAAG;IACNC,OAAO,CAACC,GAAG,CAAC,oCAAoC,EAAE,IAAI,CAACxB,QAAQ,CAAC;IAEhE,MAAMyB,QAAO,GAAIC,SAAS,CAACC,QAAO,IAAKD,SAAS,CAACE,YAAY;IAC7D,MAAMC,SAAQ,GAAIJ,QAAQ,CAACK,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACxC,IAAI,CAACC,QAAO,GAAIF,SAAS;IAEzB,MAAMG,YAAW,GAAIpC,QAAQ;IAC7B,IAAI,CAACS,QAAO,GAAKwB,SAAQ,IAAKG,YAAW,IAAKA,YAAY,CAACH,SAAS,CAAC,GAAIG,YAAY,CAACH,SAAS,IAAIG,YAAY,CAACC,EAAE;EACtH,CAAC;EAEDC,OAAO,EAAE;IACL;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;;IAEA;IACA;;IAEA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;EAAA;AAER","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}