{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.reduce.js\";\n/**\r\n * Primary entry point, Node.js specific entry point is MusepackParser.ts\r\n */\nimport { fromWebStream, fromBuffer, fromBlob } from 'strtok3';\nimport { ParserFactory } from './ParserFactory.js';\nimport { APEv2Parser } from './apev2/APEv2Parser.js';\nimport { hasID3v1Header } from './id3v1/ID3v1Parser.js';\nimport { getLyricsHeaderLength } from './lyrics3/Lyrics3.js';\nexport { LyricsContentType, TimestampFormat } from './type.js';\nexport { CouldNotDetermineFileTypeError, UnsupportedFileTypeError } from './ParseError.js';\nexport * from './ParseError.js';\n/**\r\n * Parse Web API File\r\n * Requires Blob to be able to stream using a ReadableStreamBYOBReader, only available since Node.js ≥ 20\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nexport async function parseBlob(blob, options = {}) {\n  const tokenizer = fromBlob(blob);\n  try {\n    return await parseFromTokenizer(tokenizer, options);\n  } finally {\n    await tokenizer.close();\n  }\n}\n/**\r\n * Parse audio from Web Stream.Readable\r\n * @param webStream - WebStream to read the audio track from\r\n * @param options - Parsing options\r\n * @param fileInfo - File information object or MIME-type string\r\n * @returns Metadata\r\n */\nexport async function parseWebStream(webStream, fileInfo, options = {}) {\n  const tokenizer = fromWebStream(webStream, {\n    fileInfo: typeof fileInfo === 'string' ? {\n      mimeType: fileInfo\n    } : fileInfo\n  });\n  try {\n    return await parseFromTokenizer(tokenizer, options);\n  } finally {\n    await tokenizer.close();\n  }\n}\n/**\r\n * Parse audio from memory\r\n * @param uint8Array - Uint8Array holding audio data\r\n * @param fileInfo - File information object or MIME-type string\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\r\n */\nexport async function parseBuffer(uint8Array, fileInfo, options = {}) {\n  const tokenizer = fromBuffer(uint8Array, {\n    fileInfo: typeof fileInfo === 'string' ? {\n      mimeType: fileInfo\n    } : fileInfo\n  });\n  return parseFromTokenizer(tokenizer, options);\n}\n/**\r\n * Parse audio from ITokenizer source\r\n * @param tokenizer - Audio source implementing the tokenizer interface\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\nexport function parseFromTokenizer(tokenizer, options) {\n  const parserFactory = new ParserFactory();\n  return parserFactory.parse(tokenizer, undefined, options);\n}\n/**\r\n * Create a dictionary ordered by their tag id (key)\r\n * @param nativeTags list of tags\r\n * @returns tags indexed by id\r\n */\nexport function orderTags(nativeTags) {\n  const tags = {};\n  for (const {\n    id,\n    value\n  } of nativeTags) {\n    (tags[id] || (tags[id] = [])).push(value);\n  }\n  return tags;\n}\n/**\r\n * Convert rating to 1-5 star rating\r\n * @param rating Normalized rating [0..1] (common.rating[n].rating)\r\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\r\n */\nexport function ratingToStars(rating) {\n  return rating === undefined ? 0 : 1 + Math.round(rating * 4);\n}\n/**\r\n * Select most likely cover image.\r\n * @param pictures Usually metadata.common.picture\r\n * @return Cover image, if any, otherwise null\r\n */\nexport function selectCover(pictures) {\n  return pictures ? pictures.reduce((acc, cur) => {\n    if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)']) return cur;\n    return acc;\n  }) : null;\n}\nexport async function scanAppendingHeaders(tokenizer, options = {}) {\n  let apeOffset = tokenizer.fileInfo.size;\n  if (await hasID3v1Header(tokenizer)) {\n    apeOffset -= 128;\n    const lyricsLen = await getLyricsHeaderLength(tokenizer);\n    apeOffset -= lyricsLen;\n  }\n  options.apeHeader = await APEv2Parser.findApeFooterOffset(tokenizer, apeOffset);\n}\n/**\r\n * Implementation only available when loaded as Node.js\r\n * This method will throw an Error, always.\r\n */\nexport async function parseFile(_filePath, _options = {}) {\n  throw new Error('This function require a Node engine. To load Web API File objects use parseBlob instead.');\n}\n/**\r\n * Implementation only available when loaded as Node.js\r\n * This method will throw an Error, always.\r\n */\nexport async function parseStream(_stream, _fileInfo, _options = {}) {\n  throw new Error('This function require a Node engine.');\n}\n/**\r\n * Return a list of supported mime-types\r\n */\nexport function getSupportedMimeTypes() {\n  return new ParserFactory().getSupportedMimeTypes();\n}","map":{"version":3,"names":["fromWebStream","fromBuffer","fromBlob","ParserFactory","APEv2Parser","hasID3v1Header","getLyricsHeaderLength","LyricsContentType","TimestampFormat","CouldNotDetermineFileTypeError","UnsupportedFileTypeError","parseBlob","blob","options","tokenizer","parseFromTokenizer","close","parseWebStream","webStream","fileInfo","mimeType","parseBuffer","uint8Array","parserFactory","parse","undefined","orderTags","nativeTags","tags","id","value","push","ratingToStars","rating","Math","round","selectCover","pictures","reduce","acc","cur","name","toLowerCase","scanAppendingHeaders","apeOffset","size","lyricsLen","apeHeader","findApeFooterOffset","parseFile","_filePath","_options","Error","parseStream","_stream","_fileInfo","getSupportedMimeTypes"],"sources":["C:/projects/My projects/Vue/osi/node_modules/music-metadata/lib/core.js"],"sourcesContent":["/**\r\n * Primary entry point, Node.js specific entry point is MusepackParser.ts\r\n */\r\nimport { fromWebStream, fromBuffer, fromBlob } from 'strtok3';\r\nimport { ParserFactory } from './ParserFactory.js';\r\nimport { APEv2Parser } from './apev2/APEv2Parser.js';\r\nimport { hasID3v1Header } from './id3v1/ID3v1Parser.js';\r\nimport { getLyricsHeaderLength } from './lyrics3/Lyrics3.js';\r\nexport { LyricsContentType, TimestampFormat } from './type.js';\r\nexport { CouldNotDetermineFileTypeError, UnsupportedFileTypeError } from './ParseError.js';\r\nexport * from './ParseError.js';\r\n/**\r\n * Parse Web API File\r\n * Requires Blob to be able to stream using a ReadableStreamBYOBReader, only available since Node.js ≥ 20\r\n * @param blob - Blob to parse\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nexport async function parseBlob(blob, options = {}) {\r\n    const tokenizer = fromBlob(blob);\r\n    try {\r\n        return await parseFromTokenizer(tokenizer, options);\r\n    }\r\n    finally {\r\n        await tokenizer.close();\r\n    }\r\n}\r\n/**\r\n * Parse audio from Web Stream.Readable\r\n * @param webStream - WebStream to read the audio track from\r\n * @param options - Parsing options\r\n * @param fileInfo - File information object or MIME-type string\r\n * @returns Metadata\r\n */\r\nexport async function parseWebStream(webStream, fileInfo, options = {}) {\r\n    const tokenizer = fromWebStream(webStream, { fileInfo: typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo });\r\n    try {\r\n        return await parseFromTokenizer(tokenizer, options);\r\n    }\r\n    finally {\r\n        await tokenizer.close();\r\n    }\r\n}\r\n/**\r\n * Parse audio from memory\r\n * @param uint8Array - Uint8Array holding audio data\r\n * @param fileInfo - File information object or MIME-type string\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n * Ref: https://github.com/Borewit/strtok3/blob/e6938c81ff685074d5eb3064a11c0b03ca934c1d/src/index.ts#L15\r\n */\r\nexport async function parseBuffer(uint8Array, fileInfo, options = {}) {\r\n    const tokenizer = fromBuffer(uint8Array, { fileInfo: typeof fileInfo === 'string' ? { mimeType: fileInfo } : fileInfo });\r\n    return parseFromTokenizer(tokenizer, options);\r\n}\r\n/**\r\n * Parse audio from ITokenizer source\r\n * @param tokenizer - Audio source implementing the tokenizer interface\r\n * @param options - Parsing options\r\n * @returns Metadata\r\n */\r\nexport function parseFromTokenizer(tokenizer, options) {\r\n    const parserFactory = new ParserFactory();\r\n    return parserFactory.parse(tokenizer, undefined, options);\r\n}\r\n/**\r\n * Create a dictionary ordered by their tag id (key)\r\n * @param nativeTags list of tags\r\n * @returns tags indexed by id\r\n */\r\nexport function orderTags(nativeTags) {\r\n    const tags = {};\r\n    for (const { id, value } of nativeTags) {\r\n        (tags[id] || (tags[id] = [])).push(value);\r\n    }\r\n    return tags;\r\n}\r\n/**\r\n * Convert rating to 1-5 star rating\r\n * @param rating Normalized rating [0..1] (common.rating[n].rating)\r\n * @returns Number of stars: 1, 2, 3, 4 or 5 stars\r\n */\r\nexport function ratingToStars(rating) {\r\n    return rating === undefined ? 0 : 1 + Math.round(rating * 4);\r\n}\r\n/**\r\n * Select most likely cover image.\r\n * @param pictures Usually metadata.common.picture\r\n * @return Cover image, if any, otherwise null\r\n */\r\nexport function selectCover(pictures) {\r\n    return pictures ? pictures.reduce((acc, cur) => {\r\n        if (cur.name && cur.name.toLowerCase() in ['front', 'cover', 'cover (front)'])\r\n            return cur;\r\n        return acc;\r\n    }) : null;\r\n}\r\nexport async function scanAppendingHeaders(tokenizer, options = {}) {\r\n    let apeOffset = tokenizer.fileInfo.size;\r\n    if (await hasID3v1Header(tokenizer)) {\r\n        apeOffset -= 128;\r\n        const lyricsLen = await getLyricsHeaderLength(tokenizer);\r\n        apeOffset -= lyricsLen;\r\n    }\r\n    options.apeHeader = await APEv2Parser.findApeFooterOffset(tokenizer, apeOffset);\r\n}\r\n/**\r\n * Implementation only available when loaded as Node.js\r\n * This method will throw an Error, always.\r\n */\r\nexport async function parseFile(_filePath, _options = {}) {\r\n    throw new Error('This function require a Node engine. To load Web API File objects use parseBlob instead.');\r\n}\r\n/**\r\n * Implementation only available when loaded as Node.js\r\n * This method will throw an Error, always.\r\n */\r\nexport async function parseStream(_stream, _fileInfo, _options = {}) {\r\n    throw new Error('This function require a Node engine.');\r\n}\r\n/**\r\n * Return a list of supported mime-types\r\n */\r\nexport function getSupportedMimeTypes() {\r\n    return new ParserFactory().getSupportedMimeTypes();\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}